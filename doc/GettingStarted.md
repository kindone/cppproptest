# Getting Started with `cppproptest`

## Running your first property-based test

`cppproptest` requires [CMake](https://cmake.org) for build tool and C++14-compliant compiler (likely be OK with latest standards).
You can examine the requirements with: 

```Shell
# at cppproptest root directory
$ cmake . -BBUILD
$ cd BUILD && make && ./test_proptest
```

You can edit your project's CMakeLists.txt to include the library `proptest`:

```CMake
ADD_SUBDIRECTORY(<path_to_cppproptest_root>)

```

And then add this library to `TARGET_LINK_LIBRARIES` section.

```
TARGET_LINK_LIBRARIES( ...
    ...
    proptest
    ...
)
```

Here's an example using [Googletest](https://github.com/google/googletest):

```cpp
// ...
#include "proptest/proptest.hpp"

using namespace proptest;

TEST(AudioCodec, EncoderDecoder)
{
    // ASSERT_FOR_ALL() is shorthand for ASSERT_TRUE(forAll(...))
    ASSERT_FOR_ALL([](SoundData soundData) {
        auto encoded = MyAudioCodec::encode(soundData);
        auto decoded = MyAudioCodec::decode(encoded);
        PROP_ASSERT_EQ(decoded, soundData);
    });
}
```

## `Property`

`property` defines a property with optional configurations. By calling `property`, you are creating a `Property` object. `forAll` is the shorthand for calling `Property`'s method `forAll`. `Property::forAll` performs property-based test using supplied callable (function, functor, or lambda). While `forAll` would work most of the time, `property` is more versatile and configurable.

```cpp
forAll([](int a, int b) -> bool {
    return a + b == b + a;
});
```

is equivalent to

```cpp
property([](int a, int b) -> bool {
    return a + b == b + a;
}).forAll();
```

### Defining a property

Defining a property requires a callable. For example, a lambda as following is such a callable with an `int` as parameter:

```cpp
[](int a) -> bool {
    return a >= 0;
}
```

Arguments are generated automatically by the framework and the return value of the function indicates success(`true`) or failure(`false`) of a property. 
Asserts can also be used to mark failures. If you prefer not to use boolean return value to indicate success/fail, you can use void return type.

```cpp
[](int a) {
    PROP_ASSERT_GE(a, 0);
}
```

In above case, the function is called with an integer argument randomly generated by the test framework. 

For a property to be checked, the framework requires generators for parameter types. Either an `Arbi<T>` (an arbitrary, the default generator for type `T`) should be defined for a parameter type, or a custom generator should be provided. In above example, a predefined generator `Arbi<int>` is used to generate an integer argument.   

You can supply a custom generator as additional argument(s) to `property()` function, as following.

```cpp
property([](int a, int b) -> bool {
    return true;
}, myIntGenerator);
```

Any remaining parameter in the property function with no custom generator supplied will be generated using an arbitrary. In above example, `int a` is generated using `myIntGenerator`, while `int b` will be generated using `Arbi<int>`. If there is no arbitrary defined for a type and no custom generator is supplied also, a compile error will be emitted. 

Many primitive types and containers have their default generators `Arbi<T>` defined by the framework for convenience.
You can find more about generators and see the full list of built-in Arbitraries in [Generators](Generators.md) page.


#### `Property::forAll`: adjusting generators

You can explicitly specify some of the generators for `forAll`, by passing them as arguments.
It's a common way to fix only some of the arguments using `just` combinator and let the rest of the parameters generated using the generators originally set.

```cpp
// a is fixed to INT_MAX, while b is randomly generated
prop.forAll(just<int>(INT_MIN));

prop.forAll(inRange<int>(-100, 100));
```

#### Using `Property::example` for testing for specific example

You might want to test for specific combination of arguments for a property defined. This can be accomplished using `Property::example(...)`. You need to specify all the parameters needed to call the callable:

```cpp
// define a property
auto prop = property([](int a, int b) -> bool {
    return a + b == b + a;
});

// check specific examples
prop.example(INT_MIN, INT_MIN);
prop.example(INT_MIN, INT_MAX);
prop.example(INT_MAX, INT_MIN);
prop.example(INT_MAX, INT_MAX);

// perform randomized test runs
prop.forAll(); 
```

#### Configuring random seed and number of runs

A property can be configured to have specific random seed. This can be done by calling `Property::setSeed(unsigned long seed)`.  Also, you can set the number of runs with `Property::setNumRuns(int num)`. The default number of runs is `1000`. 

```cpp
auto prop = property([](int a, int b) -> bool {
    // ...
});
prop.setSeed(savedSeed).setNumRuns(100).forAll();
```

You can set default number of runs affected globally by calling the static method `PropertyBase::setDefaultNumRuns(int num)`. 

```cpp
PropertyBase::setDefaultNumRuns(100);
```

if no random seed is specified, current timestamp in milliseconds is used. You can override these unspecified random seeds with an environment variable `PROPTEST_SEED`. This comes handy when you encountered a failure and its random seed value is available:

```Shell
# ... failed test with random seed 15665312
$ PROPTEST_SEED=15665312 ./my_proptest
```


### Assertions and expectations

Regarding assertions, `cppproptest` provides assertion(fatal)/expection(non-fatal) macros similar to the popular [Google Test](https://github.com/google/googletest) framework.

```cpp
// PROP_EXPECT*: non-fatal, continues upon failure
PROP_EXPECT(condition);
PROP_EXPECT_TRUE(condition);
PROP_EXPECT_FALSE(condition);
PROP_EXPECT_EQ(A, B);
PROP_EXPECT_NE(A, B);
PROP_EXPECT_LT(A, B);
PROP_EXPECT_GT(A, B);
PROP_EXPECT_LE(A, B);
PROP_EXPECT_GE(A, B);
PROP_EXPECT_STREQ(A, B, N);

// PROP_ASSERT*: fatal, breaks test upon failure
PROP_ASSERT(condition);
PROP_ASSERT_TRUE(condition);
PROP_ASSERT_FALSE(condition);
PROP_ASSERT_EQ(A, B);
PROP_ASSERT_NE(A, B);
PROP_ASSERT_LT(A, B);
PROP_ASSERT_GT(A, B);
PROP_ASSERT_LE(A, B);
PROP_ASSERT_GE(A, B);
PROP_ASSERT_STREQ(A, B, N);
```

Also, there are [Google Test](https://github.com/google/googletest) compatible macros for `forAll` that fails the gtest test case or suite upon a property test failure (since with a bare `forAll`, failures won't behave as gtest failure):

```cpp
EXPECT_FOR_ALL(...); // non-fatal, shorthand for EXPECT_TRUE(proptest::forAll(...));
ASSERT_FOR_ALL(...); // fatal, shorthand for ASSERT_TRUE(proptest::forAll(...));
```
