# Getting Started with `cppproptest`

## Your first property-based test

`cppproptest` requires [CMake](https://cmake.org) for build tool and a C++14-compliant compiler.
You can examine the requirements with: 

```Shell
# at cppproptest root directory
$ cmake . -BBUILD
$ cd BUILD && make && ./test_proptest
```

You can edit your project's CMakeLists.txt to include the library `proptest`:

```CMake
ADD_SUBDIRECTORY(<path_to_cppproptest_root>)

...

TARGET_LINK_LIBRARIES( ...
    ...
    proptest
    ...
)
```

Here's an example test based on [Googletest](https://github.com/google/googletest):

```cpp
// ...
#include "proptest/proptest.hpp"

using namespace PropertyBasedTesting;

TEST(AudioCodec, EncoderDecoder)
{
    ASSERT_TRUE(forAll([](SoundData soundData) {
        auto encoded = MyAudioCodec::encode(soundData);
        auto decoded = MyAudioCodec::decode(encoded);
        PROP_ASSERT_EQ(decoded, soundData);
    }));
}
```

## `property` and `forAll`

`property` defines a property with optional configuration and `forAll` is the shorthand for `Property::forAll`.
`Property::forAll` performs property-based test using supplied callable (function, functor, or lambda).

```cpp
forAll([](int a, int b) -> bool {
    return a + b == b + a;
});
```

is equivalent to

```cpp
property([](int a, int b) -> bool {
    return a + b == b + a;
}).forAll();
```

### Defining a property
Defining a property requires a callable. For example, a lambda as following is such a callable with an `int` as parameter:

```cpp
[](int a) -> bool {
    return a >= 0;
}
```

Arguments are generated automatically by the framework and the return value of the function indicates success(`true`) or failure(`false`) of a property. 

If you prefer asserts over boolean return status value, you can omit it.

```cpp
[](int a) -> bool {
    PROP_ASSERT_GE(a, 0);
}
```

In above case, the function is called with an integer argument randomly generated by the test framework. 

For a property to be checked, the framework requires generators for parameter types. Either an `Arbitrary<T>` should be defined for a parameter type, or a custom generator should be provided. In above example, a predefined generator `Arbitrary<int>` is used to generate an integer argument.

You can supply a custom generator as additional argument(s) to `property()` function, as following.

```cpp
property([](int a) -> bool {
    return true;
}, myIntGenerator);
```

Many primitive types and containers have their `Arbitrary<T>` defined by the framework for convenience.

&nbsp;

## Generators and Arbitraries

You can use generators to generate randomized arguments for properties.

A generator is a callable (function, functor, or lambda) with following signature:

```cpp
(Random&) -> Shrinkable<T>
```

You can refer to [`Shrinkable`](doc/Shrinking.md) for further detail, but you can basically treat it as a wrapper for a value of type T here. So a generator generates a value of type T from a random generator. A generator can be defined as functor or lambda, as you would prefer.  

```cpp
auto myIntGen = [](Random& rand) {
    int smallInt = rand.getRandomInt8();
    return make_shrinkable<int>(smallInt);
};
```

An `Arbitrary` refers to default generators for a type. You can additionaly define an `Arbitrary<T>` for your type `T`. By defining an `Arbitrary`, you can omit the custom generator argument that was needed to be passed everytime you defined a property for that type. Following shows an example for defining an `Arbitrary`. Note that it should be defined under `PropertyBasedTesting` namespace in order to be accessible in the framework.

```cpp
namespace PropertyBasedTesting {

struct Arbitrary<Car> : Gen<Car> {
  Shrinkable<Car> operator()(Random& rand) {
    bool isAutomatic = rand.getRandomBool();
    return make_shrinkable<Car>(isAutomatic);
  }
};

}
```

There are useful helpers for creating new generators from existing ones. You can find the full list in [Generators](doc/Generators.md) page. 

`suchThat` is such a helper. It selectively generates values that satisfies a criteria function. Following is an even number generator from the integer `Arbitrary`.

```cpp
auto anyIntGen = Arbitrary<int>();
// generates even numbers
auto evenGen = suchThat<int>(anyIntGen, [](const int& num) {
    return num % 2 == 0;
});
```
