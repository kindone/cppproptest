## Property-based testing

Property-based testing originated from [QuickCheck](https://en.wikipedia.org/wiki/QuickCheck) of Haskell. 
Its basic idea is to quickly prove a theorem, as the name suggests. 
User can define an abstract property of the system under test, letting the test framework prove or disprove the property with massive input combinations.

A property is in the form of function `(Input0, ... , InputN) -> bool`

```cpp
[](int a, int b) -> bool {
    return a + b == b+ a;
}
```

A property-based testing framework attempts to generate combinations of `a` and `b` and validate the function whether it always returns `true` for all the combinations. 

> OK, passed 1000 tests

or 

> Falsifiable after 12 tests, where
>   a = 4,
>   b = -4



## `property` and `check`

`property` defines a property with optional configuration and `check` is shorthand for`Property::check`.
`Property::check` performs property-based test using given callable (a function, a functor, or a lambda).

```cpp
check([](int a, int b) -> bool {
    return a + b == b + a;
});
```

is equivalent to

```cpp
property([](int a, int b) -> bool {
    return a + b == b + a;
}).check();
```

### Defining properties
Defining a property requires a callable with following signature:

```cpp
(arg1, ..., argN) -> bool
```

For example, a lambda as following is such callable with an int as parameter:

```cpp
[](int a) -> bool {
    return true;
}
```

Arguments are to be generated automatically by the framework and the return value of the function indicates success(`true`) or failure(`false`) of a property.
In above case, the function is called with an integer argument `a` randomly generated by the test framework. 

For a property to be defined, the framework requires a generator for parameter type. Either an `Arbitrary<T>` should be defined for a parameter type, or a custom generator is provided. In above example, a predefined generator `Arbitrary<int>` is used to generate an integer argument.

You can supply a custom generator as additional argument(s) to `property()` function, as following.

```cpp
property([](int a) -> bool {
    return true;
}, myIntGenerator);
```

Many primitive types and containers have their `Aribtrary<T>` defined by the framework for convenience.

## Generators and Arbitraries

You can use generators to generate randomized arguments for properties.

A generator is a callable (function, functor, or lambda) with following signature:

```cpp
(Random&) -> Shrinkable<T>
```

You can refer to `Shrinkable` for further detail, but you can treat it as a wrapper for a type T here. The main point is that this generates a value of type T from a random generator. A generator can be defined as functor or lambda, as you prefer.  

```cpp
auto myIntGen = [](Random& rand) {
    int smallInt = rand.getRandomInt8();
    return make_shrinkable<int>(smallInt);
};
```

An `Arbitrary` refers to default generators for a type. You can freely define an `Arbitrary<T>` for your type `T`. By defining an `Arbitrary`, you can omit a custom generator to be passed everytime you define a property for the type. Following shows an example for defining an `Arbitrary`

```cpp
namespace PropertyBasedTesting {

struct Arbitrary<Car> : Gen<Car> {
  Shrinkable<Car> operator()(Random& rand) {
    bool isAutomatic = rand.getRandomBool();
    return make_shrinkable<Car>(isAutomatic);
  }
};

}
```

## Further topics and details of the framework can be found in:

* [Using and Defining Generators](doc/Generators.md)
* [Counter Examples and Shrinking](doc/Shrinking.md)
* [Stateful Testing with Property-based Testing Framework](doc/statefulTesting.md)
* [Concurrency Testing with Property-based Testing Framework](doc/ConcurrencyTesting.md)
* [Advanced Mocking with Property-based Testing Framework](doc/Mocking.md)

