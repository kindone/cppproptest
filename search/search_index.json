{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"cppproptest","text":"<p><code>cppproptest</code> is a property-based testing library for C++. It focuses on usability with following features included:</p> <ul> <li> <p>Out-of-box generators for primitives and standard containers. See the full list of built-in generators for more.</p> </li> <li> <p>Versatile generator combinators for creating custom generators based on existing generators. See generator combinators for more.</p> </li> <li>Shrinking for automated debugging support</li> <li>Stateful testing support for testing state changes</li> <li>Concurrency testing support for testing concurrent state changes</li> </ul> <p>You can get started with <code>cppproptest</code> on this page.</p> <p> </p>"},{"location":"#why-property-based-testing","title":"Why Property-based testing?","text":""},{"location":"#generalization-and-abstraction","title":"Generalization and abstraction","text":"<p>Property-based testing, or PBT in short, lets you write a test using abstract idea, instead of some dummy examples or contrived scenarios that are either too trivivial or too complicated. You can write tests using specification or requirements - which are essentially  combination of input domain (=generators) and expected behavior (=properties) of the tested component.</p> <p>Property-based tests can immediately replace example-based tests, such as:</p> <pre><code>MyEncoder encoder;\nMyDecoder decoder;\nauto original = \"Some dummy content that hopefully prove or disprove this encoder/decoder works\";\nauto encoded = encoder.encode(original);\nauto decoded = decoder.decode(encoded);\nASSERT_EQ(original, decoded);\n</code></pre> <p>When this is turned into a property-based test, it fully tests the components against arbitrary input strings:</p> <pre><code>forAll([](std::string original) {\n// a text encoded and then decoded must be identical to original\nMyEncoder encoder;\nMyDecoder decoder;\nauto encoded = encoder.encode(original);\nauto decoded = decoder.decode(encoded);\nPROP_ASSERT_EQ(original, decoded);\n});\n</code></pre> <p>Example inputs were turned into fully randomized inputs. As a result, we can say with higher confidence that the tested component works with more general input domain.</p>"},{"location":"#clear-separation-of-variants-and-invariants","title":"Clear separation of variants and invariants","text":"<p>Describing a test using input domain and expected behavior means that we have clear cut between variants and invariants. We often mix variants and invariants in our tests in typical example-based tests. This is one of the reasons why those tests become hard to maintain and difficult to read over time. With property-based tests, however, we can clearly separate invariants as properties and variants as input domain. Thus tests become more readable, gets easier to maintain, and carry test writers' intention better.</p>"},{"location":"#convenience-and-versatility","title":"Convenience and versatility","text":"<p>Property-based testing often provides with the convenient out-of-box generators and combinators (that lets you make new generators out of existing ones), and lets you to effortlessly define the input domain for your tests. You can specify your input domains using various notions - range, constraint, union, transformation, composition, and dependency, just to name a few.</p> <pre><code>// a tailored string generator\nauto stringGen = Arbitrary&lt;int&gt;()\n.filter([] (int&amp; num) { num % 2 == 0; }) // even numbers only\n.map([] (int&amp; num) {\nreturn \"&lt;\" + std::to_string(numStr) + \"&gt;\"; // string like \"&lt;0&gt;\", ..., \"&lt;n&gt;\"\n});\n\n// property\nforAll([](std::string original) {\n// ... //\n}, stringGen);\n</code></pre> <p>The framework identifies the parameter types of a given property function. It then automatically feeds in the randomly generated values of those types to the function. Any number of parameters of simple or complex types can be used to test a property:</p> <pre><code>forAll([](int a, long b, float c, std::string d, std::vector&lt;std::string&gt; e, std::map&lt;int, std::string&gt; e) {\n// Do stuff with a, b, ..., and e\n});\n</code></pre> <p>Given this powerful generation engine, we can fully parameterize and randomize our tests with high flexibility but little effort. You don't need to care too much about how to test your requirements. Much of it is automatically done for you by the framework.</p>"},{"location":"#reusability-and-scalability","title":"Reusability and Scalability","text":"<p>As it defines input domain with generators and combinators, Property-based testing lets you define and reuse existing input domain and properties to build new input domain and properties with ease. These new ones then can be reused as building blocks for next tests and so on. Reusable nature of property-based testing lets you write tests with scale. Complex combinations of components can be readily tested if simpler pieces are already available by tests written previously.</p> <p> </p>"},{"location":"#further-topics-and-details","title":"Further topics and details:","text":"<ul> <li>Getting Started with cppproptest</li> <li>Introduction to generators<ul> <li>Arbitraries</li> <li>Built-in generators</li> </ul> </li> <li>Generator combinators for creating generators from existing ones</li> <li>Counterexamples and notion of shrinking for automated debugging</li> <li>Printing facilities</li> <li>Stateful testing with <code>cppproptest</code></li> <li>Concurrency testing with <code>cppproptest</code></li> <li>Advanced mocking with <code>cppproptest</code> (work in progress)</li> </ul>"},{"location":"Combinators/","title":"Generator Combinators","text":"<p>Generator combinators are provided for building a new generator based on existing ones. Many of them come from ideas and best practices of functional programming. They can be chained as they receive existing generator(s) as argument and returns new generator.</p> <p>While you can go through this document from top to the bottom, you might be want to find a suitable combinator for your use case using this table:</p> Purpose Examples Related Generator/Combinator Generate just a constant <code>0</code> or <code>\"1337\"</code> <code>just&lt;T&gt;</code> Generate a list of unique values <code>{3,5,1}</code> but not <code>{3,5,5}</code> <code>Arbi&lt;set&lt;T&gt;&gt;</code> Generate a value within numeric range of values a number within <code>1</code>~<code>9999</code> <code>interval&lt;T&gt;</code>, <code>integers&lt;T&gt;</code> Generate a value within a set of values a prime number under 100 <code>elementOf&lt;T&gt;</code> Generate a pair or a tuple of different types a <code>pair&lt;int, string&gt;</code> <code>pairOf&lt;T1,T2&gt;</code>, <code>tupleOf&lt;Ts...&gt;</code> Union multiple generators <code>20~39</code> or <code>60~79</code> combined <code>unionOf&lt;T&gt;</code> (<code>oneOf&lt;T&gt;</code>) Transform into another type or a value <code>\"0\"</code> or <code>\"1.4\"</code> (a number as string). <code>transform&lt;T,U&gt;</code> Generate a struct or a class object a <code>Rectangle</code> object with width and height <code>construct&lt;T,ARGS...&gt;</code> Apply constraints in generated values an even natural number (<code>n % 2 == 0</code>) <code>filter</code> (<code>suchThat</code>) Generate values with dependencies or relationships a rectangle where <code>width == height * 2</code> <code>dependency</code>, <code>chain</code>, <code>pairWith</code>, <code>tupleWith</code> <p> </p>"},{"location":"Combinators/#basic-generator-combinators","title":"Basic Generator Combinators","text":""},{"location":"Combinators/#constants","title":"Constants","text":"<ul> <li><code>just&lt;T&gt;(T*)</code> or <code>just&lt;T&gt;(T)</code>: always generates specific value</li> <li><code>lazy&lt;T&gt;(std::function&lt;T()&gt;)</code>: generates a value by calling a function     <pre><code>auto zeroGen = just(0); // template argument is optional if type is deducible\nauto oneGen = lazy&lt;int&gt;([]() { return 1; });\n</code></pre></li> </ul>"},{"location":"Combinators/#integers-and-intervals","title":"Integers and intervals","text":"<p>Some utility generators for integers are provided</p> <ul> <li><code>interval&lt;INT_TYPE&gt;(min, max)</code>: generates an integer type(e.g. <code>uint16_t</code>) in the closed interval <code>[min, max]</code>.</li> <li><code>integers&lt;INT_TYPE(from, count)</code>: generates an integer type starting from <code>from</code> <pre><code>interval&lt;int64_t&gt;(1, 28);\ninterval(1, 48); // template type argument can be ommitted if the input type(`int`) is the same as the output type.\ninterval(1L, 48L); // template type argument can be ommitted if the input type(`int`) is the same as the output type.\ninterval(0, 10); // generates an integer in {0, ..., 10}\ninterval('A', 'Z'); // generates a char of uppercase alphabet\nintegers(0, 10); // generates an integer in {0, ..., 9}\nintegers(1, 10); // generates an integer in {1, ..., 10}\n</code></pre></li> <li><code>natural&lt;INT_TYPE&gt;(max)</code>: generates a positive integer up to <code>max</code>(inclusive)</li> <li><code>nonNegative&lt;INT_TYPE&gt;(max)</code>: : generates zero or a positive integer up to <code>max</code>(inclusive)</li> </ul>"},{"location":"Combinators/#selecting-from-values","title":"Selecting from values","text":"<p>You may want to random choose from specific list of values.</p> <ul> <li> <p><code>elementOf&lt;T&gt;(val1, ..., valN)</code>: generates a type <code>T</code> from multiple values for type <code>T</code>, by choosing one of the values randomly     <pre><code>// generates a prime number under 100\nauto primeGen = elementOf&lt;int&gt;(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97);\n</code></pre></p> <ul> <li><code>elementOf</code> can receive optional probabilitistic weights (<code>0 &lt; weight &lt; 1</code>, sum of weights must not exceed 1.0) for generators. If weight is unspecified for a generator, it is calculated automatically so that remaining probability among unspecified generators is evenly distributed. <code>weightedVal(&lt;value&gt;, &lt;weight&gt;)</code> is used to annotate the desired weight.</li> </ul> <pre><code>// generates a numeric within ranges [0,10], [100, 1000], [10000, 100000]\nelementOf&lt;int&gt;(weightedVal(2, 0.8), weightedVal(5, 0.15), 10/* weight automatically becomes 1.0 - (0.8 + 0.15) == 0.05 */);\n</code></pre> </li> </ul>"},{"location":"Combinators/#pair-and-tuples","title":"Pair and Tuples","text":"<p>Generators for different types can be bound to a pair or a tuple.</p> <ul> <li> <p><code>pairOf&lt;T1, T2&gt;(gen1, gen2)</code> : generates a <code>std::pair&lt;T1,T2&gt;</code> based on result of generators <code>gen1</code> and <code>gen2</code></p> <pre><code>auto pairGen = pairOf(Arbi&lt;int&gt;(), Arbi&lt;std::string&gt;());\n</code></pre> </li> <li> <p><code>tupleOf&lt;T1, ..., TN&gt;(gen1, ..., genN)</code>: generates a <code>std::tuple&lt;T1,...,TN&gt;</code> based on result of generators <code>gen1</code> through <code>genN</code></p> <pre><code>auto tupleGen = tupleOf(Arbi&lt;int&gt;(), Arbi&lt;std::string&gt;(), Arbi&lt;double&gt;());\n</code></pre> </li> </ul> <p> </p>"},{"location":"Combinators/#advanced-generator-combinators","title":"Advanced Generator Combinators","text":""},{"location":"Combinators/#selecting-from-generators","title":"Selecting from generators","text":"<p>You can combine generators to a single generator that can generate each of them with some probability. This can be considered as taking a union of generators.</p> <ul> <li> <p><code>oneOf&lt;T&gt;(gen1, ..., genN)</code>: generates a type <code>T</code> from multiple generators for type <code>T</code>, by choosing one of the generators randomly</p> <pre><code>// generates a numeric within ranges [0,10], [100, 1000], [10000, 100000]\nauto evenGen = oneOf&lt;int&gt;(interval(0, 10), interval(100, 1000), interval(10000, 100000));\n</code></pre> <ul> <li><code>oneOf</code> can receive optional probabilitistic weights (<code>0 &lt; weight &lt; 1</code>, sum of weights must not exceed 1.0) for generators. If weight is unspecified for a generator, it is calculated automatically so that remaining probability among unspecified generators is evenly distributed. <code>weightedGen(&lt;generator&gt;, &lt;weight&gt;)</code> is used to annotate the desired weight.</li> </ul> <p><pre><code>// generates a numeric within ranges [0,10], [100, 1000], [10000, 100000]\nauto evenGen = oneOf&lt;int&gt;(weightedGen(interval(0, 10), 0.8), weightedGen(interval(100, 1000), 0.15), interval(10000, 100000)/* weight automatically becomes 1.0 - (0.8 + 0.15) == 0.05 */);\n</code></pre> * <code>unionOf&lt;T&gt;</code> is an alias of <code>oneOf&lt;T&gt;</code></p> </li> </ul>"},{"location":"Combinators/#constructing-an-object","title":"Constructing an object","text":"<p>You can generate an object of a class or a struct type <code>T</code>, by calling a matching constructor of <code>T</code>.</p> <ul> <li> <p><code>construct&lt;T, ARG1, ..., ARGN&gt;([gen1, ..., genM])</code>: generates an object of type <code>T</code> by calling its constructor that matches the signature <code>(ARG1, ..., ARGN)</code>. Custom generators <code>gen1</code>,..., <code>genM</code> can be supplied for generating arguments. If <code>M &lt; N</code>, then rest of the arguments are generated with <code>Arbi</code>s.</p> <pre><code>struct Coordinate {\nCoordinate(int x, int y) {\n// ...\n}\n};\n// ...\nauto coordinateGen1 = construct&lt;Coordinate, int, int&gt;(interval(-10, 10), interval(-20, 20));\nauto coordinateGen2 = construct&lt;Coordinate, int, int&gt;(interval(-10, 10)); // y is generated with Arbi&lt;int&gt;\n</code></pre> </li> </ul>"},{"location":"Combinators/#applying-constraints","title":"Applying constraints","text":"<p>You can add a filtering condition to a generator to restrict the generated values to have certain constraint.</p> <ul> <li> <p><code>filter&lt;T&gt;(gen, condition_predicate)</code>:  generates a type <code>T</code> that satisfies condition predicate (<code>condition_predicate</code> returns <code>true</code>)</p> <p><pre><code>// generates even numbers\nauto evenGen = filter&lt;int&gt;(Arbi&lt;int&gt;(),[](int&amp; num) {\nreturn num % 2 == 0;\n});\n</code></pre> * <code>suchThat&lt;T&gt;</code>: an alias of <code>filter</code></p> </li> </ul>"},{"location":"Combinators/#transforming-or-mapping","title":"Transforming or mapping","text":"<p>You can transform an existing generator to create new generator by providing a transformer function. This is equivalent to mapping in functional programming context.</p> <ul> <li> <p><code>transform&lt;T,U&gt;(gen, transformer)</code>: generates type <code>U</code> based on generator for type <code>T</code>, using <code>transformer</code> that transforms a value of type <code>T</code> to type <code>U</code></p> <pre><code>// generates string from integers (e.g. \"0\", \"1\", ... , \"-16384\")\nauto numStringGen = transform&lt;int, std::string&gt;(Arbi&lt;int&gt;(),[](int&amp; num) {\nreturn std::string(num);\n});\n</code></pre> </li> </ul>"},{"location":"Combinators/#deriving-or-flat-mapping","title":"Deriving or flat-mapping","text":"<p>Another combinator that resembles <code>transform</code> is <code>derive</code>. This is equivalent to flat-mapping or binding in functional programming. Difference to <code>transform&lt;T,U&gt;</code> is that you can have greater control on the resultant generator.</p> <ul> <li> <p><code>derive&lt;T, U&gt;(genT, genUGen)</code>: derives a new generator for type <code>U</code>, based on result of <code>genT</code>, which is a generator for type <code>T</code>.</p> <pre><code>// generates a string something like \"KOPZZFASF\", \"ghnpqpojv\", or \"49681002378\", ... that consists of only uppercase/lowercase alphabets/numeric characters.\nauto stringGen = derive&lt;int, std::string&gt;(integers(0, 2), [](int&amp; num) {\nif(num == 0)\nreturn Arbi&lt;std::string&gt;(interval('A', 'Z'));\nelse if(num == 1)\nreturn Arbi&lt;std::string&gt;(interval('a', 'z'));\nelse // num == 2\nreturn Arbi&lt;std::string&gt;(interval('0', '9'));\n});\n</code></pre> </li> </ul> <p>Following table compares <code>transform</code> and <code>derive</code>:</p> Combinator transformer signature Result type <code>transform&lt;T,U&gt;</code> <code>function&lt;U(T)&gt;</code> <code>Generator&lt;U&gt;</code> <code>derive&lt;T,U&gt;</code> <code>function&lt;Generator&lt;U&gt;(T)&gt;</code> <code>Generator&lt;U&gt;</code>"},{"location":"Combinators/#values-with-dependencies","title":"Values with dependencies","text":"<p>You may want to include dependency in the generated values. There are two variants that do this. One generates a pair and the other one generates a tuple.</p> <ul> <li> <p><code>dependency&lt;T,U&gt;(genT, genUgen)</code>: generates a <code>std::pair&lt;T,U&gt;</code> with a generator <code>genT</code> for type <code>T</code> and <code>genUgen</code>. <code>genUgen</code> receives a type <code>T</code> and returns a generator for type <code>U</code>. This can effectively create a generator for a pair where second item depends on the first one.</p> <pre><code>auto sizeAndVectorGen = dependency&lt;int, std::vector&lt;bool&gt;&gt;(Arbi&lt;bool&gt;(), [](int&amp; num) {\nauto vectorGen = Arbi&lt;std::vector&lt;int&gt;&gt;();\nvectorGen.maxLen = num;\n// generates a vector with maximum size of num\nreturn vectorGen;\n});\n\nauto nullableIntegers = dependency&lt;bool, int&gt;(Arbi&lt;bool&gt;(), [](bool&amp; isNull) {\nif(isNull)\nreturn just&lt;int&gt;(0);\nelse\nreturn fromTo&lt;int&gt;(10, 20);\n});\n</code></pre> </li> <li> <p><code>chain&lt;Ts..., U&gt;(genT, genUgen)</code>: similar to <code>dependency</code>, but takes a tuple generator for <code>std::tuple&lt;Ts...&gt;</code> and generates a <code>std::tuple&lt;Ts..., U&gt;</code> instead of a <code>std::pair</code>. <code>chain</code> can be repeatedly applied to itself, and results in a tuple one element larger than the previous one. You can chain multiple dependencies with this form.</p> <pre><code>auto yearMonthGen = tupleOf(fromTo(0, 9999), fromTo(1,12));\n// number of days of month depends on month (28~31 days) and year (whether it's a leap year)\nauto yearMonthDayGen = chain&lt;std::tuple&lt;int, int&gt;, int&gt;(yearMonthGen, [](std::tuple&lt;int,int&gt;&amp; yearMonth) {\nint year = std::get&lt;0&gt;(yearMonth);\nint month = std::get&lt;1&gt;(yearMonth);\nif(monthHas31Days(month)) {\nreturn fromTo(1, 31);\n}\nelse if(monthHas30Days(month)) {\nreturn fromTo(1, 30);\n}\nelse { // february has 28 or 29 days\nif(isLeapYear(year))\nreturn fromTo(1, 29);\nelse\nreturn fromTo(1, 28);\n}\n}); // yearMonthDayGen generates std::tuple&lt;int, int, int&gt; of (year, month, day)\n</code></pre> </li> </ul> <p>Actually you can achieve the similar goal using <code>filter</code> combinator:</p> <pre><code>    // generate any year,month,day combination\nauto yearMonthDayGen = tupleOf(fromTo(0, 9999), fromTo(1,12), fromTo(1,31));\n// apply filter\nauto validYearMonthDayGen = yearMonthDayGen.filter([](std::tuple&lt;int,int,int&gt;&amp; ymd) {\nint year = std::get&lt;0&gt;(ymd);\nint month = std::get&lt;1&gt;(ymd);\nint day = std::get&lt;2&gt;(ymd);\nif(monthHas31Days(month) &amp;&amp; day &lt;= 31)\nreturn true;\nelse if(monthHas30Days(month) &amp;&amp; day &lt;= 30)\nreturn true;\nelse { // february has 28 or 29 days\nif(isLeapYear(year) &amp;&amp; day &lt;= 29)\nreturn true;\nelse\nreturn day &lt;= 28;\n}\n});\n</code></pre> <p>However, using <code>filter</code> for generating values with complex dependency may result in many generated values that do not meet the constraint to be discarded and retried. Therefore it's usually not recommended for that purpose if the ratio of discarded values is high.</p>"},{"location":"Combinators/#utility-methods-in-standard-generators","title":"Utility methods in standard generators","text":"<p>Standard generators and combinators (including <code>Arbi&lt;T&gt;</code> and <code>Construct&lt;...&gt;</code>) returns a <code>Generator&lt;T&gt;</code>, which is of the form <code>(Random&amp;) -&gt; Shrinkable&lt;T&gt;</code> (aliased as <code>GenFunction&lt;T&gt;</code>), but has additional combinator methods decorated for ease of use. They in fact have equivalent standalone counterparts. Following table shows this relationship:</p> Decorated method Result type Equivalent Standalone combinator <code>Generator&lt;T&gt;::filter</code> <code>Generator&lt;T&gt;</code> <code>filter&lt;T&gt;</code> <code>Generator&lt;T&gt;::map&lt;U&gt;</code> <code>Generator&lt;U&gt;</code> <code>transform&lt;T,U&gt;</code> <code>Generator&lt;T&gt;::flatMap&lt;U&gt;</code> <code>Generator&lt;U&gt;</code> <code>derive&lt;T,U&gt;</code> <code>Generator&lt;T&gt;::pairWith&lt;U&gt;</code> <code>Generator&lt;std::pair&lt;T,U&gt;&gt;</code> <code>dependency&lt;T,U&gt;</code> <code>Generator&lt;T&gt;::tupleWith&lt;U&gt;</code> <code>Generator&lt;std::tuple&lt;T,U&gt;&gt;</code> <code>chain&lt;T,U&gt;</code> <code>Generator&lt;std::tuple&lt;Ts...&gt;&gt;::tupleWith&lt;U&gt;</code> <code>Generator&lt;std::tuple&lt;Ts...,U&gt;&gt;</code> <code>chain&lt;std::tuple&lt;Ts...&gt;,U&gt;</code> <p>These functions and methods can be continuously chained.</p> <ul> <li> <p><code>.map&lt;U&gt;(mapper)</code>: effectively calls <code>transform&lt;T,U&gt;(gen, transformer)</code> combinator on itself with type <code>T</code> and generator <code>gen</code>.</p> <pre><code>// generator for strings of arbitrary number\nArbi&lt;int&gt;().map&lt;std::string&gt;([](int &amp;num) {\nreturn std::to_string(num);\n});\n// this is equivalent to:\ntransform&lt;int, std::string&gt;(Arbi&lt;int&gt;(), [](int &amp;num) {\nreturn std::to_string(num);\n});\n</code></pre> </li> <li> <p><code>.filter(filterer)</code>: apply <code>filter</code> combinator on itself.</p> <pre><code>// two equivalent ways to generate random even numbers\nauto evenGen = Arbi&lt;int&gt;().filter([](int&amp; num) {\nreturn num % 2 == 0;\n});\n\nauto evenGen = filter&lt;int&gt;(Arbi&lt;int&gt;(),[](int&amp; num) {\nreturn num % 2 == 0;\n});\n</code></pre> </li> <li> <p><code>.flatMap&lt;U&gt;(genUGen)</code>: based on generated result of the generator object itself, induces a new generator for type <code>U</code>. It's equivalent combinator is <code>derive&lt;T,U&gt;</code>. Difference to <code>.map&lt;U&gt;</code> (or <code>transform&lt;T,U&gt;</code>) is that you can have greater control on the resultant generator.</p> <pre><code>auto stringGen = Arbi&lt;int&gt;().flatMap&lt;std::string&gt;([](int&amp; num) {\nauto genString = Arbi&lt;std::string&gt;();\ngenString.setMaxSize(num);\nreturn genString;\n});\n</code></pre> </li> <li> <p><code>.pairWith&lt;U&gt;(genUGen)</code> or <code>tupleWith&lt;U&gt;(genUGen)</code>: chains itself to create a generator of pair or tuple. Equivalent to <code>dependency</code> or <code>chain</code>, respectively.     <pre><code>Arbi&lt;bool&gt;().tupleWith&lt;int&gt;([](bool&amp; isEven) {\nif(isEven)\nreturn Arbi&lt;int&gt;().filter([](int&amp; value) {\nreturn value % 2 == 0;\n});\nelse\nreturn Arbi&lt;int&gt;().filter([](int&amp; value) {\nreturn value % 2 == 1;\n});\n}).tupleWith&lt;std::string&gt;([](std::tuple&lt;bool, int&gt;&amp; tuple) {\nint size = std::get&lt;1&gt;(tuple);\nauto stringGen = Arbi&lt;std::string&gt;();\nstringGen.setSize(size);\nreturn stringGen;\n});\n</code></pre></p> <p>Notice <code>tupleWith</code> can automatically chain a tuple generator of <code>n</code> parameters into a tuple generator of <code>n+1</code> parameters (<code>bool</code> generator -&gt; <code>tuple&lt;bool, int&gt;</code> generator -&gt; <code>tuple&lt;bool, int, string&gt;</code> generator in above example)</p> </li> </ul>"},{"location":"ConcurrencyTesting/","title":"Concurrency Testing","text":"<p>Once you're familiar with stateful testing, you can get acquanted with concurrent stateful testing easily. Concurrency testing performs interleaved state transitions using multiple threads in parallel to see if any anomaly or breaking of requirement can be found.</p> <p>Actually, a concurrency test is almost immediately achievable when you have prepared a stateful test for an object type. Following depicts a concurrent test for <code>std::vector&lt;int&gt;</code> with <code>push_back(int)</code>, <code>pop_back()</code>, and <code>clear()</code> actions included.</p> <pre><code>using namespace proptest;\nusing namespace proptest::concurrent;\n\n// ...\n\nauto pushBackGen = Arbi&lt;int&gt;().map&lt;SimpleAction&lt;std::vector&lt;int&gt;&gt;&gt;([](int&amp; value) {\nreturn [value](std::vector&lt;int&gt;&amp; obj) {\nobj.push_back(value);\nreturn true;\n};\n});\n\nauto popBackGen = just&lt;SimpleAction&lt;std::vector&lt;int&gt;&gt;&gt;([](std::vector&lt;int&gt;&amp; obj) {\nif (obj.empty())\nreturn true;\nobj.pop_back();\nreturn true;\n});\n\nauto clearGen = just&lt;SimpleAction&lt;std::vector&lt;int&gt;&gt;&gt;([](std::vector&lt;int&gt;&amp; obj) {\nobj.clear();\nreturn true;\n});\n\nauto actionListGen = actionListGenOf&lt;std::vector&lt;int&gt;&gt;(pushBackGen, popBackGen, clearGen);\nauto concurrentProp = concurrency&lt;std::vector&lt;int&gt;&gt;(Arbi&lt;std::vector&lt;int&gt;&gt;(), actionListGen);\nconcurrentProp.go();\n</code></pre> <p>You may have noticed that, this test would lead to various exceptions or crashes, as <code>std::vector</code> is not made for concurrent writes, unless some synchronization mechanism is present.</p> <p>You can also add a post-check to be performed after each concurrent test run, by adding a post-check function as an argument to <code>check()</code>:</p> <pre><code>concurrentProp.go([](std::vector&lt;int&gt;&amp; obj) {\n// ... post-check. perform some consistency check for obj\n});\n\n// variant with a model\nconcurrentProp.go([](std::vector&lt;int&gt;&amp; obj, VectorModel&amp; model) {\n// ... post-check. perform some consistency check for obj against model\n});\n</code></pre> <p>In concurrent tests, you should be cautious about validation. Your model object as well as the stateful object can be concurrently accessed. Adding synchronization primitives for model object can cause serialization to occur on stateful object, too. This is why a post-check comes handy, as you don't need to care about synchronization since it's performed after all actions are finished.</p>"},{"location":"Generators/","title":"Generating Inputs","text":""},{"location":"Generators/#generators-in-property-based-testing","title":"Generators in Property-based testing","text":"<p>Property-based testing clearly separates concepts of input domain and property. Generators are the representation of input domain for a property-based test. A generator is basically a function that can generate random values with some constraint. A simple <code>forAll</code> statement depends on generators under the hood:</p> <pre><code>forAll([](int age, std::string name) {\n});\n</code></pre> <p>Above <code>forAll</code> takes a function having parameters of types <code>int</code> and <code>std::string</code>. This function is the property function. If no additional information on how to generate values for <code>age</code> and <code>name</code> as in this example, the parameter types are extracted and then used to invoke the default generators for those types. In this case, it calls default generators for <code>int</code> and <code>std::string</code>. Those default generators are called arbitraries. This code is actually equivalent to:</p> <pre><code>forAll([](int age, std::string name) {\n}, Arbitrary&lt;int&gt;(), Arbitrary&lt;std::string&gt;());\n</code></pre> <p>Notice the extra arguments <code>Arbitrary&lt;int&gt;()</code> and <code>Arbitrary&lt;std::string&gt;()</code>. As you can see, <code>forAll</code> actually needs some information how to generate values of the parameter types. They can be ommitted if you're using the defaults, the arbitraries.</p> <p> </p>"},{"location":"Generators/#arbitraries-the-globally-default-generators","title":"Arbitraries - The globally default generators","text":""},{"location":"Generators/#arbitrary-lets-you-omit-generator-arguments","title":"Arbitrary lets you omit generator arguments","text":"<p>An <code>Arbitrary&lt;T&gt;</code> or its alias <code>Arbi&lt;T&gt;</code> is a generator type (that also coerces to <code>GenFunction&lt;T&gt;</code>). These generator types are specially treated in <code>cppproptest</code>. An arbitrary serves as globally defined default generator for the type. If a default generator for a type is available, <code>cppproptest</code> uses that generator to generate a value of that type, if no other generator is specified.</p> <pre><code>// if there is no default generator available, you must provide a generator for the type.\nforAll([](SomeNewType x) {\n}, someNewTypeGen);\n\n\n// if there is a default generator (Arbitrary&lt;SomeType&gt;) available, you may use that generator by omitting the argument\nforAll([](SomeType x) {\n});\n</code></pre>"},{"location":"Generators/#built-in-arbitraries","title":"Built-in Arbitraries","text":"<p><code>cppproptest</code> provides a set of built-in generators for immediate generation of types that are often used in practice. Built-in generators are in the form of Arbitraries.</p> <p>Here's quick reference for built-in arbitraries</p> Purpose Examples Generator Generate a boolean <code>true</code> or <code>false</code> <code>Arbi&lt;bool&gt;()</code> Generate a character <code>'c'</code> or <code>'%'</code> <code>Arbi&lt;char&gt;()</code> Generate an integer <code>12</code> or <code>-1133</code> <code>Arbi&lt;int&gt;()</code>, <code>Arbi&lt;uint64_t&gt;()</code>, ... Generate a floating point number <code>3.4</code> or <code>-1.4e3</code> <code>Arbi&lt;float&gt;()</code>, <code>Arbi&lt;double&gt;()</code> Generate a string <code>\"world\"</code> or <code>\"\u3042\u53f6\u8449\ub9d0\"</code> <code>Arbi&lt;std::string&gt;()</code>, <code>Arbi&lt;UTF8String&gt;()</code> Generate a pair <code>{1, \"xv\"}</code> or <code>{true, 3.4}</code> <code>Arbi&lt;std::pair&lt;T1,T2&gt;&gt;()</code> Generate a tuple <code>{1, \"xv\", true}</code> or <code>{true, 3.4}</code> <code>Arbi&lt;std::tuple&lt;Ts...&gt;&gt;()</code> Generate a list <code>{10, -4, 0}</code> or <code>{\"k\", \"&amp;\"}</code> <code>Arbi&lt;std::list&lt;T&gt;&gt;()</code> Generate a vector <code>{10, -4, 0}</code> or <code>{\"k\", \"&amp;\"}</code> <code>Arbi&lt;std::vector&lt;T&gt;&gt;()</code> Generate a set set <code>{1, 3, 4}</code> but not <code>{1, 1, 3}</code> <code>Arbi&lt;std::set&lt;T&gt;&gt;()</code> Generate a map map of <code>\"Bob\" -&gt; 25, \"Alice\" -&gt; 30</code> <code>Arbi&lt;std::map&lt;K,V&gt;&gt;()</code> <ul> <li>Boolean type:<code>bool</code></li> <li>Character type: <code>char</code></li> <li>Integral types: <code>int8_t</code>, <code>uint8_t</code>, <code>int16_t</code>, <code>uint16_t</code>, <code>int32_t</code>, <code>uint32_t</code>, <code>int64_t</code>, <code>uint64_t</code></li> <li>Floating point types: <code>float</code>, <code>double</code></li> <li>String types:<ul> <li><code>std::string</code> (defaults to generate ASCII character strings in [0x01, 0x7F] range)</li> <li><code>UTF8String</code> (a class which extends <code>std::string</code> and can be used to generate valid UTF-8 strings by using <code>Arbi&lt;UTF8String&gt;</code>)</li> <li><code>CESU8String</code> (similar to UTF-8, but can be used to generate valid CESU-8 strings)</li> <li><code>UTF16BEString</code> and <code>UTF16LEString</code> for UTF-16 big and little endian strings. CESU-8 and Unicode types produce full unicode code point range of [0x1, 0x10FFFF], excluding forbidden surrogate code points ([0xD800, 0xDFFF])</li> </ul> </li> <li>Shared pointers: <code>std::shared_ptr&lt;T&gt;</code> where an <code>Arbi&lt;T&gt;</code> or a custom generator for <code>T</code> is available. It's also useful for generating polymorphic types.     <pre><code>struct Action {\nvirtual int get() = 0;\n};\nstruct Insert : Action {\nvirtual void get() { return 1; }\n};\nstruct Delete : Action {\nvirtual void get() { return 2; }\n};\nGenerator&lt;std::shared_ptr&lt;Action&gt;&gt;(...); // can hold both Insert and Delete\n</code></pre></li> <li> <p>Standard containers: <code>std::string</code>, <code>std::vector</code>, <code>std::list</code>, <code>std::set</code>, <code>std::pair</code>, <code>std::tuple</code>, <code>std::map</code></p> <ul> <li> <p>Arbitraries for containers can optionally take a generator for their element types     <pre><code>// You can supply a specific generator for integers\nauto vecInt0to100 = Arbi&lt;std::vector&lt;int&gt;&gt;(interval&lt;int&gt;(0,100));\n// otherwise, Arbi&lt;int&gt; is used\nauto vecInt = Arbi&lt;std::vector&lt;int&gt;&gt;();\n\n// string aarbitraries also take optional element generator\nauto uppercaseGen = Arbi&lt;std::string&gt;(interval('A', 'Z'));\nauto alphabetGen = Arbi&lt;std::string&gt;(unionOf(interval('A', 'Z'), interval('a','z')));\n</code></pre></p> </li> <li> <p><code>Arbi&lt;std::Map&gt;</code> provides setter methods for assigning key and value generators</p> <pre><code>auto mapGen = Arbi&lt;std::map&lt;int,int&gt;&gt;();\nmapGen.setKeyGen(interval&lt;int&gt;(0,100)); // key ranges from 0 to 100\nmapGen.setElemGen(interval&lt;int&gt;(-100, 100)); // value ranges from -100 to 100\n</code></pre> </li> <li> <p>Containers provide methods for configuring desired sizes</p> <ul> <li><code>setMinSize(size)</code>, <code>setMaxSize(size)</code> for restricting to specific range of sizes</li> <li><code>setSize(size)</code> for restricting to specific size</li> </ul> <pre><code>auto vecInt = Arbi&lt;std::vector&lt;int&gt;&gt;();\nvecInt.setSize(10); // 1) generated vector will always have size 10\nvecInt.setMinSize(1); // 2) generated vector will have size &gt;= 1\nvecInt.setMaxSize(10); // generated vector will have size &lt;= 10\nvecInt.setSize(1, 10); // 3) generated vector will have size &gt;= 1 and size &lt;= 10\n</code></pre> </li> </ul> </li> </ul>"},{"location":"Generators/#defining-an-arbitrary","title":"Defining an arbitrary","text":"<p>With template specialization, new <code>Arbi&lt;T&gt;</code> (or its alias <code>Arbitrary&lt;T&gt;</code>) for type <code>T</code> can be defined, if it isn't already defined yet. By defining an Arbitrary, you are effectively adding a default generator for a type.</p> <p>Following shows an example of defining an Arbitrary. Note that it should be defined under <code>proptest</code> namespace in order to be recognized and accessible by the library core.</p> <pre><code>namespace proptest { // you should define your Arbi&lt;T&gt; inside the namespace\n\n// define a template specialization of Arbi for Car type\n// by extending ArbiBase, you are decorating your arbitrary with standard methods (map, flatMap, filter, etc.)\ntemplate &lt;&gt;\nstruct Arbi&lt;Car&gt; : ArbiBase&lt;Car&gt; {\nShrinkable&lt;Car&gt; operator()(Random&amp; rand) {\nbool isAutomatic = rand.getRandomBool();\nreturn make_shrinkable&lt;Car&gt;(isAutomatic); // make_shrinkable creates a Car object by calling Car's constructor with 1 boolean parameter\n}\n};\n\n}\n</code></pre>"},{"location":"Generators/#arbitrary-provides-utility-methods","title":"Arbitrary provides utility methods","text":"<p>As an <code>Arbitrary&lt;T&gt;</code> is also a <code>Generator&lt;T&gt;</code>, an arbitrary provides useful helpers for creating new generators from existing ones. <code>filter</code> is such a helper. It restrictively generates values that satisfy a criteria function. Following shows an even number generator from the integer <code>Arbitrary</code>.</p> <pre><code>// generates any integers\nauto anyIntGen = Arbi&lt;int&gt;();\n// generates even integers\nauto evenGen = anyIntGen.filter([](int&amp; num) {\nreturn num % 2 == 0;\n});\n</code></pre> <p>You can find the full list of such helpers in section Utility methods in standard generators.</p> <p> </p>"},{"location":"Generators/#building-custom-generators-with-generator-combinators","title":"Building Custom Generators with Generator Combinators","text":"<p>While you can build your own generator by manually defining a <code>GenFunction&lt;T&gt;</code> for type <code>T</code>, it's usually not recommended as there is a better option - generator combinators. Generator combinators are toolkit for building new generators based on existing ones. They can be chained to create another generator out of themselves. See Combinators page for the detail.</p> <p> </p>"},{"location":"Generators/#advanced-topics","title":"Advanced Topics","text":""},{"location":"Generators/#genfunctiont-common-representation-for-all-generators-for-type-t","title":"<code>GenFunction&lt;T&gt;</code> - Common representation for all generators for type <code>T</code>","text":"<p>All generators, including the default ones, share the same base function type. A generator can be a callable (function, functor, or lambda) with following common signature:</p> <pre><code>// (Random&amp;) -&gt; Shrinkable&lt;T&gt;\n</code></pre> <p>This can be represented as (or coerced to) a standard function type, <code>std::function&lt;Shrinkable&lt;T&gt;(Random&amp;)&gt;</code>. In <code>cppproptest</code>, this function type is aliased as <code>GenFunction&lt;T&gt;</code>. We will use this term GenFunction throughout this page to refer the generator function type.</p> <pre><code>template &lt;typename T&gt;\nusing GenFunction = std::function&lt;Shrinkable&lt;T&gt;(Random&amp;);\n</code></pre> <p>By the way, you may have noticed a strange template type <code>Shrinkable</code> in this signature. You can refer to <code>Shrinkable</code> for its further detail, but it can be treated as a wrapper for type <code>T</code> for now. So a generator (<code>Generator&lt;T&gt;</code>) basically generates a value of type <code>T</code> from a random number generator of <code>Random</code> type. A generator can be defined as function, functor, or lambda, as following:</p> <pre><code>// lambda style\nauto myIntGen = [](Random&amp; rand) {\nint smallInt = rand.getRandomInt8();\nreturn make_shrinkable&lt;int&gt;(smallInt);\n};\n\n// function style\nShrinkable&lt;int&gt; myIntGen(Random&amp; rand) {\nint smallInt = rand.getRandomInt8();\nreturn make_shrinkable&lt;int&gt;(smallInt);\n}\n\n// functor style\nstruct MyIntGen {\nShrinkable&lt;int&gt; operator()(Random&amp; rand) {\nint smallInt = rand.getRandomInt8();\nreturn make_shrinkable&lt;int&gt;(smallInt);\n}\n};\n</code></pre>"},{"location":"Generators/#generatort-decorator-class-for-supercharging-a-generator","title":"<code>Generator&lt;T&gt;</code> - Decorator class for supercharging a generator","text":"<p>The template class <code>Generator&lt;T&gt;</code> is an abstract functor class that also coerces to <code>GenFunction&lt;T&gt;</code>. A <code>Generator&lt;T&gt;</code> gives access to some useful methods so that you can wrap your callable with this to decorate with those methods. As all accompanied generators and combinators of <code>cppproptest</code> produce decorated <code>Generator&lt;T&gt;</code>s, you can use the utility methods out-of-box.</p> <pre><code>// decorate a GenFunction with Generator&lt;T&gt;\nauto myIntGen = Generator&lt;int&gt;([](Random&amp; rand) {\nint smallInt = rand.getRandomInt8();\nreturn make_shrinkable&lt;int&gt;(smallInt);\n});\n\n// .filter and other utility methods can be used once the generator is decorated with Generator&lt;T&gt;\nauto evenGen = myIntGen.filter([](int&amp; value) {\nreturn value % 2 == 0;\n}); // generates even numbers only\n</code></pre>"},{"location":"GettingStarted/","title":"Getting Started with <code>cppproptest</code>","text":""},{"location":"GettingStarted/#running-your-first-property-based-test","title":"Running your first property-based test","text":"<p><code>cppproptest</code> requires CMake for build tool. You can examine the requirements with:</p> <pre><code># at cppproptest root directory\n$ cmake . -BBUILD\n$ cd BUILD &amp;&amp; make &amp;&amp; ./test_proptest\n</code></pre> <p>You can edit your project's CMakeLists.txt to include the library <code>proptest</code>:</p> <pre><code>ADD_SUBDIRECTORY(&lt;path_to_cppproptest_root&gt;)\n</code></pre> <p>And then add this library to <code>TARGET_LINK_LIBRARIES</code> section.</p> <pre><code>TARGET_LINK_LIBRARIES( ...\n    ...\n    proptest\n    ...\n)\n</code></pre> <p>Here's an example using Googletest:</p> <pre><code>// ...\n#include \"proptest/proptest.hpp\"\n\nusing namespace proptest;\n\nTEST(AudioCodec, EncoderDecoder)\n{\n// ASSERT_FOR_ALL() is shorthand for ASSERT_TRUE(forAll(...))\nASSERT_FOR_ALL([](SoundData soundData) {\nauto encoded = MyAudioCodec::encode(soundData);\nauto decoded = MyAudioCodec::decode(encoded);\nPROP_ASSERT_EQ(decoded, soundData);\n});\n}\n</code></pre>"},{"location":"GettingStarted/#property","title":"<code>Property</code>","text":"<p><code>property</code> defines a property with optional configurations. By calling <code>property</code>, you are creating a <code>Property</code> object. <code>forAll</code> is the shorthand for calling <code>Property</code>'s method <code>forAll</code>. <code>Property::forAll</code> performs property-based test using supplied callable (function, functor, or lambda). While <code>forAll</code> would work most of the time, <code>property</code> is more versatile and configurable.</p> <pre><code>forAll([](int a, int b) -&gt; bool {\nreturn a + b == b + a;\n});\n</code></pre> <p>is equivalent to</p> <pre><code>property([](int a, int b) -&gt; bool {\nreturn a + b == b + a;\n}).forAll();\n</code></pre>"},{"location":"GettingStarted/#defining-a-property","title":"Defining a property","text":"<p>Defining a property requires a callable. For example, a lambda as following is such a callable with an <code>int</code> as parameter:</p> <pre><code>[](int a) -&gt; bool {\nreturn a &gt;= 0;\n}\n</code></pre> <p>Arguments are generated automatically by the framework and the return value of the function indicates success(<code>true</code>) or failure(<code>false</code>) of a property. Asserts can also be used to mark failures. If you prefer not to use boolean return value to indicate success/fail, you can use void return type.</p> <pre><code>[](int a) {\nPROP_ASSERT_GE(a, 0);\n}\n</code></pre> <p>In above case, the function is called with an integer argument randomly generated by the test framework.</p> <p>For a property to be checked, the framework requires generators for parameter types. Either an <code>Arbi&lt;T&gt;</code> (an arbitrary, the default generator for type <code>T</code>) should be defined for a parameter type, or a custom generator should be provided. In above example, a predefined generator <code>Arbi&lt;int&gt;</code> is used to generate an integer argument.</p> <p>You can supply a custom generator as additional argument(s) to <code>property()</code> function, as following.</p> <pre><code>property([](int a, int b) -&gt; bool {\nreturn true;\n}, myIntGenerator);\n</code></pre> <p>Any remaining parameter in the property function with no custom generator supplied will be generated using an arbitrary. In above example, <code>int a</code> is generated using <code>myIntGenerator</code>, while <code>int b</code> will be generated using <code>Arbi&lt;int&gt;</code>. If there is no arbitrary defined for a type and no custom generator is supplied also, a compile error will be emitted.</p> <p>Many primitive types and containers have their default generators <code>Arbi&lt;T&gt;</code> defined by the framework for convenience. You can find more about generators and see the full list of built-in Arbitraries in Generators page.</p>"},{"location":"GettingStarted/#propertyforall-adjusting-generators","title":"<code>Property::forAll</code>: adjusting generators","text":"<p>You can explicitly specify some of the generators for <code>forAll</code>, by passing them as arguments. It's a common way to fix only some of the arguments using <code>just</code> combinator and let the rest of the parameters generated using the generators originally set.</p> <pre><code>// a is fixed to INT_MAX, while b is randomly generated\nprop.forAll(just&lt;int&gt;(INT_MIN));\n\nprop.forAll(inRange&lt;int&gt;(-100, 100));\n</code></pre>"},{"location":"GettingStarted/#using-propertyexample-for-testing-for-specific-example","title":"Using <code>Property::example</code> for testing for specific example","text":"<p>You might want to test for specific combination of arguments for a property defined. This can be accomplished using <code>Property::example(...)</code>. You need to specify all the parameters needed to call the callable:</p> <pre><code>// define a property\nauto prop = property([](int a, int b) -&gt; bool {\nreturn a + b == b + a;\n});\n\n// check specific examples\nprop.example(INT_MIN, INT_MIN);\nprop.example(INT_MIN, INT_MAX);\nprop.example(INT_MAX, INT_MIN);\nprop.example(INT_MAX, INT_MAX);\n\n// perform randomized test runs\nprop.forAll();\n</code></pre>"},{"location":"GettingStarted/#configuring-random-seed-and-number-of-runs","title":"Configuring random seed and number of runs","text":"<p>A property can be configured to have specific random seed. This can be done by calling <code>Property::setSeed(unsigned long seed)</code>.  Also, you can set the number of runs with <code>Property::setNumRuns(int num)</code>. The default number of runs is <code>1000</code>.</p> <pre><code>auto prop = property([](int a, int b) -&gt; bool {\n// ...\n});\nprop.setSeed(savedSeed).setNumRuns(100).forAll();\n</code></pre> <p>You can set default number of runs affected globally by calling the static method <code>PropertyBase::setDefaultNumRuns(int num)</code>.</p> <pre><code>PropertyBase::setDefaultNumRuns(100);\n</code></pre> <p>if no random seed is specified, current timestamp in milliseconds is used. You can override these unspecified random seeds with an environment variable <code>PROPTEST_SEED</code>. This comes handy when you encountered a failure and its random seed value is available:</p> <pre><code># ... failed test with random seed 15665312\n$ PROPTEST_SEED=15665312 ./my_proptest\n</code></pre>"},{"location":"GettingStarted/#assertions-and-expectations","title":"Assertions and expectations","text":"<p>Regarding assertions, <code>cppproptest</code> provides assertion(fatal)/expection(non-fatal) macros similar to the popular Google Test framework.</p> <pre><code>// PROP_EXPECT*: non-fatal, continues upon failure\nPROP_EXPECT(condition);\nPROP_EXPECT_TRUE(condition);\nPROP_EXPECT_FALSE(condition);\nPROP_EXPECT_EQ(A, B);\nPROP_EXPECT_NE(A, B);\nPROP_EXPECT_LT(A, B);\nPROP_EXPECT_GT(A, B);\nPROP_EXPECT_LE(A, B);\nPROP_EXPECT_GE(A, B);\nPROP_EXPECT_STREQ(A, B, N);\n\n// PROP_ASSERT*: fatal, breaks test upon failure\nPROP_ASSERT(condition);\nPROP_ASSERT_TRUE(condition);\nPROP_ASSERT_FALSE(condition);\nPROP_ASSERT_EQ(A, B);\nPROP_ASSERT_NE(A, B);\nPROP_ASSERT_LT(A, B);\nPROP_ASSERT_GT(A, B);\nPROP_ASSERT_LE(A, B);\nPROP_ASSERT_GE(A, B);\nPROP_ASSERT_STREQ(A, B, N);\n</code></pre> <p>Also, there are Google Test compatible macros for <code>forAll</code> that fails the gtest test case or suite upon a property test failure (since with a bare <code>forAll</code>, failures won't behave as gtest failure):</p> <pre><code>EXPECT_FOR_ALL(...); // non-fatal, shorthand for EXPECT_TRUE(proptest::forAll(...));\nASSERT_FOR_ALL(...); // fatal, shorthand for ASSERT_TRUE(proptest::forAll(...));\n</code></pre>"},{"location":"Mocking/","title":"Mocking","text":""},{"location":"Mocking/#generating-mocks","title":"Generating Mocks","text":""},{"location":"Mocking/#todo","title":"TODO","text":""},{"location":"Printing/","title":"Printing Facilities","text":"<p>It's sometimes recommended to have a printer defined for a type. It would ensure values of a type to be correctly printed. <code>cppproptest</code> fully defines printers for built-in types.</p> <pre><code>// a std::tuple&lt;std::tuple&lt;int, std::tuple&lt;int&gt;&gt;&gt; type is printed:\nshrinking found simpler failing arg 0: { { -10, { -1002144 } } }\n</code></pre> <p>For a new type you'd like to use with <code>cppproptest</code>, you can define a printer for that type. As you can see in above example, complex recursive structures such as tuple of tuples can be printed if you have correctly defined it. If there is no printer is defined for a type yet, '???' would be printed instead, as there is no correct way known to <code>cppproptest</code> how to printing that type .</p> <pre><code>// Car type that does not yet have a printing method, so it's printed as '???':\nshrinking found simpler failing arg 0: ???\n</code></pre>"},{"location":"Printing/#defining-a-printer-for-a-type","title":"Defining a printer for a type","text":"<p>Defining a printer for type <code>T</code> can be achieved by defining the struct specialization <code>proptest::util::ShowDefault&lt;T&gt;</code>:</p> <pre><code>namespace proptest {\nnamespace util {\n\n// printer for Car class\ntemplate &lt;&gt;\nstruct ShowDefault&lt;Car&gt;\n{\nstatic std::ostream&amp; show(std::ostream&amp; os, const Car&amp; car)\n{\nos &lt;&lt; \"Car(\" &lt;&lt; car.name &lt;&lt; \", \" &lt;&lt; car.year &lt;&lt; \")\";\nreturn os;\n}\n};\n\n} // namespace util\n} // namespace proptest\n</code></pre> <p>This will be called whenever <code>T</code> is being printed by <code>cppproptest</code>:</p> <pre><code>// Car type now has a printer defined\nshrinking found simpler failing arg 0: Car(Ferari, 2020)\n</code></pre>"},{"location":"Printing/#defining-a-printer-for-a-templated-type","title":"Defining a printer for a templated type","text":"<p>You can also define a printer for a templated type as following:</p> <pre><code>namespace proptest {\nnamespace util {\n\n// printer for CarLike&lt;T&gt;\ntemplate &lt;typename T&gt;\nstruct ShowDefault&lt;CarLike&lt;T&gt;&gt;\n{\nstatic std::ostream&amp; show(std::ostream&amp; os, const CarLike&lt;T&gt;&amp;)\n{\nos &lt;&lt; \"CarLike()\";\nreturn os;\n}\n};\n\n} // namespace util\n} // namespace proptest\n</code></pre> <p>This will print a <code>CarLike</code> as:</p> <pre><code>shrinking found simpler failing arg 0: CarLike()\n</code></pre>"},{"location":"Printing/#utilizing-other-printers","title":"Utilizing other printers","text":"<p>If your printer fneeds to print another type <code>T</code>, you can use an already defined (either built-in or custom one) printer for <code>T</code> by calling <code>proptest::util::Show&lt;T&gt;(T&amp;)</code>, as following:</p> <pre><code>namespace proptest {\nnamespace util {\n\ntemplate &lt;typename T&gt;\nstruct ShowDefault&lt;CarLike&lt;T&gt;&gt;\n{\nstatic std::ostream&amp; show(std::ostream&amp; os, const CarLike&lt;T&gt;&amp; carLike)\n{\n// utilize printer for type T ('CarLike(???)' will be printed if there is no printer defined for T)\nos &lt;&lt; \"CarLike(\" &lt;&lt; Show&lt;T&gt;(carLike.t) &lt;&lt; \")\";\nreturn os;\n}\n};\n\n} // namespace util\n} // namespace proptest\n</code></pre> <p>Now it will correctly prints a <code>CarLike&lt;Car&gt;</code>:</p> <pre><code>shrinking found simpler failing arg 0: CarLike(Car(Ferari, 2020))\n</code></pre>"},{"location":"Shrinking/","title":"Simplifying Failed Inputs","text":"<p>Shrinking is powerful notion widely utilized in most property-based testing libraries. It automates some of typical debugging process and greatly reduces the effort required to analyse a test failure. <code>cppproptest</code> fully supports shrinking for all built-in generators and combinators.</p>"},{"location":"Shrinking/#counterexample-and-shrinking","title":"Counterexample and Shrinking","text":"<p>Compared to generators, shrinking is a relatively optional feature of property-based testing. But it plays very important role in terms of usability and debugging. Here is an example:</p> <pre><code>forAll([](int a, double b, bool c) -&gt; bool {\nPROP_ASSERT(...);\n});\n</code></pre> <p>When a property fails during a property-based test, a counterexample is found.</p> <p>Falsifiable after 12 tests, where a = -13680124, b = 7524.68454e-14, c = true</p> <p>Here, <code>a</code>, <code>b</code>, and <code>c</code>'s tuple <code>(-13680124, 7524.68454e-14, true)</code> is a counterexample that disproves a property. You can reproduce the property failure with this input combination so that you can further reason about its root cause.</p> <p>You would immediately want to know which combination of the arguments <code>a</code>, <code>b</code>, and <code>c</code> is responsible for the failure. In some cases, a boolean flag such as <code>c</code> in this example could have triggered the failure. If <code>c</code> is the only responsible for the failure, we can pull other arguments <code>a</code> and <code>b</code> out of the equation and keep them as simple as possible. Finding such relationship of arguments is what we would typically do to indentify the root cause of the failure.</p> <p>Shrinking exactly automates this process. When a failure is encountered, <code>forAll</code> shrinks the failing input combination. In other words, it tries to find another input combination that still fails the property, but with simpler representation. If an integer is big, it tries with a smaller number. If a boolean is <code>true</code>, then tries with <code>false</code>. If a vector has many elements, it tries with removing some of the elements, and so on. If possible, it will come up with much more meaningful set of arguments that led to the failure. In this specific example, <code>a</code>, <code>b</code>, and <code>c</code> tuple can be shrunk from the complicated <code>(-13680124, 7524.68454e-14, true)</code> to much simpler <code>(0, 0, true)</code>, because <code>a</code> and <code>b</code> has no role in the failure.</p> <p>In short,</p> <p>Shrinking is the process of finding another failing combination of arguments with simpler representation.</p> <p>Although There is no universal definition of simple or simpler, we can agree on some basic ideas:</p> <ul> <li>Booleans: <code>false</code> (turning a flag off) is simpler than <code>true</code> (turning on)</li> <li>Numerics:<ul> <li>remove sign or take a smaller absolute value/exponent (e.g. <code>-34</code> -&gt; <code>34</code>, <code>16384</code> -&gt; <code>1024</code>, <code>12e55</code> -&gt; <code>12e20</code>)</li> <li>round some of the digits (e.g. <code>-29.5134</code> -&gt; <code>-29</code>)</li> </ul> </li> <li>Strings: drop some of characters in the back (e.g. <code>\"Hello world!\"</code> -&gt; <code>\"Hello\"</code>)</li> <li>Containers: remove some of the elements (in the back)<ul> <li><code>[0,1,2,3,4,5]</code> -&gt; <code>[0,1,2]</code></li> </ul> </li> </ul> <p>Shrinking also shines during the early stage of writing a test. It can quickly summarize a test failure so that we can easily identify whether it was the component that had a bug or the test itself that was badly designed.</p>"},{"location":"StatefulTesting/","title":"Stateful Testing","text":"<p>While property-based testing suits well with functions and stateless objects, it's also useful in testing for various state changes with ease. Typical properties we can test with stateful tests are as following:</p> <ul> <li>Test for consistency of internal state</li> <li>Test for memory leaks</li> <li>Test for concurrent accesses (see Concurrency Testing for more)</li> </ul> <p>The key idea of stateful testing with <code>cppproptest</code> is to generate state changes.</p> <ol> <li>Define action generators: Define <code>action</code>s that each represents unit of state change - e.g. For a numeric object, calling <code>.multiply(int multiplier)</code> method with a numeric multiplier as an argument, calling <code>.divide(int divisor)</code> method, etc.</li> <li>Build an action list generator: we then need a generator for the <code>action</code> types that can build a list of actions and pass required arguments to the selected actions</li> <li>Run the stateful test</li> </ol> <p>Say, you are to write stateful test for your <code>MyVector</code>, which is a linear container for integers.</p> <pre><code>class MyVector {\nvoid push_back(int val);\nint pop_back();\nint size();\nint&amp; at(int pos);\nvoid clear();\n};\n</code></pre> <p>You first need to define actions for each state change.</p>"},{"location":"StatefulTesting/#using-action-functions","title":"Using Action Functions","text":"<p>An <code>Action</code> or a <code>SimpleAction</code> is formally defined as a functor object of the form:</p> <p><code>Action&lt;ObjectType,ModelType&gt;</code>: <pre><code>(ObjectType&amp;, ModelType&amp;) -&gt; void\n</code></pre></p> <p><code>SimpleAction&lt;ObjectType&gt;</code>: <pre><code>(ObjectType&amp;) -&gt; void\n</code></pre></p> <p><code>ObjectType</code> refers to the type of the stateful object of our concern. <code>ModelType</code> indicates an optional object type with which we'd like to check our stateful object. This additional object is called a model. For example, you can mark number of elements in a model to track the inserted or removed elements in a container object. Or you could closely compare your object with an already validated implementation that works similar to yours.</p>"},{"location":"StatefulTesting/#option-1-simpleaction-working-without-a-model","title":"Option 1: <code>SimpleAction</code> - Working without a model","text":"<pre><code>(ObjectType&amp;) -&gt; void\n</code></pre> <p>You can use <code>SimpleAction</code> and its variant if you do not intend to use a model object. Let's discuss this simper variant first. The function takes an <code>ObjectType</code> reference. You will typically be defining a <code>SimpleAction</code> with a lambda. Our first goal is to create a generator for our action. A generator for an action with no arguments such as <code>pop_back()</code> can be defined as:</p> <pre><code>#include \"statefultest.hpp\"\n\n// ...\n\nauto popBackGen = just(SimpleAction&lt;MyVector&gt;([](MyVector&amp; obj) {\nobj.pop_back();\n}));\n</code></pre> <p>Notice the usage of <code>just</code> generator combinator which will always generate the same action. Compare with following <code>push_back()</code>'s action generator that requires an integer argument:</p> <pre><code>auto pushBackGen = Arbi&lt;int&gt;().map&lt;SimpleAction&lt;MyVector&gt;&gt;([](int value) {\nreturn SimpleAction&lt;MyVector&gt;([value](MyVector&amp; obj) {\nobj.push_back(value);\n});\n});\n</code></pre> <p>Here you can see an integer generator is transformed as an action generator. The outer lambda returns an action that calls <code>push_back()</code> with the integer argument <code>value</code>.</p> <p>You can add various assertions in the action. Any failed assertion will be reported and analyzed, as in ordinary property tests.</p> <p>With each action generator defined, we would typically combine these generators as one, using <code>oneOf</code> combinator:</p> <pre><code>auto actionGen = oneOf&lt;SimpleAction&lt;MyAction&gt;&gt;(pushBackGen, popBackGen, clearGen);\n</code></pre> <p>This will generate either of 3 actions, with evenly distributed probability (1/3).</p> <p>Finally, we can define a stateful property by calling <code>statefulProperty&lt;ObjectType&gt;()</code>. This method requires an initial state generator, and the <code>actionGen</code> we've just obtained. Calling <code>statefulProperty::go()</code> will execute the stateful property test.</p> <pre><code>// we can generate initial object from an arbitrary, assuming we have an Arbi&lt;MyVector&gt; defined\nauto prop = statefulProperty&lt;T&gt;(\n/* initial state generator */ Arbi&lt;MyVector&gt;(),\n/* action generator */ actionGen);\nprop.go();\n\n// ...\n\n// or, we can just initialize the object to an empty object\nauto prop = statefulProperty&lt;T&gt;(\n/* initial state generator */ just&lt;MyVector&gt;([]() { return MyVector(); }),\n/* action generator */ actionGen);\nprop.go();\n</code></pre>"},{"location":"StatefulTesting/#putting-it-together","title":"Putting it together:","text":"<pre><code>class MyVector {\nvoid push_back(int val) { ... }\nint pop_back() { ... }\nint size() { ... }\nint&amp; at(int pos) { ... }\nvoid clear() { ... }\n};\n\nTEST(MyVectorTest, Stateful)\n{\nauto popBackGen = just(SimpleAction&lt;MyVector&gt;([](MyVector&amp; obj) {\nif(obj.size() == 0)\nreturn;\nint size = obj.size();\nobj.pop_back();\nPROP_ASSERT(obj.size() == size - 1);\n}));\n\nauto pushBackGen = Arbi&lt;int&gt;().map&lt;SimpleAction&lt;MyVector&gt;&gt;([](int value) {\nreturn [value](MyVector&amp; obj) {\nint size = obj.size();\nobj.push_back(value);\nPROP_ASSERT(obj.size() == size + 1);\n};\n});\n\nauto clearGen = just(SimpleAction&lt;MyVector&gt;([](MyVector&amp; obj) {\nobj.clear();\nPROP_ASSERT(obj.size() == 0);\n}));\n\nauto actionGen = oneOf&lt;SimpleAction&lt;MyVector&gt;&gt;(pushBackGen, popBackGen, weightedGen&lt;SimpleAction&lt;MyVector&gt;&gt;(clearGen, 0.1));\n// `oneOf` can take weights, so you can adjust rate of generation of an action\n//    auto actionGen = oneOf&lt;SimpleAction&lt;MyVector&gt;&gt;(pushBackGen, popBackGen, weightedGen&lt;SimpleAction&lt;MyVector&gt;&gt;(clearGen, 0.1));\nauto prop = statefulProperty&lt;MyVector&gt;(\n/* initial state generator */ just&lt;MyVector&gt;([]() { return MyVector(); }),\n/* action generator */ actionGen);\n// Tests massive cases with randomly generated action sequences\nprop.go();\n}\n</code></pre>"},{"location":"StatefulTesting/#option-2-action-working-with-a-model","title":"Option 2: <code>Action</code> - Working with a model","text":"<p>If you need a model for advanced tracking of state changes, use <code>Action</code> instead of <code>SimpleAction</code>. <code>Action</code> takes additional parameter indicating the model type. Let's define our model for tracking number of elements for <code>MyVector</code></p> <pre><code>// our simple model that tracks number of elements\nstruct Counter {\nCounter(int n) : num(n) {}\nint num;\n};\n</code></pre> <p>With this defined, we can continue defining our actions.</p> <pre><code>auto popBackGen = just(Action&lt;MyVector, Counter&gt;([](MyVector&amp; obj, Counter&amp; counter) {\nif(obj.size() == 0)\nreturn;\nobj.pop_back();\ncounter.num--;\n}));\n</code></pre> <p>You can use <code>oneOf&lt;Action&lt;ObjectType, ModelType&gt;&gt;</code> to get the combined action generator:</p> <pre><code>auto actionGen = oneOf&lt;Action&lt;MyVector, Counter&gt;&gt;(pushBackGen, popBackGen, clearGen);\n</code></pre> <p>Finally, we can define a stateful property by calling <code>statefulProperty&lt;ObjectType,ModelType&gt;()</code>. This method requires an initial state generator, and the <code>actionGen</code> we've just obtained. Compared to <code>SimpleAction</code> case, it additionally requires a model factory in the form of <code>ObjectType&amp; -&gt; ModelType</code>. This factory is to induce initial model from initial object. Calling <code>statefulProperty::go()</code> will execute the stateful property test.</p> <pre><code>auto prop = statefulProperty&lt;T&gt;(\n/* initial state generator */ Arbi&lt;MyVector&gt;(),\n/* model factory */ [](MyVector&amp; vec) { return Counter(vec.size()); },\n/* action generator */ actionGen);\nprop.go();\n</code></pre> <p>While the model in this example is simple, you may choose to use more complex ones. It's often a clever idea to use an existing, well validated implementation as model. For example, we could use <code>std::vector&lt;int&gt;</code> as model and perform the actions on both <code>MyVector</code> and <code>std::vector</code>. We assure <code>MyVector</code> works correctly by comparing element-wise with the <code>std::vector</code> model object that has undergone the same state changes.</p>"},{"location":"StatefulTesting/#putting-it-together_1","title":"Putting it together:","text":"<pre><code>class MyVector {\nvoid push_back(int val) { ... }\nint pop_back() { ... }\nint size() { ... }\nint&amp; at(int pos) { ... }\nvoid clear() { ... }\n};\n\n// our simple model that tracks number of elements\nstruct Counter {\nCounter(int n) : num(n) {}\nint num;\n};\n\nTEST(MyVectorTest, Stateful)\n{\nauto popBackGen = just(Action&lt;MyVector, Counter&gt;([](MyVector&amp; obj, Counter&amp; cnt) {\nif(obj.size() == 0)\nreturn;\nobj.pop_back();\ncnt.num--;\nPROP_ASSERT(cnt.num == obj.size());\n}));\n\nauto pushBackGen = Arbi&lt;int&gt;().map&lt;Action&lt;MyVector, Counter&gt;&gt;([](int value) {\nreturn [value](MyVector&amp; obj) {\nobj.push_back(value);\ncnt.num++;\nPROP_ASSERT(cnt.num == obj.size());\n};\n});\n\nauto clearGen = just(Action&lt;MyVector, Counter&gt;([](MyVector&amp; obj) {\nobj.clear();\ncnt.num = 0;\nPROP_ASSERT(cnt.num == obj.size());\n}));\n\n// combine action generators\nauto actionGen = oneOf&lt;Action&lt;MyVector, Counter&gt;&gt;(pushBackGen, popBackGen, clearGen);\n// oneOf() can take weights, so you can adjust rate of generation of an action\n//    auto actionGen = oneOf&lt;Action&lt;MyVector, Counter&gt;&gt;(pushBackGen, popBackGen, weightedGen&lt;Action&lt;MyVector, Counter&gt;&gt;(clearGen, 0.1));\nauto prop = statefulProperty&lt;MyVector, Counter&gt;(\n/* initial state generator */ Arbi&lt;MyVector&gt;(),\n/* initial model factory */ [](MyVector&amp; vec) { return Counter(vec.size()); },\n/* action generator */ actionGen);\n// Tests massive cases with randomly generated action sequences\nprop.go();\n}\n</code></pre>"},{"location":"StatefulTesting/#debugging-stateful-test-failures","title":"Debugging stateful test failures","text":"<p>A stateful test is succesful if all tried combinations were complete without issues. On the other hand, a failed assertion or an unexpected exception would end up with a stateful test failure. The framework will print the failed condition and tried input combinations so that you can debug the failure. Among the <code>args</code>, the first arg is the initial state, and the second one is the action list:</p> <pre><code>Falsifiable, after 12 tests: vec.size() == count (test/test_state_func.cpp:111)\nwith args: { [ 1882384569, -1157159508, ..., 128, 32768, 840506558 ], [ Action&lt;?&gt;, Action&lt;?&gt;, Action&lt;?&gt;, ..., Action&lt;?&gt; ] }\n</code></pre> <p>Note that, by default, an <code>Action</code> or a <code>SimpleAction</code> has no distinctive description. This is why there are indistinguishable <code>Action&lt;?&gt;</code>s printed in the action list. This can be avoided by prepending a description to each action constructor:</p> <pre><code>// action with no argument\nauto clearGen = just(SimpleAction&lt;MyVector&gt;&gt;(\"Clear\", [](MyVector&amp; obj) {\n// ...\n}));\n\n// action with arguments can be printed nicely with a stringstream\nauto pushBackGen = Arbi&lt;int&gt;().map&lt;SimpleAction&lt;MyVector&gt;&gt;([](int value) {\nstd::stringstream str;\nstr &lt;&lt; \"PushBack(\" &lt;&lt; value &lt;&lt; \")\";\nreturn SimpleAction(str.str(), [value](MyVector&amp; obj) {\n// ...\n});\n});\n</code></pre> <p>Now you can see the actions are correctly printed:</p> <pre><code>Falsifiable, after 1 tests: vec.size() &lt; 5 (test/test_state_func.cpp:111)\nwith args: { [ 1882384569, -1157159508, ..., 128, 32768, 840506558 ], [ PushBack(1894834799), PopBack, Clear, ..., PushBack(814265512) ] }\n</code></pre>"},{"location":"StatefulTesting/#configuring-stateful-test-runs","title":"Configuring stateful test runs","text":"<p>You can alter some of test characteristics of stateful test runs. * Random seed * Number of runs</p> <pre><code>auto prop = statefulProperty(...);\n// set random seed\nprop.setSeed(5464561L);\n// number of sequences to be tested\nprop.setNumRuns(10000);\nprop.go();\n// or you can simply chain the property:\nprop.setSeed(0).setNumRuns(1000).go();\n</code></pre>"},{"location":"StatefulTesting/#alternative-style-using-action-classes","title":"Alternative Style: Using Action Classes","text":"<p>There are actually two styles of stateful testing - one with action functions(lambda) and one with action classes. While the first style using functions are easier to use and understand, the second style is more formal and traditional way of doing stateful testing. You may choose to use either style. Both have similar process of defining and running stateful tests. See the separate page for detail. This style is more traditional way of defining actions. Both styles are similar in terms of expressive power.</p>"},{"location":"StatefulTesting/#further-topics","title":"Further topics","text":"<ul> <li>See Concurrency Testing for testing for concurrent changes of a stateful object.</li> </ul>"},{"location":"StatefulTestingStyle2/","title":"Stateful Testing","text":""},{"location":"StatefulTestingStyle2/#style-2-using-action-classes","title":"Style 2: Using Action Classes","text":""},{"location":"StatefulTestingStyle2/#understanding-action","title":"Understanding <code>Action</code>","text":"<p>In the second style, you will define actions by defining an <code>Action</code> or a <code>SimpleAction</code> abstract class with following signatures:</p> <pre><code>template &lt;typename ObjectType, typename ModelType&gt;\nstruct Action\n{\nvirtual bool precondition(const ObjectType&amp;, const ModelType&amp;) { ... }\n\nvirtual bool run(ObjectType&amp;, ModelType&amp;) { ... }\n};\n\ntemplate &lt;typename ObjectType&gt;\nstruct SimpleAction\n{\nvirtual bool precondition(const ObjectType&amp;) { ... }\n\nvirtual bool run(ObjectType&amp;) { ... }\n};\n</code></pre> <p><code>ObjectType</code> is the target stateful object type. In this case, <code>MyVector</code> is the <code>ObjectType</code> type. <code>ModelType</code> is optional structure to hold useful data for validation of the <code>ObjectType</code> based on some model, throughout the test sequence.</p> <p>You would prefer to use <code>SimpleAction</code> if you don't need a model structure, and <code>Action</code> if you need one.</p> <ul> <li><code>precondition</code> is called to check if an action in the sequence is applicable to current state. If it's not the action is skipped.<ul> <li>Overriding <code>precondition</code> is optional and returns <code>true</code> by default</li> </ul> </li> <li><code>run</code> is called to actually apply the state change and perform validations against your model after the state change</li> </ul> <pre><code>template &lt;typename ObjectType, typename ModelType&gt;\nstruct Action\n{\nvirtual bool precondition(const ObjectType&amp; system, const ModelType&amp;) { ... }\n\nvirtual bool run(ObjectType&amp; system, ModelType&amp;) { ... }\n};\n</code></pre>"},{"location":"StatefulTestingStyle2/#defining-actions","title":"Defining Actions","text":"<p>For the listed methods that might change the state of a <code>MyVector</code>, we would write <code>Action</code>s for each.</p> <pre><code>void push_back(int val);\nint pop_back();\nint&amp; at(int pos);\nvoid clear();\n</code></pre> <pre><code>struct PushBack : public SimpleAction&lt;MyVector&gt; {\nint val;\n\nPushBack(int val) : val(val) {\n}\n\nbool run(MyVector&amp; vector) {\nvector.push_back(val);\n}\n};\n\nstruct PopBack : public SimpleAction&lt;MyVector&gt; {\nbool precondition(MyVector&amp; vector) {\nreturn vector.size() &gt; 0;\n}\n\nbool run(MyVector&amp; vector) {\nvector.pop_back(val);\n}\n};\n\nstruct SetAt : public SimpleAction&lt;MyVector&gt; {\nint pos;\nint val;\n\nSetAt(int pos, int val) : pos(pos), val(val) {\n}\n\nbool precondition(MyVector&amp; vector) {\nreturn pos &lt; vector.size();\n}\n\nbool run(MyVector&amp; vector) {\nvector.at(pos) = val;\n}\n};\n\nstruct Clear : public SimpleAction&lt;MyVector&gt; {\nbool run(MyVector&amp; vector) {\nvector.clear(val);\n}\n};\n</code></pre>"},{"location":"StatefulTestingStyle2/#generating-action-sequence","title":"Generating <code>Action</code> sequence","text":"<p>With our <code>Action</code>s properly defined, we can generate a sequence of <code>Action</code>s. <code>actionClasses</code> function is a useful shorthand for <code>oneOf</code> generator combinator that is specialized for generating <code>Action</code> Sequences.</p> <pre><code>        auto actionListGen = actionListGenOf&lt;SimpleAction&lt;MyVector&gt;&gt;(\n// int -&gt; PushBack(int)\ntransform&lt;int, std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;(\nArbi&lt;int&gt;(), [](const int&amp; value) { return std::make_shared&lt;PushBack&gt;(value); }),\n\n// Popback()\njust&lt;std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;([]() { return std::make_shared&lt;PopBack&gt;(); }),\n\n// (int, int) -&gt; SetAt(int, int)\ntransform&lt;int, std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;(\nArbi&lt;std::pair&lt;int,int&gt;&gt;(), [](const std:;pair&lt;int,int&gt;&amp; posAndVal) { return std::make_shared&lt;SetAt&gt;(posAndVal.first, posAndVal.second); }),\n\n// Clear()\njust&lt;std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;([]() { return std::make_shared&lt;Clear&gt;(); })\n);\n</code></pre> <p>This defines a generator for action sequences that randomly chooses <code>push_back</code>, <code>pop_back</code>, <code>at</code>, and <code>clear</code> methods for <code>MyVector</code> with arguments.</p>"},{"location":"StatefulTestingStyle2/#running-stateful-tests","title":"Running stateful tests","text":"<p>Finally, we will call <code>statefulProperty::forAll</code> to perform generation of action sequences and run the tests. You should supply generator for initial state of <code>MyVector</code> to start with.</p> <pre><code>auto prop = statefulProperty&lt;SimpleAction&lt;MyVector&gt;&gt;(Arbi&lt;MyVector&gt;(), actionListGen)\nprop.forAll();\n</code></pre>"},{"location":"WhyPropertyBasedTesting/","title":"Why Property-based testing?","text":""},{"location":"WhyPropertyBasedTesting/#generalization-and-abstraction","title":"Generalization and abstraction","text":"<p>Property-based testing, or PBT in short, lets you write a test using abstract idea, instead of some dummy examples or contrived scenarios that are easy to break over time and hard to interpret. You can write tests using specification or requirements - which are essentially expressed as combination of input domain and expected behavior (=properties) of tested component.</p>"},{"location":"WhyPropertyBasedTesting/#clear-separation-of-variants-and-invariants","title":"Clear separation of variants and invariants","text":"<p>Describing a test using input domain and expected behavior means that we have clear cut between variants and invariants. We often mix variants and invariants in our tests in typical example-based tests. This is one of the reasons why those tests become hard to maintain and difficult to read over time. In property-based tests, however, we clearly separate invariants as properties and variants as input domain. Thus tests become more readable and gets easier to maintain, as they carry test writers' intention better.</p>"},{"location":"WhyPropertyBasedTesting/#convenience-and-versatility","title":"Convenience and versatility","text":"<p>Property-based testing often provides with the convenient out-of-box generators (sometimes called strategies) and combinators (that lets you make new generators out of existing ones), and lets you to effortlessly define the input domain for your tests. You can specify your input domains using various notions - range, constraint, union, transformation, composition, and dependency, just to name a few.</p>"},{"location":"WhyPropertyBasedTesting/#reusability-and-scalability","title":"Reusability and Scalability","text":"<p>As it defines input domain with generators and combinators, Property-based testing lets you define and reuse existing input domain and properties to build new input domain and properties with ease. These new ones then can be reused as building blocks for next tests and so on. Reusable nature of property-based testing lets you write tests with scale. Complex combinations of components can be readily tested if simpler pieces are already available by tests written previously.</p> <p> </p>"},{"location":"WhyPropertyBasedTesting2/","title":"WhyPropertyBasedTesting2","text":""},{"location":"WhyPropertyBasedTesting2/#an-attempt-to-approximate-software-quality","title":"An attempt to approximate software quality","text":"<p>Property-based testing, or sometimes refered to as specification-based testing, tries to verify software's integrity by validating the requirements of a software component, where the requirements are often written as properties(or specifications). They are validated using massive input combinations.</p> <pre><code>    // encode &amp; decode are inverse functions\nASSERT(decode(encode(text)) == text);\n</code></pre> <p>Many property-based testing implementations derive their ideas from QuickCheck, which was originally written in Haskell. Quickcheck's basic idea is to quickly prove a theorem, as the name suggests. But how can anything possibly be proved about software? A software piece is often too complex to reason about in definitive way. If we randomly choose 100 input combinations to test your component and confirm that it satisfies the required properties with every 100 of the combinations, you may argue that it's still not proving anything. But how about if we increase the number of combinations to 1,000, or 10,000?</p> <p>Certainly there still remains some possibility that one of the untested input combinations might fail the properties. But we can say this as an approximation - an approximation of software integrity or quality. As the number of evidences grows, more accurate the approximation it becomes. It's often very effective to approximate an answer when it cannot be easily obtained. It's sometimes the only feasible way.</p> <p>Property-based testing can do exactly that. You define a property (or 'specification') of a software component should satisfy, then you can let the test library prove or disprove that requirement automatically by feeding in random (but valid) input combinations.</p> <p>In fact, often the underlying issues of a component are easily detected than you can imagine. Some properties may hold true with a few combinations, but such luck usually cannot last for long. The issues reveal themselves eventually.</p> <p>In property-based testing, software requirements can be validated in automated fashion as in static code analyses, but by actually running the code as in dynamic code analyses. By actually running the code, we can check for many software requirements and issues that are usually not feasible to find with static code analyses.</p> <p> </p>"},{"location":"WhyPropertyBasedTesting2/#why-property-based-testing-for-c","title":"Why property-based testing for C++?","text":"<p>Property-based tesing relies on massive input combinations to be attempted to achieve high confidence. For example, if you have a function with 10 boolean flags to be thoroughly tested in runtime, you need to test it with <code>2</code><code>10</code> <code>= 1024</code> combinations. This kind of complexity has been often considered as unmanageable and something that should be avoided. However, as most C++ unit components (as single unit or multiple components combined) tend to execute blazingly fast on modern machines, running them 1000 times is usually not an issue. Unless it's involving external devices like secondary disk or network communication, running a typical C++ component 1000 times would normally end up finishing under a second barrier. This is why C++ and property-based testing is a fine pair.</p> <p>I feel many of the existing property-based testing implementation in C++ are either outdated or too daunting to learn due to their complexity. <code>cppproptest</code> focuses on lowering the learning curve while maintaining feature-completeness.</p>"}]}