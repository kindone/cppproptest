{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"cppproptest","text":"<p><code>cppproptest</code> is a property-based testing library for C++. It focuses on usability with features included:</p> <ul> <li>Out-of-box generators for primitives and standard containers</li> <li>Set of powerful generator combinators for creating new generators from existing generators</li> <li>Shrinking capability for quickly finding root cause of a failure and automated debugging support</li> <li>Stateful testing support for testing state changes</li> <li>Concurrency testing support for testing concurrent state changes</li> </ul> <p>You can get started with <code>cppproptest</code> on this page.</p> <p> </p>"},{"location":"#why-property-based-testing","title":"Why Property-based Testing?","text":""},{"location":"#generalization-and-abstraction","title":"Generalization and Abstraction","text":"<p>Property-based testing lets you write tests using abstract ideas, instead of introducing some dummy examples or overly contrived scenarios. You can write tests focusing on specification or requirements of the tested components.</p>"},{"location":"#clear-separation-of-variants-and-invariants","title":"Clear Separation of Variants and Invariants","text":"<p>In reality, we often mix variants and invariants in our tests under typical example-based tests. This is one of the reasons why those tests become hard to maintain and difficult to read over time. Let's see following example-based test for an encoder and a decoder:</p> <pre><code>// a text encoded and then decoded must be identical to original\nMyEncoder encoder;\nMyDecoder decoder;\nauto encodedMsg = encoder.encode(\"Some dummy content that hopefully prove or disprove this works\");\nauto decodedMsg = decoder.decode(encodedMsg);\nASSERT_EQ(\"Some dummy content that hopefully prove or disprove this works\", decodedMsg);\n</code></pre> <p>Even a simple test like this is confusing, as some dummy string value seems like as if it's playing a significant role in the test but in fact it isn't. Turning this dummy value to a free variable would lead to greater generalization of the test:</p> <pre><code>[](std::string originalMsg) {\n// a text encoded and then decoded must be identical to originalMsg\nMyEncoder encoder;\nMyDecoder decoder;\nauto encodedMsg = encoder.encode(originalMsg);\nauto decodedMsg = decoder.decode(encodedMsg);\nPROP_ASSERT_EQ(originalMsg, decodedMsg);\n};\n</code></pre> <p>The new free variable <code>originalMsg</code> becomes the variant part (input domain) of the test while the rest becomes the invariant part.</p> <p>In order to turn this into a concrete test run, we can feed in some random values for the free variable <code>originalMsg</code>. This can be achieved by enclosing this function with <code>forAll()</code> function, which calls the given test function many times with some randomly generated values for the free variable <code>originalMsg</code>:</p> <pre><code>forAll([](std::string originalMsg) {\n// a text encoded and then decoded must be identical to original\nMyEncoder encoder;\nMyDecoder decoder;\nauto encodedMsg = encoder.encode(originalMsg);\nauto decodedMsg = decoder.decode(encodedMsg);\nPROP_ASSERT_EQ(originalMsg, decodedMsg);\n});\n</code></pre> <p>As a result, <code>forAll()</code> will test the encoder and decoder against arbitrary input strings, by calling the property function hundreds of times (200 is the default number of runs) with some random strings, instead of relying on a dummy value. This let's you validate the property with various forms of <code>originalMsg</code>.</p> <p>With this approach, our test becomes more readable, gets easier to maintain, and carries test writer's intention better.</p>"},{"location":"#convenience-and-versatility","title":"Convenience and Versatility","text":"<p>Property-based testing often provides with the convenient out-of-box generators and generator combinators (that can make new generators out of existing ones), and lets you to effortlessly define an input domain tailored for your test. You can specify your input domain using various notions - range, constraint, union, transformation, composition, and dependency, just to name a few.</p> <p>Following example shows how certain input domain of string type can be specified using a built-in generator and generator combinators:</p> <p></p> <pre><code>// a tailored string generator\nauto stringGen = Arbitrary&lt;int&gt;()\n.filter([] (int&amp; num) { return num % 2 == 0; }) // even numbers only\n.map([] (int&amp; num) {\nreturn \"&lt;\" + std::to_string(numStr) + \"&gt;\"; // string like \"&lt;0&gt;\", ..., \"&lt;n&gt;\"\n});\n\n// property\nforAll([](std::string original) {\n// ... //\n}, stringGen);\n</code></pre> <p>The <code>forAll</code> function automatically identifies parameter types of the given property function. This automation allows any number of parameters of simple or complex types to be used to define a property-based test:</p> <p></p> <p>It then automatically feeds in the randomly generated values of those types to call the given function multiple times. With this powerful generation engine, we can fully parameterize and randomize our tests with high flexibility but with much less effort.</p> <p>You don't need to care too much about how to test your requirements. Most of it is automatically done for you by the framework, letting you to focus on what to test.</p> <p> </p>"},{"location":"#further-topics-and-details","title":"Further Topics and Details:","text":"<ul> <li>Getting Started with cppproptest</li> <li>Introduction to generators<ul> <li>Arbitraries</li> <li>Built-in generators</li> </ul> </li> <li>Generator combinators for creating generators from existing ones</li> <li>Counterexamples and notion of shrinking for automated debugging</li> <li>Printing facilities</li> <li>Stateful testing with <code>cppproptest</code></li> <li>Concurrency testing with <code>cppproptest</code></li> <li>Advanced mocking with <code>cppproptest</code> (work in progress)</li> </ul>"},{"location":"Combinators/","title":"Generator Combinators","text":"<p>Generator combinators are provided for building a new generator based on existing ones. Many of them come from ideas and best practices of functional programming. They can be chained as they receive existing generator(s) as argument and returns new generator.</p> <p>While you can go through this document from top to the bottom, you might be want to find a suitable combinator for your use case using this table:</p> Purpose Related Generator/Combinator Examples Generate just a constant <code>just&lt;T&gt;</code> <code>0</code> or <code>\"1337\"</code> Generate a value within constants <code>elementOf&lt;T&gt;</code> a prime number under 100 Generate a list of unique values <code>Arbi&lt;set&lt;T&gt;&gt;</code> <code>{3,5,1}</code> but not <code>{3,5,5}</code> Generate a value within numeric range of values <code>interval&lt;T&gt;</code>, <code>integers&lt;T&gt;</code> a number within <code>1</code>~<code>9999</code> Generate a pair or a tuple of different types <code>pairOf&lt;T1,T2&gt;</code>, <code>tupleOf&lt;Ts...&gt;</code> a <code>pair&lt;int, string&gt;</code> Union multiple generators <code>unionOf&lt;T&gt;</code> (<code>oneOf&lt;T&gt;</code>) <code>20~39</code> or <code>60~79</code> combined Transform into another type or a value <code>transform&lt;T,U&gt;</code> <code>\"0\"</code> or <code>\"1.4\"</code> (a number as string). Generate a struct or a class object <code>construct&lt;T,ARGS...&gt;</code> a <code>Rectangle</code> object with width and height Apply constraints in generated values <code>filter</code> (<code>suchThat</code>) an even natural number (<code>n % 2 == 0</code>) Generate values with dependencies or relationships <code>dependency</code>, <code>chain</code>, <code>pairWith</code>, <code>tupleWith</code> a rectangle where <code>width == height * 2</code> <p> </p>"},{"location":"Combinators/#basic-generator-combinators","title":"Basic Generator Combinators","text":""},{"location":"Combinators/#constants","title":"Constants","text":"<ul> <li><code>just&lt;T&gt;(T*)</code>, <code>just&lt;T&gt;(T)</code>, <code>just&lt;T&gt;(shared_ptr&lt;T&gt;)</code>: always generates a specific value. A shared pointer can be used for non-copyable types.</li> <li><code>lazy&lt;T&gt;(std::function&lt;T()&gt;)</code>: generates a value by calling a function     <pre><code>auto zeroGen = just(0); // template argument is optional if type is deducible\nauto oneGen = lazy&lt;int&gt;([]() { return 1; });\n</code></pre></li> </ul>"},{"location":"Combinators/#selecting-from-constants","title":"Selecting from constants","text":"<p>You may want to random choose from specific list of values.</p> <ul> <li> <p><code>elementOf&lt;T&gt;(val1, ..., valN)</code>: generates a type <code>T</code> from multiple values for type <code>T</code>, by choosing one of the values randomly     <pre><code>// generates a prime number under 50\nauto primeGen = elementOf&lt;int&gt;(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47);\n</code></pre></p> <ul> <li><code>elementOf</code> can receive optional probabilitistic weights (<code>0 &lt; weight &lt; 1</code>, sum of weights must not exceed 1.0) for generators. If weight is unspecified for a generator, it is calculated automatically so that remaining probability among unspecified generators is evenly distributed. <code>weightedVal(&lt;value&gt;, &lt;weight&gt;)</code> is used to annotate the desired weight.</li> </ul> <pre><code>// generates a numeric within ranges [0,10], [100, 1000], [10000, 100000]\n//   weight for 10 automatically becomes 1.0 - 0.8 - 0.15 == 0.05\nelementOf&lt;int&gt;(weightedVal(2, 0.8), weightedVal(5, 0.15), 10);\n</code></pre> </li> </ul>"},{"location":"Combinators/#integers-and-intervals","title":"Integers and intervals","text":"<p>Some utility generators for integers are provided</p> <ul> <li><code>interval&lt;INT_TYPE&gt;(min, max)</code>: generates an integer type(e.g. <code>uint16_t</code>) in the closed interval <code>[min, max]</code>.</li> <li><code>integers&lt;INT_TYPE(from, count)</code>: generates an integer type starting from <code>from</code> <pre><code>interval&lt;int64_t&gt;(1, 28);\ninterval(1, 48); // template type argument can be ommitted if the input type(`int`) is the same as the output type.\ninterval(1L, 48L); // template type argument can be ommitted if the input type(`int`) is the same as the output type.\ninterval(0, 10); // generates an integer in {0, ..., 10}\ninterval('A', 'Z'); // generates a char of uppercase alphabet\nintegers(0, 10); // generates an integer in {0, ..., 9}\nintegers(1, 10); // generates an integer in {1, ..., 10}\n</code></pre></li> <li><code>natural&lt;INT_TYPE&gt;(max)</code>: generates a positive integer up to <code>max</code>(inclusive)</li> <li><code>nonNegative&lt;INT_TYPE&gt;(max)</code>: : generates zero or a positive integer up to <code>max</code>(inclusive)</li> </ul>"},{"location":"Combinators/#pair-and-tuples","title":"Pair and Tuples","text":"<p>Generators for different types can be bound to a pair or a tuple.</p> <ul> <li> <p><code>pairOf&lt;T1, T2&gt;(gen1, gen2)</code> : generates a <code>std::pair&lt;T1,T2&gt;</code> based on result of generators <code>gen1</code> and <code>gen2</code></p> <pre><code>auto pairGen = pairOf(Arbi&lt;int&gt;(), Arbi&lt;std::string&gt;());\n</code></pre> </li> <li> <p><code>tupleOf&lt;T1, ..., TN&gt;(gen1, ..., genN)</code>: generates a <code>std::tuple&lt;T1,...,TN&gt;</code> based on result of generators <code>gen1</code> through <code>genN</code></p> <pre><code>auto tupleGen = tupleOf(Arbi&lt;int&gt;(), Arbi&lt;std::string&gt;(), Arbi&lt;double&gt;());\n</code></pre> </li> </ul> <p> </p>"},{"location":"Combinators/#advanced-generator-combinators","title":"Advanced Generator Combinators","text":""},{"location":"Combinators/#selecting-from-generators","title":"Selecting from generators","text":"<p>You can combine generators to a single generator that can generate each of them with some probability. This can be considered as taking a union of generators.</p> <ul> <li> <p><code>oneOf&lt;T&gt;(gen1, ..., genN)</code>: generates a type <code>T</code> from multiple generators for type <code>T</code>, by choosing one of the generators randomly</p> <pre><code>// generates a numeric within ranges [0,10], [100, 1000], [10000, 100000]\nauto evenGen = oneOf&lt;int&gt;(interval(0, 10), interval(100, 1000), interval(10000, 100000));\n</code></pre> <ul> <li><code>oneOf</code> can receive optional probabilistic weights (<code>0 &lt; weight &lt; 1</code>, sum of weights must not exceed 1.0) for generators. If weight is unspecified for a generator, it is calculated automatically so that remaining probability among unspecified generators is evenly distributed. <code>weightedGen(&lt;generator&gt;, &lt;weight&gt;)</code> is used to annotate the desired weight.</li> </ul> <p><pre><code>// generates a numeric within ranges [0,10], [100, 1000], [10000, 100000]\nauto evenGen = oneOf&lt;int&gt;(weightedGen(interval(0, 10), 0.8), weightedGen(interval(100, 1000), 0.15), interval(10000, 100000)/* weight automatically becomes 1.0 - (0.8 + 0.15) == 0.05 */);\n</code></pre> * <code>unionOf&lt;T&gt;</code> is an alias of <code>oneOf&lt;T&gt;</code></p> </li> </ul>"},{"location":"Combinators/#constructing-an-object","title":"Constructing an object","text":"<p>You can generate an object of a class or a struct type <code>T</code>, by calling a matching constructor of <code>T</code>.</p> <ul> <li> <p><code>construct&lt;T, ARG1, ..., ARGN&gt;([gen1, ..., genM])</code>: generates an object of type <code>T</code> by calling its constructor that matches the signature <code>(ARG1, ..., ARGN)</code>. Custom generators <code>gen1</code>,..., <code>genM</code> can be supplied for generating arguments. If <code>M &lt; N</code>, then rest of the arguments are generated with <code>Arbi</code>s.</p> <pre><code>struct Coordinate {\nCoordinate(int x, int y) {\n// ...\n}\n};\n// ...\nauto coordinateGen1 = construct&lt;Coordinate, int, int&gt;(interval(-10, 10), interval(-20, 20));\nauto coordinateGen2 = construct&lt;Coordinate, int, int&gt;(interval(-10, 10)); // y is generated with Arbi&lt;int&gt;\n</code></pre> </li> </ul>"},{"location":"Combinators/#applying-constraints","title":"Applying constraints","text":"<p>You can add a filtering condition to a generator to restrict the generated values to have certain constraint.</p> <ul> <li> <p><code>filter&lt;T&gt;(gen, condition_predicate)</code>:  generates a type <code>T</code> that satisfies condition predicate (<code>condition_predicate</code> returns <code>true</code>)</p> <p><pre><code>// generates even numbers\nauto evenGen = filter&lt;int&gt;(Arbi&lt;int&gt;(),[](int&amp; num) {\nreturn num % 2 == 0;\n});\n</code></pre> * <code>suchThat&lt;T&gt;</code>: an alias of <code>filter</code></p> </li> </ul>"},{"location":"Combinators/#transforming-or-mapping","title":"Transforming or mapping","text":"<p>You can transform an existing generator to create new generator by providing a transformer function. This is equivalent to mapping in functional programming context.</p> <ul> <li> <p><code>transform&lt;T,U&gt;(gen, transformer)</code>: generates type <code>U</code> based on generator for type <code>T</code>, using <code>transformer</code> that transforms a value of type <code>T</code> to type <code>U</code></p> <pre><code>// generates string from integers (e.g. \"0\", \"1\", ... , \"-16384\")\nauto numStringGen = transform&lt;int, std::string&gt;(Arbi&lt;int&gt;(),[](int&amp; num) {\nreturn std::string(num);\n});\n</code></pre> </li> </ul>"},{"location":"Combinators/#deriving-or-flat-mapping","title":"Deriving or flat-mapping","text":"<p>Another combinator that resembles <code>transform</code> is <code>derive</code>. This is equivalent to flat-mapping or binding in functional programming. Difference to <code>transform&lt;T,U&gt;</code> is that you can have greater control on the resultant generator.</p> <ul> <li> <p><code>derive&lt;T, U&gt;(genT, genUGen)</code>: derives a new generator for type <code>U</code>, based on result of <code>genT</code>, which is a generator for type <code>T</code>.</p> <pre><code>// generates a string something like \"KOPZZFASF\", \"ghnpqpojv\", or \"49681002378\", ... that consists of only uppercase/lowercase alphabets/numeric characters.\nauto stringGen = derive&lt;int, std::string&gt;(integers(0, 2), [](int&amp; num) {\nif(num == 0)\nreturn Arbi&lt;std::string&gt;(interval('A', 'Z'));\nelse if(num == 1)\nreturn Arbi&lt;std::string&gt;(interval('a', 'z'));\nelse // num == 2\nreturn Arbi&lt;std::string&gt;(interval('0', '9'));\n});\n</code></pre> </li> </ul> <p>Following table compares <code>transform</code> and <code>derive</code>:</p> Combinator transformer signature Result type <code>transform&lt;T,U&gt;</code> <code>function&lt;U(T)&gt;</code> <code>Generator&lt;U&gt;</code> <code>derive&lt;T,U&gt;</code> <code>function&lt;Generator&lt;U&gt;(T)&gt;</code> <code>Generator&lt;U&gt;</code>"},{"location":"Combinators/#values-with-dependencies","title":"Values with dependencies","text":"<p>You may want to include dependency in the generated values. There are two variants that do this. One generates a pair and the other one generates a tuple.</p> <ul> <li> <p><code>dependency&lt;T,U&gt;(genT, genUgen)</code>: generates a <code>std::pair&lt;T,U&gt;</code> with a generator <code>genT</code> for type <code>T</code> and <code>genUgen</code>. <code>genUgen</code> receives a type <code>T</code> and returns a generator for type <code>U</code>. This can effectively create a generator for a pair where second item depends on the first one.</p> <pre><code>auto sizeAndVectorGen = dependency&lt;int, std::vector&lt;bool&gt;&gt;(Arbi&lt;bool&gt;(), [](int&amp; num) {\nauto vectorGen = Arbi&lt;std::vector&lt;int&gt;&gt;();\nvectorGen.maxLen = num;\n// generates a vector with maximum size of num\nreturn vectorGen;\n});\n\nauto nullableIntegers = dependency&lt;bool, int&gt;(Arbi&lt;bool&gt;(), [](bool&amp; isNull) {\nif(isNull)\nreturn just&lt;int&gt;(0);\nelse\nreturn fromTo&lt;int&gt;(10, 20);\n});\n</code></pre> </li> <li> <p><code>chain&lt;Ts..., U&gt;(genT, genUgen)</code>: similar to <code>dependency</code>, but takes a tuple generator for <code>std::tuple&lt;Ts...&gt;</code> and generates a <code>std::tuple&lt;Ts..., U&gt;</code> instead of a <code>std::pair</code>. <code>chain</code> can be repeatedly applied to itself, and results in a tuple one element larger than the previous one. You can chain multiple dependencies with this form.</p> <pre><code>auto yearMonthGen = tupleOf(fromTo(0, 9999), fromTo(1,12));\n// number of days of month depends on month (28~31 days) and year (whether it's a leap year)\nauto yearMonthDayGen = chain&lt;std::tuple&lt;int, int&gt;, int&gt;(yearMonthGen, [](std::tuple&lt;int,int&gt;&amp; yearMonth) {\nint year = std::get&lt;0&gt;(yearMonth);\nint month = std::get&lt;1&gt;(yearMonth);\nif(monthHas31Days(month)) {\nreturn fromTo(1, 31);\n}\nelse if(monthHas30Days(month)) {\nreturn fromTo(1, 30);\n}\nelse { // february has 28 or 29 days\nif(isLeapYear(year))\nreturn fromTo(1, 29);\nelse\nreturn fromTo(1, 28);\n}\n}); // yearMonthDayGen generates std::tuple&lt;int, int, int&gt; of (year, month, day)\n</code></pre> </li> </ul> <p>Actually you can achieve the similar goal using <code>filter</code> combinator:</p> <pre><code>    // generate any year,month,day combination\nauto yearMonthDayGen = tupleOf(fromTo(0, 9999), fromTo(1,12), fromTo(1,31));\n// apply filter\nauto validYearMonthDayGen = yearMonthDayGen.filter([](std::tuple&lt;int,int,int&gt;&amp; ymd) {\nint year = std::get&lt;0&gt;(ymd);\nint month = std::get&lt;1&gt;(ymd);\nint day = std::get&lt;2&gt;(ymd);\nif(monthHas31Days(month) &amp;&amp; day &lt;= 31)\nreturn true;\nelse if(monthHas30Days(month) &amp;&amp; day &lt;= 30)\nreturn true;\nelse { // february has 28 or 29 days\nif(isLeapYear(year) &amp;&amp; day &lt;= 29)\nreturn true;\nelse\nreturn day &lt;= 28;\n}\n});\n</code></pre> <p>However, using <code>filter</code> for generating values with complex dependency may result in many generated values that do not meet the constraint to be discarded and retried. Therefore it's usually not recommended for that purpose if the ratio of discarded values is high.</p>"},{"location":"Combinators/#utility-methods-in-standard-generators","title":"Utility Methods in Standard Generators","text":"<p>Standard generators and combinators (including <code>Arbi&lt;T&gt;</code> and <code>Construct&lt;...&gt;</code>) returns a <code>Generator&lt;T&gt;</code>, which is of the form <code>(Random&amp;) -&gt; Shrinkable&lt;T&gt;</code> (aliased as <code>GenFunction&lt;T&gt;</code>), but has additional combinator methods decorated for ease of use. They in fact have equivalent standalone counterparts. Following table shows this relationship:</p> Decorated method Result type Equivalent Standalone combinator <code>Generator&lt;T&gt;::filter</code> <code>Generator&lt;T&gt;</code> <code>filter&lt;T&gt;</code> <code>Generator&lt;T&gt;::map&lt;U&gt;</code> <code>Generator&lt;U&gt;</code> <code>transform&lt;T,U&gt;</code> <code>Generator&lt;T&gt;::flatMap&lt;U&gt;</code> <code>Generator&lt;U&gt;</code> <code>derive&lt;T,U&gt;</code> <code>Generator&lt;T&gt;::pairWith&lt;U&gt;</code> <code>Generator&lt;std::pair&lt;T,U&gt;&gt;</code> <code>dependency&lt;T,U&gt;</code> <code>Generator&lt;T&gt;::tupleWith&lt;U&gt;</code> <code>Generator&lt;std::tuple&lt;T,U&gt;&gt;</code> <code>chain&lt;T,U&gt;</code> <code>Generator&lt;std::tuple&lt;Ts...&gt;&gt;::tupleWith&lt;U&gt;</code> <code>Generator&lt;std::tuple&lt;Ts...,U&gt;&gt;</code> <code>chain&lt;std::tuple&lt;Ts...&gt;,U&gt;</code> <p>These functions and methods can be continuously chained.</p> <ul> <li> <p><code>.map&lt;U&gt;(mapper)</code>: effectively calls <code>transform&lt;T,U&gt;(gen, transformer)</code> combinator on itself with type <code>T</code> and generator <code>gen</code>.</p> <pre><code>// generator for strings of arbitrary number\nArbi&lt;int&gt;().map&lt;std::string&gt;([](int &amp;num) {\nreturn std::to_string(num);\n});\n// this is equivalent to:\ntransform&lt;int, std::string&gt;(Arbi&lt;int&gt;(), [](int &amp;num) {\nreturn std::to_string(num);\n});\n</code></pre> </li> <li> <p><code>.filter(filterer)</code>: apply <code>filter</code> combinator on itself.</p> <pre><code>// two equivalent ways to generate random even numbers\nauto evenGen = Arbi&lt;int&gt;().filter([](int&amp; num) {\nreturn num % 2 == 0;\n});\n\nauto evenGen = filter&lt;int&gt;(Arbi&lt;int&gt;(),[](int&amp; num) {\nreturn num % 2 == 0;\n});\n</code></pre> </li> <li> <p><code>.flatMap&lt;U&gt;(genUGen)</code>: based on generated result of the generator object itself, induces a new generator for type <code>U</code>. It's equivalent combinator is <code>derive&lt;T,U&gt;</code>. Difference to <code>.map&lt;U&gt;</code> (or <code>transform&lt;T,U&gt;</code>) is that you can have greater control on the resultant generator.</p> <pre><code>auto stringGen = Arbi&lt;int&gt;().flatMap&lt;std::string&gt;([](int&amp; num) {\nauto genString = Arbi&lt;std::string&gt;();\ngenString.setMaxSize(num);\nreturn genString;\n});\n</code></pre> </li> <li> <p><code>.pairWith&lt;U&gt;(genUGen)</code> or <code>tupleWith&lt;U&gt;(genUGen)</code>: chains itself to create a generator of pair or tuple. Equivalent to <code>dependency</code> or <code>chain</code>, respectively.     <pre><code>Arbi&lt;bool&gt;().tupleWith&lt;int&gt;([](bool&amp; isEven) {\nif(isEven)\nreturn Arbi&lt;int&gt;().filter([](int&amp; value) {\nreturn value % 2 == 0;\n});\nelse\nreturn Arbi&lt;int&gt;().filter([](int&amp; value) {\nreturn value % 2 == 1;\n});\n}).tupleWith&lt;std::string&gt;([](std::tuple&lt;bool, int&gt;&amp; tuple) {\nint size = std::get&lt;1&gt;(tuple);\nauto stringGen = Arbi&lt;std::string&gt;();\nstringGen.setSize(size);\nreturn stringGen;\n});\n</code></pre></p> <p>Notice <code>tupleWith</code> can automatically chain a tuple generator of <code>n</code> parameters into a tuple generator of <code>n+1</code> parameters (<code>bool</code> generator -&gt; <code>tuple&lt;bool, int&gt;</code> generator -&gt; <code>tuple&lt;bool, int, string&gt;</code> generator in above example)</p> </li> </ul>"},{"location":"ConcurrencyTesting/","title":"Concurrency Testing","text":"<p>Once you're familiar with stateful testing, you can get acquainted with concurrent stateful testing easily. Concurrency testing performs interleaved state transitions using multiple threads in parallel. It allows us to see if any anomaly or breaking of requirement can be found in the tested component with concurrent accesses.</p> <p>Actually, a concurrency test is almost immediately achievable when you have prepared a stateful test for an object type. Following depicts a concurrent test for <code>std::vector&lt;int&gt;</code> with <code>push_back(int)</code>, <code>pop_back()</code>, and <code>clear()</code> actions included.</p> <pre><code>using namespace proptest;\nusing namespace proptest::concurrent;\n\n// ...\n\nauto pushBackGen = Arbi&lt;int&gt;().map&lt;SimpleAction&lt;std::vector&lt;int&gt;&gt;&gt;([](int&amp; value) {\nreturn [value](std::vector&lt;int&gt;&amp; obj) {\nobj.push_back(value);\nreturn true;\n};\n});\n\nauto popBackGen = just&lt;SimpleAction&lt;std::vector&lt;int&gt;&gt;&gt;([](std::vector&lt;int&gt;&amp; obj) {\nif (obj.empty())\nreturn true;\nobj.pop_back();\nreturn true;\n});\n\nauto clearGen = just&lt;SimpleAction&lt;std::vector&lt;int&gt;&gt;&gt;([](std::vector&lt;int&gt;&amp; obj) {\nobj.clear();\nreturn true;\n});\n\nauto actionListGen = actionListGenOf&lt;std::vector&lt;int&gt;&gt;(pushBackGen, popBackGen, clearGen);\nauto concurrentProp = concurrency&lt;std::vector&lt;int&gt;&gt;(Arbi&lt;std::vector&lt;int&gt;&gt;(), actionListGen);\nconcurrentProp.go();\n</code></pre> <p>You may have noticed that, above test would lead to exceptions or crashes, as <code>std::vector</code> is not made for concurrent writes, unless some synchronization mechanism is present.</p> <p>You can also add a post-check to be performed after each concurrent test run, by setting a post-check function to concurrent property with <code>setPostCheck()</code> method:</p> <pre><code>concurrentProp.setPostCheck([](std::vector&lt;int&gt;&amp; obj) {\n// ... post-check. perform some consistency check for obj\n}).go();\n\n// variant with a model\nconcurrentProp.setPostCheck([](std::vector&lt;int&gt;&amp; obj, VectorModel&amp; model) {\n// ... post-check. perform some consistency check for obj against model\n}).go();\n</code></pre> <p>While you can perform checks in some of the actions, it's sometimes better to have a post-check instead. In concurrent tests, your model as well as the stateful object can be concurrently accessed. Adding synchronization primitives for model object can cause unintended serialization to occur on the stateful object, too. This is why a post-check comes handy, as you don't need to care about synchronization since it's performed after all actions are finished and threads are joined.</p> <pre><code>\n</code></pre>"},{"location":"CustomGenerator/","title":"Building Custom Generator from Scratch","text":""},{"location":"CustomGenerator/#genfunctiont-common-representation-for-all-generators-for-type-t","title":"<code>GenFunction&lt;T&gt;</code> - Common representation for all generators for type <code>T</code>","text":"<p>All generators, including the default ones, share the same base function type. A generator can be a callable (function, functor, or lambda) with following common signature:</p> <pre><code>// (Random&amp;) -&gt; Shrinkable&lt;T&gt;\n</code></pre> <p>This can be represented as (or coerced to) a standard function type, <code>std::function&lt;Shrinkable&lt;T&gt;(Random&amp;)&gt;</code>. In <code>cppproptest</code>, this function type is aliased as <code>GenFunction&lt;T&gt;</code>. We will use this term GenFunction throughout this page to refer the generator function type.</p> <pre><code>template &lt;typename T&gt;\nusing GenFunction = std::function&lt;Shrinkable&lt;T&gt;(Random&amp;);\n</code></pre> <p>By the way, you may have noticed a strange template type <code>Shrinkable</code> in this signature. You can refer to <code>Shrinkable</code> for its further detail, but it can be treated as a wrapper for type <code>T</code> for now. So a generator (<code>Generator&lt;T&gt;</code>) basically generates a value of type <code>T</code> from a random number generator of <code>Random</code> type. A generator can be defined as function, functor, or lambda, as following:</p> <pre><code>// lambda style\nauto myIntGen = [](Random&amp; rand) {\nint smallInt = rand.getRandomInt8();\nreturn make_shrinkable&lt;int&gt;(smallInt);\n};\n\n// function style\nShrinkable&lt;int&gt; myIntGen(Random&amp; rand) {\nint smallInt = rand.getRandomInt8();\nreturn make_shrinkable&lt;int&gt;(smallInt);\n}\n\n// functor style\nstruct MyIntGen {\nShrinkable&lt;int&gt; operator()(Random&amp; rand) {\nint smallInt = rand.getRandomInt8();\nreturn make_shrinkable&lt;int&gt;(smallInt);\n}\n};\n</code></pre>"},{"location":"CustomGenerator/#generatort-decorator-class-for-supercharging-a-generator","title":"<code>Generator&lt;T&gt;</code> - Decorator class for supercharging a generator","text":"<p>The template class <code>Generator&lt;T&gt;</code> is an abstract functor class that also coerces to <code>GenFunction&lt;T&gt;</code>. A <code>Generator&lt;T&gt;</code> gives access to some useful methods so that you can wrap your callable with this to decorate with those methods. As all accompanied generators and combinators of <code>cppproptest</code> produce decorated <code>Generator&lt;T&gt;</code>s, you can use the utility methods out-of-box.</p> <pre><code>// decorate a GenFunction with Generator&lt;T&gt;\nauto myIntGen = Generator&lt;int&gt;([](Random&amp; rand) {\nint smallInt = rand.getRandomInt8();\nreturn make_shrinkable&lt;int&gt;(smallInt);\n});\n\n// .filter and other utility methods can be used once the generator is decorated with Generator&lt;T&gt;\nauto evenGen = myIntGen.filter([](int&amp; value) {\nreturn value % 2 == 0;\n}); // generates even numbers only\n</code></pre>"},{"location":"Generators/","title":"Generating Inputs","text":""},{"location":"Generators/#generators-in-property-based-testing","title":"Generators in Property-Based Testing","text":"<p>Property-based testing promotes the concept of input domain of a property. In property-based testing, generators are the means for representing input domains. A generator is basically a function that generates random values. It defines the constraints of the generated random values in its body. Even a simple <code>forAll()</code> call depends on generators under the hood. Let's see following example:</p> <pre><code>forAll([](int age, std::string name) {\n});\n</code></pre> <p>This <code>forAll()</code> call takes a function with parameters of types <code>int</code> and <code>std::string</code>. This function is the property function. If no additional specification is given on how to generate the values for <code>age</code> and <code>name</code> as in this example, the parameter types are identified to invoke the default generators for those types. In this case, it calls the default generators for <code>int</code> and <code>std::string</code> types. Those default generators are called the arbitraries. You can access the arbitraries of a type <code>T</code> with <code>Arbitrary&lt;T&gt;</code> or <code>Arbi&lt;T&gt;</code>. This code is actually equivalent to:</p> <pre><code>forAll([](int age, std::string name) {\n}, Arbitrary&lt;int&gt;(), Arbitrary&lt;std::string&gt;());\n</code></pre> <p>Notice the extra arguments <code>Arbitrary&lt;int&gt;()</code> and <code>Arbitrary&lt;std::string&gt;()</code> in the <code>forAll()</code> call. As you can see, <code>forAll()</code> actually requires some information on how to generate the values for the parameter types. Some of the often used types have default generators defined in <code>cppproptest</code>.</p> <p> </p>"},{"location":"Generators/#arbitraries-the-default-generators","title":"Arbitraries - The Default Generators","text":""},{"location":"Generators/#what-makes-defaults-so-special","title":"What makes defaults so special","text":"<p>An <code>Arbitrary&lt;T&gt;</code> or its alias <code>Arbi&lt;T&gt;</code> is a generator type (that also coerces to <code>GenFunction&lt;T&gt;</code>). Arbitraries are specially treated in <code>cppproptest</code>. An arbitrary serves as globally defined default generator for the type. If a default generator for a type is available, <code>cppproptest</code> can use the default generator to generate a value of that type, if no generator has been specified.</p> <pre><code>forAll([](T1 t1, T2 t2, ..., TN tn) {\n// property function body\n}, /* custom generators for T1, ..., TN */);\n</code></pre> <p>For each of the parameter types of a property function, <code>forAll()</code> requires either a custom generator is provided as an argument, or a conforming <code>Arbitrary&lt;T&gt;</code> class has been defined in <code>proptest</code> namespace. A custom generator can be supplied in the <code>forAll()</code> function arguments next to the property function, as in the same order of parameters of the property function. If it hasn't been supplied, <code>forAll()</code> looks up the default generator - the arbitrary - and uses it instead. If there were no <code>proptest::Arbitrary&lt;T&gt;</code> defined, the compilation would fail.</p> <pre><code>// if there is no default generator available, you must provide a generator for the type SomeNewType.\nforAll([](SomeNewType x) {\n}, someNewTypeGen);\n\n\n// explicit generators should be supplied in same order as parameter types of property function\nforAll([](SomeNewType x, SomeOtherType y) {\n}, someNewTypeGen, SomeOtherTypeGen);\n\n\n// if there is a default generator (Arbitrary&lt;SomeType&gt;) available, you can use that generator by omitting the argument\nforAll([](SomeType x) {\n});\n\n// Partially specifying generators is also allowed. Other types will be generated with arbitraries\nforAll([](SomeNewType x, SomeOtherType y) {\n}, someNewTypeGen); // y will be generated with Arbitary&lt;SomeOtherType&gt;\n</code></pre>"},{"location":"Generators/#built-in-arbitraries","title":"Built-in Arbitraries","text":"<p><code>cppproptest</code> provides a set of built-in generators for generation of types that are often used in practice. These built-in generators are in the form of Arbitraries. You can access an arbitrary for <code>T</code> with <code>proptest::Arbitrary&lt;T&gt;</code>. Some of them are defined as template classes with type parameters for universality. For example, <code>Arbitrary&lt;vector&lt;T&gt;&gt;</code> defines a generator for a vector of any given type <code>T</code>, assuming you have an arbitrary for <code>T</code> already defined, or you have provided a custom generator for <code>T</code> as an argument for the vector arbitrary's constructor. Arbitraries of Commonly used standard containers are defined with type parameters so that you can generate such containers for the elemental types you desire.</p> <p>Here's quick reference for built-in arbitraries:</p> Purpose Generator Examples Generate a boolean <code>Arbi&lt;bool&gt;()</code> <code>true</code> or <code>false</code> Generate a character <code>Arbi&lt;char&gt;()</code> <code>'c'</code> or <code>'%'</code> Generate an integer <code>Arbi&lt;int&gt;()</code>, <code>Arbi&lt;uint64_t&gt;()</code>, ... <code>12</code> or <code>-1133</code> Generate a floating point number <code>Arbi&lt;float&gt;()</code>, <code>Arbi&lt;double&gt;()</code> <code>3.4</code> or <code>-1.4e3</code> Generate a string <code>Arbi&lt;std::string&gt;()</code>, <code>Arbi&lt;UTF8String&gt;()</code> <code>\"world\"</code> or <code>\"\u3042\u53f6\u8449\ub9d0\"</code> Generate a pair <code>Arbi&lt;std::pair&lt;T1,T2&gt;&gt;()</code> <code>{1, \"xv\"}</code> or <code>{true, 3.4}</code> Generate a tuple <code>Arbi&lt;std::tuple&lt;Ts...&gt;&gt;()</code> <code>{1, \"xv\", true}</code> or <code>{true, 3.4}</code> Generate a list <code>Arbi&lt;std::list&lt;T&gt;&gt;()</code> <code>{10, -4, 0}</code> or <code>{\"k\", \"&amp;\"}</code> Generate a vector <code>Arbi&lt;std::vector&lt;T&gt;&gt;()</code> <code>{10, -4, 0}</code> or <code>{\"k\", \"&amp;\"}</code> Generate a set <code>Arbi&lt;std::set&lt;T&gt;&gt;()</code> set <code>{1, 3, 4}</code> but not <code>{1, 1, 3}</code> Generate a map <code>Arbi&lt;std::map&lt;K,V&gt;&gt;()</code> map of <code>\"Bob\" -&gt; 25, \"Alice\" -&gt; 30</code> <ul> <li>Boolean type:<code>bool</code></li> <li>Character type: <code>char</code></li> <li>Integral types: <code>int8_t</code>, <code>uint8_t</code>, <code>int16_t</code>, <code>uint16_t</code>, <code>int32_t</code>, <code>uint32_t</code>, <code>int64_t</code>, <code>uint64_t</code></li> <li>Floating point types: <code>float</code>, <code>double</code></li> <li>String types:<ul> <li><code>std::string</code> (defaults to generate ASCII character strings in [0x01, 0x7F] range)</li> <li><code>UTF8String</code> (a class which extends <code>std::string</code> and can be used to generate valid UTF-8 strings by using <code>Arbi&lt;UTF8String&gt;</code>)</li> <li><code>CESU8String</code> (similar to UTF-8, but can be used to generate valid CESU-8 strings)</li> <li><code>UTF16BEString</code> and <code>UTF16LEString</code> for UTF-16 big and little endian strings. CESU-8 and Unicode types produce full unicode code point range of [0x1, 0x10FFFF], excluding forbidden surrogate code points ([0xD800, 0xDFFF])</li> </ul> </li> <li>Shared pointers: <code>std::shared_ptr&lt;T&gt;</code> where an <code>Arbi&lt;T&gt;</code> or a custom generator for <code>T</code> is available. It's also useful for generating polymorphic types.     <pre><code>struct Action {\nvirtual int get() = 0;\n};\nstruct Insert : Action {\nvirtual void get() { return 1; }\n};\nstruct Delete : Action {\nvirtual void get() { return 2; }\n};\nGenerator&lt;std::shared_ptr&lt;Action&gt;&gt;(...); // can hold both Insert and Delete\n</code></pre></li> <li> <p>Standard containers: <code>std::string</code>, <code>std::vector</code>, <code>std::list</code>, <code>std::set</code>, <code>std::pair</code>, <code>std::tuple</code>, <code>std::map</code></p> <ul> <li> <p>Arbitraries for containers can optionally take a custom generator for their elemental types. If no custom generator for elemental type <code>T</code> is provided, <code>Arbitrary&lt;T&gt;</code> will be used instead.     <pre><code>// You can supply a specific generator for integers\nauto vecInt0to100 = Arbi&lt;std::vector&lt;int&gt;&gt;(interval&lt;int&gt;(0,100));\n// otherwise, Arbi&lt;int&gt; is used\nauto vecInt = Arbi&lt;std::vector&lt;int&gt;&gt;();\n\n// string aarbitraries also take optional element generator\nauto uppercaseGen = Arbi&lt;std::string&gt;(interval('A', 'Z'));\nauto alphabetGen = Arbi&lt;std::string&gt;(unionOf(interval('A', 'Z'), interval('a','z')));\n</code></pre></p> </li> <li> <p><code>Arbi&lt;std::Map&gt;</code> provides setter methods for assigning a key generator and a value generator.</p> <pre><code>auto mapGen = Arbi&lt;std::map&lt;int,int&gt;&gt;();\nmapGen.setKeyGen(interval&lt;int&gt;(0,100)); // interval: key ranges from 0 to 100\nmapGen.setElemGen(interval&lt;int&gt;(-100, 100)); // interval: value ranges from -100 to 100\n</code></pre> </li> <li> <p>Containers provide methods for configuring the desired sizes</p> <ul> <li><code>setMinSize(size)</code>, <code>setMaxSize(size)</code> for restricting the container to specific range of sizes</li> <li><code>setSize(size)</code> for restricting the container to a specific size</li> </ul> <pre><code>auto vecInt = Arbi&lt;std::vector&lt;int&gt;&gt;();\nvecInt.setSize(10);    // 1) generated vector will always have size 10\nvecInt.setMinSize(1);  // 2) generated vector will have size &gt;= 1\nvecInt.setMaxSize(10); //    generated vector will have size &lt;= 10\nvecInt.setSize(1, 10); // 3) generated vector will have size &gt;= 1 and size &lt;= 10\n</code></pre> </li> </ul> </li> </ul> <p>As long as a generator for type <code>T</code> is available (either by <code>Arbitary&lt;T&gt;</code> defined or a custom generator provided), you can generate a container of that type, however complex the type <code>T</code> is, even including a container type. This means you can readily generate a random <code>vector&lt;vector&lt;int&gt;&gt;</code>, as <code>Arbitrary&lt;vector&lt;T&gt;&gt;</code> and <code>Arbitrary&lt;int&gt;</code> is readily available.</p> <pre><code>    Arbi&lt;std::vector&lt;std::vector&lt;int&gt;&gt;&gt;(); // generates a vector of vector of ints.\nArbi&lt;std::map&lt;std::string, std::vector&lt;std::set&lt;int&gt;&gt;&gt;&gt;();\n</code></pre> <p>This design makes arbitraries of <code>cppproptest</code> composable, meaning that they can be easily reusable as building blocks for a new generator.</p>"},{"location":"Generators/#defining-an-arbitrary","title":"Defining an Arbitrary","text":"<p>With template specialization, new <code>proptest::Arbi&lt;T&gt;</code> (or its alias <code>proptest::Arbitrary&lt;T&gt;</code>) for type <code>T</code> can be defined, if it hasn't been already defined yet. By defining an Arbitrary, you are effectively adding a default generator for a type.</p> <p>Following shows an example of defining an Arbitrary. Note that it should be defined under <code>proptest</code> namespace in order to be recognized and accessible by the library.</p> <pre><code>namespace proptest { // you should define your Arbi&lt;T&gt; inside this namespace\n\n// define a template specialization of Arbi for Car type\n// by extending ArbiBase, you are decorating your arbitrary with standard methods (map, flatMap, filter, etc.)\ntemplate &lt;&gt;\nstruct Arbi&lt;Car&gt; : ArbiBase&lt;Car&gt; {\nShrinkable&lt;Car&gt; operator()(Random&amp; rand) {\nbool isAutomatic = rand.getRandomBool();\nreturn make_shrinkable&lt;Car&gt;(isAutomatic); // make_shrinkable creates a Car object by calling Car's constructor with 1 boolean parameter\n}\n};\n\n}\n</code></pre> <p>Although you can define an arbitrary as shown in this example, it's only required to do so if you desire to have a default generator for the type.</p>"},{"location":"Generators/#utility-methods-of-arbitrary","title":"Utility methods of Arbitrary","text":"<p><code>Arbitrary&lt;T&gt;</code> provides useful helpers for creating new generators from existing ones1. <code>filter</code> is such a helper. It restrictively generates values that satisfy a criteria function. Following shows an even number generator from the integer <code>Arbitrary</code>.</p> <pre><code>// generates any integers\nauto anyIntGen = Arbi&lt;int&gt;();\n// generates even integers\nauto evenGen = anyIntGen.filter([](int&amp; num) {\nreturn num % 2 == 0;\n});\n</code></pre> <p>You can find the full list of such helpers in Utility methods in standard generators.</p> <p> </p>"},{"location":"Generators/#building-custom-generators","title":"Building Custom Generators","text":"<p>You can build your own generator for type <code>T</code> by manually defining the conforming generator type <code>GenFunction&lt;T&gt;</code>. You can refer to Building Custom Generators from Scratch for more information.</p> <p>While you can build a custom generator from scratch, it's usually not recommended as there is a better option - using a generator combinator. Generator combinators are toolkit for building new generators based on existing ones. They can also be chained to create another generator out of themselves. See Combinators page for the detail.</p> <p> </p> <ol> <li> <p>In fact, <code>Arbitrary&lt;T&gt;</code> inherits from <code>Generator&lt;T&gt;</code>, which provides those helpers.\u00a0\u21a9</p> </li> </ol>"},{"location":"GettingStarted/","title":"Getting Started with <code>cppproptest</code>","text":"<p><code>cppproptest</code> can be built and used with CMake. You can examine the requirements with:</p> <pre><code># at cppproptest root directory\n$ cmake . -BBUILD\n$ cd BUILD &amp;&amp; make &amp;&amp; ./test_proptest\n</code></pre> <p>You can edit your project's CMakeLists.txt to include the library <code>proptest</code>:</p> <pre><code>ADD_SUBDIRECTORY(&lt;path_to_cppproptest_root&gt;)\n</code></pre> <p>And then add the shared library <code>proptest</code> to <code>TARGET_LINK_LIBRARIES</code> section.</p> <pre><code>TARGET_LINK_LIBRARIES( ...\n    ...\n    proptest\n    ...\n)\n</code></pre> <p>Here's an example using Googletest:</p> <pre><code>// ...\n#include \"proptest/proptest.hpp\"\n\nusing namespace proptest;\n\nTEST(AudioCodec, EncoderDecoder)\n{\n// ASSERT_FOR_ALL() is shorthand for ASSERT_TRUE(forAll(...))\nASSERT_FOR_ALL([](SoundData soundData) {\nauto encoded = MyAudioCodec::encode(soundData);\nauto decoded = MyAudioCodec::decode(encoded);\nPROP_ASSERT_EQ(decoded, soundData);\n});\n}\n</code></pre> <p>Note that <code>ASSERT_FOR_ALL</code> is a simple macro wrapping an <code>ASSERT_TRUE</code> google test macro around the <code>proptest::forAll</code> function. You can find more information in Using Assertion section.</p> <p>You can continue to Writing Property-based Tests</p>"},{"location":"Mocking/","title":"Mocking","text":""},{"location":"Mocking/#generating-mocks","title":"Generating Mocks","text":""},{"location":"Mocking/#todo","title":"TODO","text":""},{"location":"Printing/","title":"Printing Facilities","text":"<p>It's sometimes recommended to have a printer defined for a type. It would ensure values of a type to be correctly printed. <code>cppproptest</code> fully defines printers for built-in types.</p> <pre><code>// a std::tuple&lt;std::tuple&lt;int, std::tuple&lt;int&gt;&gt;&gt; type is printed:\nshrinking found simpler failing arg 0: { { -10, { -1002144 } } }\n</code></pre> <p>For a new type you'd like to use with <code>cppproptest</code>, you can define a printer for that type. As you can see in above example, complex recursive structures such as tuple of tuples can be printed if you have correctly defined it. If there is no printer is defined for a type yet, '???' would be printed instead, as there is no correct way known to <code>cppproptest</code> how to printing that type .</p> <pre><code>// Car type that does not yet have a printing method, so it's printed as '???':\nshrinking found simpler failing arg 0: ???\n</code></pre>"},{"location":"Printing/#defining-a-printer-for-a-type","title":"Defining a printer for a type","text":"<p>Defining a printer for type <code>T</code> can be achieved by defining the struct specialization <code>proptest::util::ShowDefault&lt;T&gt;</code>:</p> <pre><code>namespace proptest {\nnamespace util {\n\n// printer for Car class\ntemplate &lt;&gt;\nstruct ShowDefault&lt;Car&gt;\n{\nstatic std::ostream&amp; show(std::ostream&amp; os, const Car&amp; car)\n{\nos &lt;&lt; \"Car(\" &lt;&lt; car.name &lt;&lt; \", \" &lt;&lt; car.year &lt;&lt; \")\";\nreturn os;\n}\n};\n\n} // namespace util\n} // namespace proptest\n</code></pre> <p>This will be called whenever <code>T</code> is being printed by <code>cppproptest</code>:</p> <pre><code>// Car type now has a printer defined\nshrinking found simpler failing arg 0: Car(Ferari, 2020)\n</code></pre>"},{"location":"Printing/#defining-a-printer-for-a-templated-type","title":"Defining a printer for a templated type","text":"<p>You can also define a printer for a templated type as following:</p> <pre><code>namespace proptest {\nnamespace util {\n\n// printer for CarLike&lt;T&gt;\ntemplate &lt;typename T&gt;\nstruct ShowDefault&lt;CarLike&lt;T&gt;&gt;\n{\nstatic std::ostream&amp; show(std::ostream&amp; os, const CarLike&lt;T&gt;&amp;)\n{\nos &lt;&lt; \"CarLike()\";\nreturn os;\n}\n};\n\n} // namespace util\n} // namespace proptest\n</code></pre> <p>This will print a <code>CarLike</code> as:</p> <pre><code>shrinking found simpler failing arg 0: CarLike()\n</code></pre>"},{"location":"Printing/#utilizing-other-printers","title":"Utilizing other printers","text":"<p>If your printer fneeds to print another type <code>T</code>, you can use an already defined (either built-in or custom one) printer for <code>T</code> by calling <code>proptest::util::Show&lt;T&gt;(T&amp;)</code>, as following:</p> <pre><code>namespace proptest {\nnamespace util {\n\ntemplate &lt;typename T&gt;\nstruct ShowDefault&lt;CarLike&lt;T&gt;&gt;\n{\nstatic std::ostream&amp; show(std::ostream&amp; os, const CarLike&lt;T&gt;&amp; carLike)\n{\n// utilize printer for type T ('CarLike(???)' will be printed if there is no printer defined for T)\nos &lt;&lt; \"CarLike(\" &lt;&lt; Show&lt;T&gt;(carLike.t) &lt;&lt; \")\";\nreturn os;\n}\n};\n\n} // namespace util\n} // namespace proptest\n</code></pre> <p>Now it will correctly prints a <code>CarLike&lt;Car&gt;</code>:</p> <pre><code>shrinking found simpler failing arg 0: CarLike(Car(Ferari, 2020))\n</code></pre>"},{"location":"Property/","title":"Writing Property-based Tests","text":""},{"location":"Property/#what-you-can-do-with-cppproptest","title":"What you can do with <code>cppproptest</code>","text":"<p>Here's the list of property-based test functions and macros you can use in <code>cppproptest</code>:</p>"},{"location":"Property/#property-function-and-its-test-methods","title":"Property Function and Its Test Methods","text":"<p>You can define a property with a criteria function and certain input domain. You can choose to verify the criteria function with randomly generated inputs (<code>forAll()</code>) or with manually specified ones (<code>example()</code>). You can also exhaustively test all combinations of inputs based on the values you provided (<code>matrix()</code>).</p> Name Description Remark <code>proptest::property()</code> Define a property based on a callable <code>.forAll()</code> Run the property with random inputs <code>.matrix()</code> Run the property with Cartesian product of inputs Input list as <code>initializer_list</code> <code>.example()</code> Run the property with specific inputs"},{"location":"Property/#shorthands-for-property-test-methods","title":"Shorthands for Property Test Methods","text":"<p>You can use convenient shorthands for above methods.</p> Name Description Remark <code>proptest::forAll()</code> Define and run a property immediately Shorthand for <code>proptest::property(callable).forAll()</code> <code>proptest::matrix()</code> Define and run a matrix test immediately Shorthand for <code>proptest::property(callable).matrix()</code>"},{"location":"Property/#google-test-assertion-macros","title":"Google Test Assertion Macros","text":"<p>You can wrap around a property test with Google Tests' macro so that you make Google Test consider the property test failure as a test failure (otherwise, the property test will only print the failure information to standard output and return <code>false</code>.).</p> Name Description Remark <code>EXPECT_FOR_ALL()</code> Run <code>proptest::forAll</code> with <code>EXPECT_TRUE</code> Google Test macro Shorthand for <code>EXPECT_TRUE(proptest::forAll(...))</code> <code>ASSERT_FOR_ALL()</code> Run <code>proptest::forAll</code> with <code>ASSERT_TRUE</code> Google Test macro Shorthand for <code>ASSERT_TRUE(proptest::forAll(...))</code>"},{"location":"Property/#defining-and-running-a-property-test","title":"Defining and running a <code>property</code> test","text":"<p><code>property()</code> defines a property with optional configurations. By calling <code>property()</code>, you are creating a <code>Property</code> object. <code>forAll()</code> is the shorthand for calling <code>Property</code>'s method <code>forAll()</code>. <code>Property::forAll()</code> performs property-based test using supplied callable (function, functor, or lambda). While <code>forAll()</code> would work most of the time, <code>property()</code> in combination with its methods <code>.forAll()</code>, <code>.example()</code>, <code>.matrix()</code> can be more versatile and configurable at times.</p> <pre><code>forAll([](int a, int b) -&gt; bool {\nreturn a + b == b + a;\n});\n</code></pre> <p>is equivalent to:</p> <pre><code>property([](int a, int b) -&gt; bool {\nreturn a + b == b + a;\n}).forAll();\n</code></pre>"},{"location":"Property/#defining-a-property","title":"Defining a Property","text":"<p>Defining a property requires a callable. For example, a lambda as following is such a callable with an <code>int</code> as parameter:</p> <pre><code>[](int a) -&gt; bool {\nreturn a &gt;= 0;\n}\n</code></pre> <p>Arguments are generated automatically by the library and the return value of the function will indicate success(<code>true</code>) or failure(<code>false</code>) of the property. Asserts can also be used to mark successes and failures. If you prefer not to use boolean return value to indicate success/fail, you can use void return type and use assertions instead:</p> <pre><code>[](int a) {\nPROP_ASSERT_GE(a, 0);\n}\n</code></pre>"},{"location":"Property/#generators-and-arbitraries-under-the-hood","title":"Generators and Arbitraries under the hood","text":"<p>In above case, the function is called with an integer argument randomly generated by the test library. The library will repeatedly feed in some random values into the function for given number of runs.</p> <p>Under the hood, the library requires a generator for each of given parameter types. For each parameter, either an <code>Arbi&lt;T&gt;</code> (an arbitrary, the default generator for type <code>T</code>) should be defined ahead, or a custom generator must be provided. In above example, a predefined generator <code>Arbi&lt;int&gt;</code> is used to generate an integer argument.</p> <p>You can provide a custom generator as additional argument(s) to <code>property()</code> function, as following:</p> <pre><code>property([](int a, int b) -&gt; bool {\nreturn true;\n}, myIntGenerator);\n</code></pre> <p>Any remaining parameter in the property function with no custom generator supplied will be generated using an arbitrary. In above example, <code>int a</code> is generated using <code>myIntGenerator</code> as it was supplied in the arguments, while <code>int b</code> will be generated using <code>Arbi&lt;int&gt;</code>, as no custom generator was supplied. If there is no arbitrary defined for a type and no custom generator is supplied either, a compile error will be emitted, as the library cannot test a property without a generator for the input type.</p> <p>Many primitive types and standard containers have their default generators <code>Arbi&lt;T&gt;</code> defined by the library for convenience. You can find more about generators and see the full list of built-in Arbitraries in Generators page.</p>"},{"location":"Property/#testing-a-property","title":"Testing a Property","text":"<p>Once a property has been defined, you can run a simple randomized test based on the defined property with <code>Property::forAll()</code>.</p> <pre><code>auto prop = property([](int a, int b) -&gt; bool {\nreturn true;\n}, myIntGenerator);\n\nprop.forAll();\n</code></pre> <p>It will repeatedly call the lambda with different input combinations of <code>a</code> and <code>b</code> then stops after some designated number of runs or a time duration. If a property fails with an input combination by the lambda returning <code>false</code> or encountering an assertion failure, the test stops there and the library will provide some information on the failed case. If possible the library will simplify the failed case with a process called shrinking. See Shrinking page for more information on this process.</p>"},{"location":"Property/#specifying-generators-with-propertyforall","title":"Specifying generators with <code>Property::forAll()</code>","text":"<p>While you can define a property with or without specifying generators, you can additionally specify or override some of the generators when calling <code>.forAll()</code>, by passing the generators as arguments.</p> <pre><code>// a is fixed to INT_MAX, while b is randomly generated\nprop.forAll(just&lt;int&gt;(INT_MIN));\n\n// specifying generator for both a and b\nprop.forAll(just&lt;int&gt;(INT_MIN), inRange&lt;int&gt;(-100, 100));\n</code></pre> <p>In above example, <code>proptest::just()</code> is a generator combinator that simply keeps generating a single value. <code>proptest::inRange</code> is another example of generator combinator. It generates a numeric value within a given range.</p>"},{"location":"Property/#specifying-example-inputs-with-propertyexample","title":"Specifying example inputs with <code>Property::example()</code>","text":"<p>While having a randomized set of inputs is powerful, you might want to test the property with specific combination of inputs to ensure those combinations are always tested. This can be accomplished using <code>.example(...)</code>. You need to specify all the parameters needed to call the callable:</p> <pre><code>// define a property\nauto prop = property([](int a, int b) -&gt; bool {\nreturn a + b == b + a;\n});\n\n// check specific examples\nprop.example(INT_MIN, INT_MIN);\nprop.example(INT_MIN, INT_MAX);\nprop.example(INT_MAX, INT_MIN);\nprop.example(INT_MAX, INT_MAX);\n</code></pre>"},{"location":"Property/#specifying-full-matrix-of-inputs-with-propertymatrix","title":"Specifying full matrix of inputs with <code>Property::matrix()</code>","text":"<p>While <code>.example()</code> provides a way to test certain examples by specifying each one of them, you might want to go even further to test all combinations of concerned inputs (e.g. all defined enum values) by taking a Cartesian product of the input parameters. In above example,taking <code>{INT_MIN, INT_MAX}</code> for <code>a</code> and another <code>{INT_MIN, INT_MAX}</code> for <code>b</code> and multiply them as if it was a matrix multiplication. This will result in four combinations <code>{(INT_MIN, INT_MIN), (INT_MIN, INT_MAX), (INT_MAX, INT_MIN), (INT_MAX, INT_MAX)}</code>. <code>.matrix()</code> lets you do exactly this kind of combination test:</p> <pre><code>// equivalent to above using four `prop.example()`\nprop.matrix({INT_MIN, INT_MAX}, {INT_MIN, INT_MAX});\n// arbitrary size of the list can be used\nprop.matrix({INT_MIN, 0, INT_MAX}, {INT_MIN, 0, 1, INT_MAX});\n</code></pre>"},{"location":"Property/#configuring-test-runs","title":"Configuring test runs","text":""},{"location":"Property/#setting-number-of-runs","title":"Setting number of runs","text":"<p>You can set the number of runs with <code>Property::setNumRuns(int num)</code>. The default number of runs is <code>1000</code>.</p> <pre><code>auto prop = property([](int a, int b) -&gt; bool {\n// ...\n});\nprop.setNumRuns(100).forAll();\n</code></pre> <p>You can set default number of runs affected globally by calling the static method <code>PropertyBase::setDefaultNumRuns(int num)</code>. Subsequent properties will follow this number of runs unless specified with <code>setNumRuns()</code>.</p> <pre><code>PropertyBase::setDefaultNumRuns(100);\n</code></pre>"},{"location":"Property/#setting-the-random-seed","title":"Setting the random seed","text":"<p>A property can be configured a specific random seed. This can be done by calling <code>Property::setSeed(unsigned long seed)</code>.</p> <pre><code>auto prop = property([](int a, int b) -&gt; bool {\n// ...\n});\nprop.setSeed(savedSeed).forAll();\n</code></pre> <p>If no random seed is specified, current timestamp in milliseconds is used. You can override these unspecified random seeds globally with an environment variable <code>PROPTEST_SEED</code>. This comes in handy when you have encountered a failure and its random seed value is available for reproduction:</p> <pre><code># ... failed test with random seed 15665312\n$ PROPTEST_SEED=15665312 ./my_proptest\n</code></pre>"},{"location":"Property/#setting-maximum-test-duration","title":"Setting maximum test duration","text":"<p>You can set maximum duration for a property test run by calling <code>Property::setMaxDurationMs()</code>. This will limit the time regardless of number of runs. It can be useful if your time resource is limited or if you have some external timeout duration configured.</p> <pre><code>prop.setMaxDurationMs(60000); // will run the test for maximum of 60 seconds, if number of runs does not run out first.\n</code></pre>"},{"location":"Property/#chaining-configurations","title":"Chaining configurations","text":"<p>You can chain the configurations for a property as following, for ease of use:</p> <pre><code>auto prop = property([](int a, int b) -&gt; bool {\n// ...\n});\nprop.setSeed(savedSeed).setNumRuns(1000000).setMaxDurationMs(60000).forAll();\n</code></pre>"},{"location":"Property/#using-assertions","title":"Using Assertions","text":"<p><code>cppproptest</code> provides assertion(fatal)/expectation(non-fatal) macros based on the popular Google Test library.</p> <pre><code>// PROP_EXPECT*: non-fatal, continues upon failure\nPROP_EXPECT(condition);\nPROP_EXPECT_TRUE(condition);\nPROP_EXPECT_FALSE(condition);\nPROP_EXPECT_EQ(A, B);\nPROP_EXPECT_NE(A, B);\nPROP_EXPECT_LT(A, B);\nPROP_EXPECT_GT(A, B);\nPROP_EXPECT_LE(A, B);\nPROP_EXPECT_GE(A, B);\nPROP_EXPECT_STREQ(A, B, N);\n\n// PROP_ASSERT*: fatal, breaks test upon failure\nPROP_ASSERT(condition);\nPROP_ASSERT_TRUE(condition);\nPROP_ASSERT_FALSE(condition);\nPROP_ASSERT_EQ(A, B);\nPROP_ASSERT_NE(A, B);\nPROP_ASSERT_LT(A, B);\nPROP_ASSERT_GT(A, B);\nPROP_ASSERT_LE(A, B);\nPROP_ASSERT_GE(A, B);\nPROP_ASSERT_STREQ(A, B, N);\n</code></pre> <p>Also, there are Google Test compatible macros for <code>forAll</code> that fails the gtest test case or suite upon a property test failure (since with a bare <code>forAll</code>, the failures won't behave as gtest failure):</p> <pre><code>EXPECT_FOR_ALL(...); // non-fatal, shorthand for EXPECT_TRUE(proptest::forAll(...));\nASSERT_FOR_ALL(...); // fatal, shorthand for ASSERT_TRUE(proptest::forAll(...));\n</code></pre>"},{"location":"Shrinking/","title":"Simplifying Failed Inputs","text":"<p>Shrinking is powerful notion widely utilized in most property-based testing libraries. It automates some of typical debugging process and greatly reduces the effort required to analyse a test failure. <code>cppproptest</code> fully supports shrinking for all built-in generators and combinators.</p>"},{"location":"Shrinking/#counterexample-and-shrinking","title":"Counterexample and Shrinking","text":"<p>Compared to generators, shrinking is a relatively optional feature of property-based testing. But it plays very important role in terms of usability and debugging. Here is an example:</p> <pre><code>forAll([](int a, double b, bool c) -&gt; bool {\nPROP_ASSERT(...);\n});\n</code></pre> <p>When a property fails during a property-based test, a counterexample is found.</p> <p>Falsifiable after 12 tests, where a = -13680124, b = 7524.68454e-14, c = true</p> <p>Here, <code>a</code>, <code>b</code>, and <code>c</code>'s tuple <code>(-13680124, 7524.68454e-14, true)</code> is a counterexample that disproves a property. You can reproduce the property failure with this input combination so that you can further reason about its root cause.</p> <p>You would immediately want to know which combination of the arguments <code>a</code>, <code>b</code>, and <code>c</code> is responsible for the failure. In some cases, a boolean flag such as <code>c</code> in this example could have triggered the failure. If <code>c</code> is the only responsible for the failure, we can pull other arguments <code>a</code> and <code>b</code> out of the equation and keep them as simple as possible. Finding such relationship of arguments is what we would typically do to indentify the root cause of the failure.</p> <p>Shrinking exactly automates this process. When a failure is encountered, <code>forAll</code> shrinks the failing input combination. In other words, it tries to find another input combination that still fails the property, but with simpler representation. If an integer is big, it tries with a smaller number. If a boolean is <code>true</code>, then tries with <code>false</code>. If a vector has many elements, it tries with removing some of the elements, and so on. If possible, it will come up with much more meaningful set of arguments that led to the failure. In this specific example, <code>a</code>, <code>b</code>, and <code>c</code> tuple can be shrunk from the complicated <code>(-13680124, 7524.68454e-14, true)</code> to much simpler <code>(0, 0, true)</code>, because <code>a</code> and <code>b</code> has no role in the failure.</p> <p>In short,</p> <p>Shrinking is the process of finding another failing combination of arguments with simpler representation.</p> <p>Although There is no universal definition of simple or simpler, we can agree on some basic ideas:</p> <ul> <li>Booleans: <code>false</code> (turning a flag off) is simpler than <code>true</code> (turning on)</li> <li>Numerics:<ul> <li>remove sign or take a smaller absolute value/exponent (e.g. <code>-34</code> -&gt; <code>34</code>, <code>16384</code> -&gt; <code>1024</code>, <code>12e55</code> -&gt; <code>12e20</code>)</li> <li>round some of the digits (e.g. <code>-29.5134</code> -&gt; <code>-29</code>)</li> </ul> </li> <li>Strings: drop some of characters in the back (e.g. <code>\"Hello world!\"</code> -&gt; <code>\"Hello\"</code>)</li> <li>Containers: remove some of the elements (in the back)<ul> <li><code>[0,1,2,3,4,5]</code> -&gt; <code>[0,1,2]</code></li> </ul> </li> </ul> <p>Shrinking also shines during the early stage of writing a test. It can quickly summarize a test failure so that we can easily identify whether it was the component that had a bug or the test itself that was badly designed.</p>"},{"location":"StatefulTesting/","title":"Stateful Testing","text":"<p>While property-based testing suits well with functions and stateless objects, it's also useful in testing for various state changes with ease. Typical properties we can test with stateful tests are as following:</p> <ul> <li>Test for consistency of internal state</li> <li>Test for memory leaks</li> <li>Test for concurrent accesses (see Concurrency Testing for more)</li> </ul> <p>The key idea of stateful testing with <code>cppproptest</code> is to generate state changes.</p> <ol> <li>Define action generators: Define <code>action</code>s that each represents unit of state change - e.g. For a numeric object, calling <code>.multiply(int multiplier)</code> method with a numeric multiplier as an argument, calling <code>.divide(int divisor)</code> method, etc.</li> <li>Build an action list generator: we then need a generator for the <code>action</code> types that can build a list of actions and pass required arguments to the selected actions</li> <li>Run the stateful test</li> </ol> <p>Say, you are to write stateful test for your <code>MyVector</code>, which is a linear container for integers.</p> <pre><code>class MyVector {\nvoid push_back(int val);\nint pop_back();\nint size();\nint&amp; at(int pos);\nvoid clear();\n};\n</code></pre> <p>You first need to define actions for each state change.</p>"},{"location":"StatefulTesting/#using-action-functions","title":"Using Action Functions","text":"<p>An <code>Action</code> or a <code>SimpleAction</code> is formally defined as a functor object of the form:</p> <p><code>Action&lt;ObjectType,ModelType&gt;</code>: <pre><code>(ObjectType&amp;, ModelType&amp;) -&gt; void\n</code></pre></p> <p><code>SimpleAction&lt;ObjectType&gt;</code>: <pre><code>(ObjectType&amp;) -&gt; void\n</code></pre></p> <p><code>ObjectType</code> refers to the type of the stateful object of our concern. <code>ModelType</code> indicates an optional object type with which we'd like to check our stateful object. This additional object is called a model. For example, you can mark number of elements in a model to track the inserted or removed elements in a container object. Or you could closely compare your object with an already validated implementation that works similar to yours.</p>"},{"location":"StatefulTesting/#option-1-simpleaction-working-without-a-model","title":"Option 1: <code>SimpleAction</code> - Working without a model","text":"<pre><code>(ObjectType&amp;) -&gt; void\n</code></pre> <p>You can use <code>SimpleAction</code> and its variant if you do not intend to use a model object. Let's discuss this simper variant first. The function takes an <code>ObjectType</code> reference. You will typically be defining a <code>SimpleAction</code> with a lambda. Our first goal is to create a generator for our action. A generator for an action with no arguments such as <code>pop_back()</code> can be defined as:</p> <pre><code>#include \"statefultest.hpp\"\n\n// ...\n\nauto popBackGen = just(SimpleAction&lt;MyVector&gt;([](MyVector&amp; obj) {\nobj.pop_back();\n}));\n</code></pre> <p>Notice the usage of <code>just</code> generator combinator which will always generate the same action. Compare with following <code>push_back()</code>'s action generator that requires an integer argument:</p> <pre><code>auto pushBackGen = Arbi&lt;int&gt;().map&lt;SimpleAction&lt;MyVector&gt;&gt;([](int value) {\nreturn SimpleAction&lt;MyVector&gt;([value](MyVector&amp; obj) {\nobj.push_back(value);\n});\n});\n</code></pre> <p>Here you can see an integer generator is transformed as an action generator. The outer lambda returns an action that calls <code>push_back()</code> with the integer argument <code>value</code>.</p> <p>You can add various assertions in the action. Any failed assertion will be reported and analyzed, as in ordinary property tests.</p> <p>With each action generator defined, we would typically combine these generators as one, using <code>oneOf</code> combinator:</p> <pre><code>auto actionGen = oneOf&lt;SimpleAction&lt;MyAction&gt;&gt;(pushBackGen, popBackGen, clearGen);\n</code></pre> <p>This will generate either of 3 actions, with evenly distributed probability (1/3).</p> <p>Finally, we can define a stateful property by calling <code>statefulProperty&lt;ObjectType&gt;()</code>. This method requires an initial state generator, and the <code>actionGen</code> we've just obtained. Calling <code>statefulProperty::go()</code> will execute the stateful property test.</p> <pre><code>// we can generate initial object from an arbitrary, assuming we have an Arbi&lt;MyVector&gt; defined\nauto prop = statefulProperty&lt;T&gt;(\n/* initial state generator */ Arbi&lt;MyVector&gt;(),\n/* action generator */ actionGen);\nprop.go();\n\n// ...\n\n// or, we can just initialize the object to an empty object\nauto prop = statefulProperty&lt;T&gt;(\n/* initial state generator */ just&lt;MyVector&gt;([]() { return MyVector(); }),\n/* action generator */ actionGen);\nprop.go();\n</code></pre>"},{"location":"StatefulTesting/#putting-it-together","title":"Putting it together:","text":"<pre><code>class MyVector {\nvoid push_back(int val) { ... }\nint pop_back() { ... }\nint size() { ... }\nint&amp; at(int pos) { ... }\nvoid clear() { ... }\n};\n\nTEST(MyVectorTest, Stateful)\n{\nauto popBackGen = just(SimpleAction&lt;MyVector&gt;([](MyVector&amp; obj) {\nif(obj.size() == 0)\nreturn;\nint size = obj.size();\nobj.pop_back();\nPROP_ASSERT(obj.size() == size - 1);\n}));\n\nauto pushBackGen = Arbi&lt;int&gt;().map&lt;SimpleAction&lt;MyVector&gt;&gt;([](int value) {\nreturn [value](MyVector&amp; obj) {\nint size = obj.size();\nobj.push_back(value);\nPROP_ASSERT(obj.size() == size + 1);\n};\n});\n\nauto clearGen = just(SimpleAction&lt;MyVector&gt;([](MyVector&amp; obj) {\nobj.clear();\nPROP_ASSERT(obj.size() == 0);\n}));\n\nauto actionGen = oneOf&lt;SimpleAction&lt;MyVector&gt;&gt;(pushBackGen, popBackGen, weightedGen&lt;SimpleAction&lt;MyVector&gt;&gt;(clearGen, 0.1));\n// `oneOf` can take weights, so you can adjust rate of generation of an action\n//    auto actionGen = oneOf&lt;SimpleAction&lt;MyVector&gt;&gt;(pushBackGen, popBackGen, weightedGen&lt;SimpleAction&lt;MyVector&gt;&gt;(clearGen, 0.1));\nauto prop = statefulProperty&lt;MyVector&gt;(\n/* initial state generator */ just&lt;MyVector&gt;([]() { return MyVector(); }),\n/* action generator */ actionGen);\n// Tests massive cases with randomly generated action sequences\nprop.go();\n}\n</code></pre>"},{"location":"StatefulTesting/#option-2-action-working-with-a-model","title":"Option 2: <code>Action</code> - Working with a model","text":"<p>If you need a model for advanced tracking of state changes, use <code>Action</code> instead of <code>SimpleAction</code>. <code>Action</code> takes additional parameter indicating the model type. Let's define our model for tracking number of elements for <code>MyVector</code></p> <pre><code>// our simple model that tracks number of elements\nstruct Counter {\nCounter(int n) : num(n) {}\nint num;\n};\n</code></pre> <p>With this defined, we can continue defining our actions.</p> <pre><code>auto popBackGen = just(Action&lt;MyVector, Counter&gt;([](MyVector&amp; obj, Counter&amp; counter) {\nif(obj.size() == 0)\nreturn;\nobj.pop_back();\ncounter.num--;\n}));\n</code></pre> <p>You can use <code>oneOf&lt;Action&lt;ObjectType, ModelType&gt;&gt;</code> to get the combined action generator:</p> <pre><code>auto actionGen = oneOf&lt;Action&lt;MyVector, Counter&gt;&gt;(pushBackGen, popBackGen, clearGen);\n</code></pre> <p>Finally, we can define a stateful property by calling <code>statefulProperty&lt;ObjectType,ModelType&gt;()</code>. This method requires an initial state generator, and the <code>actionGen</code> we've just obtained. Compared to <code>SimpleAction</code> case, it additionally requires a model factory in the form of <code>ObjectType&amp; -&gt; ModelType</code>. This factory is to induce initial model from initial object. Calling <code>statefulProperty::go()</code> will execute the stateful property test.</p> <pre><code>auto prop = statefulProperty&lt;T&gt;(\n/* initial state generator */ Arbi&lt;MyVector&gt;(),\n/* model factory */ [](MyVector&amp; vec) { return Counter(vec.size()); },\n/* action generator */ actionGen);\nprop.go();\n</code></pre> <p>While the model in this example is simple, you may choose to use more complex ones. It's often a clever idea to use an existing, well validated implementation as model. For example, we could use <code>std::vector&lt;int&gt;</code> as model and perform the actions on both <code>MyVector</code> and <code>std::vector</code>. We assure <code>MyVector</code> works correctly by comparing element-wise with the <code>std::vector</code> model object that has undergone the same state changes.</p>"},{"location":"StatefulTesting/#putting-it-together_1","title":"Putting it together:","text":"<pre><code>class MyVector {\nvoid push_back(int val) { ... }\nint pop_back() { ... }\nint size() { ... }\nint&amp; at(int pos) { ... }\nvoid clear() { ... }\n};\n\n// our simple model that tracks number of elements\nstruct Counter {\nCounter(int n) : num(n) {}\nint num;\n};\n\nTEST(MyVectorTest, Stateful)\n{\nauto popBackGen = just(Action&lt;MyVector, Counter&gt;([](MyVector&amp; obj, Counter&amp; cnt) {\nif(obj.size() == 0)\nreturn;\nobj.pop_back();\ncnt.num--;\nPROP_ASSERT(cnt.num == obj.size());\n}));\n\nauto pushBackGen = Arbi&lt;int&gt;().map&lt;Action&lt;MyVector, Counter&gt;&gt;([](int value) {\nreturn [value](MyVector&amp; obj) {\nobj.push_back(value);\ncnt.num++;\nPROP_ASSERT(cnt.num == obj.size());\n};\n});\n\nauto clearGen = just(Action&lt;MyVector, Counter&gt;([](MyVector&amp; obj) {\nobj.clear();\ncnt.num = 0;\nPROP_ASSERT(cnt.num == obj.size());\n}));\n\n// combine action generators\nauto actionGen = oneOf&lt;Action&lt;MyVector, Counter&gt;&gt;(pushBackGen, popBackGen, clearGen);\n// oneOf() can take weights, so you can adjust rate of generation of an action\n//    auto actionGen = oneOf&lt;Action&lt;MyVector, Counter&gt;&gt;(pushBackGen, popBackGen, weightedGen&lt;Action&lt;MyVector, Counter&gt;&gt;(clearGen, 0.1));\nauto prop = statefulProperty&lt;MyVector, Counter&gt;(\n/* initial state generator */ Arbi&lt;MyVector&gt;(),\n/* initial model factory */ [](MyVector&amp; vec) { return Counter(vec.size()); },\n/* action generator */ actionGen);\n// Tests massive cases with randomly generated action sequences\nprop.go();\n}\n</code></pre>"},{"location":"StatefulTesting/#debugging-stateful-test-failures","title":"Debugging stateful test failures","text":"<p>A stateful test is succesful if all tried combinations were complete without issues. On the other hand, a failed assertion or an unexpected exception would end up with a stateful test failure. The framework will print the failed condition and tried input combinations so that you can debug the failure. Among the <code>args</code>, the first arg is the initial state, and the second one is the action list:</p> <pre><code>Falsifiable, after 12 tests: vec.size() == count (test/test_state_func.cpp:111)\nwith args: { [ 1882384569, -1157159508, ..., 128, 32768, 840506558 ], [ Action&lt;?&gt;, Action&lt;?&gt;, Action&lt;?&gt;, ..., Action&lt;?&gt; ] }\n</code></pre> <p>Note that, by default, an <code>Action</code> or a <code>SimpleAction</code> has no distinctive description. This is why there are indistinguishable <code>Action&lt;?&gt;</code>s printed in the action list. This can be avoided by prepending a description to each action constructor:</p> <pre><code>// action with no argument\nauto clearGen = just(SimpleAction&lt;MyVector&gt;&gt;(\"Clear\", [](MyVector&amp; obj) {\n// ...\n}));\n\n// action with arguments can be printed nicely with a stringstream\nauto pushBackGen = Arbi&lt;int&gt;().map&lt;SimpleAction&lt;MyVector&gt;&gt;([](int value) {\nstd::stringstream str;\nstr &lt;&lt; \"PushBack(\" &lt;&lt; value &lt;&lt; \")\";\nreturn SimpleAction(str.str(), [value](MyVector&amp; obj) {\n// ...\n});\n});\n</code></pre> <p>Now you can see the actions are correctly printed:</p> <pre><code>Falsifiable, after 1 tests: vec.size() &lt; 5 (test/test_state_func.cpp:111)\nwith args: { [ 1882384569, -1157159508, ..., 128, 32768, 840506558 ], [ PushBack(1894834799), PopBack, Clear, ..., PushBack(814265512) ] }\n</code></pre>"},{"location":"StatefulTesting/#configuring-stateful-test-runs","title":"Configuring stateful test runs","text":"<p>You can alter some of test characteristics of stateful test runs.</p> <ul> <li>Random seed</li> <li>Number of runs</li> <li>Maximum time duration of test runs</li> </ul> <pre><code>auto prop = statefulProperty(...);\n// set random seed\nprop.setSeed(5464561L);\n// number of sequences to be tested\nprop.setNumRuns(10000);\n// maximum time duration for go() is 60 seconds\nprop.setMaxDurationMs(60*1000);\nprop.go();\n// or you can simply chain the property:\nprop.setSeed(0).setNumRuns(1000).setMaxDurationMs(10000).go();\n</code></pre>"},{"location":"StatefulTesting/#alternative-style-using-action-classes","title":"Alternative Style: Using Action Classes","text":"<p>There are actually two styles of stateful testing - one with action functions(lambda) and one with action classes. While the first style using functions are easier to use and understand, the second style is more formal way of doing stateful testing. You may choose to use either style. Both have similar process of defining and running stateful tests. See the separate page for detail. Both styles are similar in terms of expressive power.</p>"},{"location":"StatefulTesting/#further-topics","title":"Further topics","text":"<ul> <li>See Concurrency Testing for testing for concurrent changes of a stateful object.</li> </ul>"},{"location":"StatefulTestingStyle2/","title":"Stateful Testing","text":""},{"location":"StatefulTestingStyle2/#style-2-using-action-classes","title":"Style 2: Using Action Classes","text":""},{"location":"StatefulTestingStyle2/#understanding-action","title":"Understanding <code>Action</code>","text":"<p>In the second style, you will define actions by defining an <code>Action</code> or a <code>SimpleAction</code> abstract class with following signatures:</p> <pre><code>template &lt;typename ObjectType, typename ModelType&gt;\nstruct Action\n{\nvirtual bool precondition(const ObjectType&amp;, const ModelType&amp;) { ... }\n\nvirtual bool run(ObjectType&amp;, ModelType&amp;) { ... }\n};\n\ntemplate &lt;typename ObjectType&gt;\nstruct SimpleAction\n{\nvirtual bool precondition(const ObjectType&amp;) { ... }\n\nvirtual bool run(ObjectType&amp;) { ... }\n};\n</code></pre> <p><code>ObjectType</code> is the target stateful object type. In this case, <code>MyVector</code> is the <code>ObjectType</code> type. <code>ModelType</code> is optional structure to hold useful data for validation of the <code>ObjectType</code> based on some model, throughout the test sequence.</p> <p>You would prefer to use <code>SimpleAction</code> if you don't need a model structure, and <code>Action</code> if you need one.</p> <ul> <li><code>precondition</code> is called to check if an action in the sequence is applicable to current state. If it's not the action is skipped.<ul> <li>Overriding <code>precondition</code> is optional and returns <code>true</code> by default</li> </ul> </li> <li><code>run</code> is called to actually apply the state change and perform validations against your model after the state change</li> </ul> <pre><code>template &lt;typename ObjectType, typename ModelType&gt;\nstruct Action\n{\nvirtual bool precondition(const ObjectType&amp; system, const ModelType&amp;) { ... }\n\nvirtual bool run(ObjectType&amp; system, ModelType&amp;) { ... }\n};\n</code></pre>"},{"location":"StatefulTestingStyle2/#defining-actions","title":"Defining Actions","text":"<p>For the listed methods that might change the state of a <code>MyVector</code>, we would write <code>Action</code>s for each.</p> <pre><code>void push_back(int val);\nint pop_back();\nint&amp; at(int pos);\nvoid clear();\n</code></pre> <pre><code>struct PushBack : public SimpleAction&lt;MyVector&gt; {\nint val;\n\nPushBack(int val) : val(val) {\n}\n\nbool run(MyVector&amp; vector) {\nvector.push_back(val);\n}\n};\n\nstruct PopBack : public SimpleAction&lt;MyVector&gt; {\nbool precondition(MyVector&amp; vector) {\nreturn vector.size() &gt; 0;\n}\n\nbool run(MyVector&amp; vector) {\nvector.pop_back(val);\n}\n};\n\nstruct SetAt : public SimpleAction&lt;MyVector&gt; {\nint pos;\nint val;\n\nSetAt(int pos, int val) : pos(pos), val(val) {\n}\n\nbool precondition(MyVector&amp; vector) {\nreturn pos &lt; vector.size();\n}\n\nbool run(MyVector&amp; vector) {\nvector.at(pos) = val;\n}\n};\n\nstruct Clear : public SimpleAction&lt;MyVector&gt; {\nbool run(MyVector&amp; vector) {\nvector.clear(val);\n}\n};\n</code></pre>"},{"location":"StatefulTestingStyle2/#generating-action-sequence","title":"Generating <code>Action</code> sequence","text":"<p>With our <code>Action</code>s properly defined, we can generate a sequence of <code>Action</code>s. <code>actionClasses</code> function is a useful shorthand for <code>oneOf</code> generator combinator that is specialized for generating <code>Action</code> Sequences.</p> <pre><code>        auto actionListGen = actionListGenOf&lt;SimpleAction&lt;MyVector&gt;&gt;(\n// int -&gt; PushBack(int)\ntransform&lt;int, std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;(\nArbi&lt;int&gt;(), [](const int&amp; value) { return std::make_shared&lt;PushBack&gt;(value); }),\n\n// Popback()\njust&lt;std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;([]() { return std::make_shared&lt;PopBack&gt;(); }),\n\n// (int, int) -&gt; SetAt(int, int)\ntransform&lt;int, std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;(\nArbi&lt;std::pair&lt;int,int&gt;&gt;(), [](const std:;pair&lt;int,int&gt;&amp; posAndVal) { return std::make_shared&lt;SetAt&gt;(posAndVal.first, posAndVal.second); }),\n\n// Clear()\njust&lt;std::shared_ptr&lt;SimpleAction&lt;MyVector&gt;&gt;&gt;([]() { return std::make_shared&lt;Clear&gt;(); })\n);\n</code></pre> <p>This defines a generator for action sequences that randomly chooses <code>push_back</code>, <code>pop_back</code>, <code>at</code>, and <code>clear</code> methods for <code>MyVector</code> with arguments.</p>"},{"location":"StatefulTestingStyle2/#running-stateful-tests","title":"Running stateful tests","text":"<p>Finally, we will call <code>statefulProperty::forAll</code> to perform generation of action sequences and run the tests. You should supply generator for initial state of <code>MyVector</code> to start with.</p> <pre><code>auto prop = statefulProperty&lt;SimpleAction&lt;MyVector&gt;&gt;(Arbi&lt;MyVector&gt;(), actionListGen)\nprop.forAll();\n</code></pre>"},{"location":"WhyPropertyBasedTesting/","title":"Why Property-based testing?","text":""},{"location":"WhyPropertyBasedTesting/#generalization-and-abstraction","title":"Generalization and abstraction","text":"<p>Property-based testing, or PBT in short, lets you write a test using abstract idea, instead of some dummy examples or contrived scenarios that are easy to break over time and hard to interpret. You can write tests using specification or requirements - which are essentially expressed as combination of input domain and expected behavior (=properties) of tested component.</p>"},{"location":"WhyPropertyBasedTesting/#clear-separation-of-variants-and-invariants","title":"Clear separation of variants and invariants","text":"<p>Describing a test using input domain and expected behavior means that we have clear cut between variants and invariants. We often mix variants and invariants in our tests in typical example-based tests. This is one of the reasons why those tests become hard to maintain and difficult to read over time. In property-based tests, however, we clearly separate invariants as properties and variants as input domain. Thus tests become more readable and gets easier to maintain, as they carry test writers' intention better.</p>"},{"location":"WhyPropertyBasedTesting/#convenience-and-versatility","title":"Convenience and versatility","text":"<p>Property-based testing often provides with the convenient out-of-box generators (sometimes called strategies) and combinators (that lets you make new generators out of existing ones), and lets you to effortlessly define the input domain for your tests. You can specify your input domains using various notions - range, constraint, union, transformation, composition, and dependency, just to name a few.</p>"},{"location":"WhyPropertyBasedTesting/#reusability-and-scalability","title":"Reusability and Scalability","text":"<p>As it defines input domain with generators and combinators, Property-based testing lets you define and reuse existing input domain and properties to build new input domain and properties with ease. These new ones then can be reused as building blocks for next tests and so on. Reusable nature of property-based testing lets you write tests with scale. Complex combinations of components can be readily tested if simpler pieces are already available by tests written previously.</p> <p> </p>"},{"location":"WhyPropertyBasedTesting2/","title":"WhyPropertyBasedTesting2","text":""},{"location":"WhyPropertyBasedTesting2/#an-attempt-to-approximate-software-quality","title":"An attempt to approximate software quality","text":"<p>Property-based testing, or sometimes refered to as specification-based testing, tries to verify software's integrity by validating the requirements of a software component, where the requirements are often written as properties(or specifications). They are validated using massive input combinations.</p> <pre><code>    // encode &amp; decode are inverse functions\nASSERT(decode(encode(text)) == text);\n</code></pre> <p>Many property-based testing implementations derive their ideas from QuickCheck, which was originally written in Haskell. Quickcheck's basic idea is to quickly prove a theorem, as the name suggests. But how can anything possibly be proved about software? A software piece is often too complex to reason about in definitive way. If we randomly choose 100 input combinations to test your component and confirm that it satisfies the required properties with every 100 of the combinations, you may argue that it's still not proving anything. But how about if we increase the number of combinations to 1,000, or 10,000?</p> <p>Certainly there still remains some possibility that one of the untested input combinations might fail the properties. But we can say this as an approximation - an approximation of software integrity or quality. As the number of evidences grows, more accurate the approximation it becomes. It's often very effective to approximate an answer when it cannot be easily obtained. It's sometimes the only feasible way.</p> <p>Property-based testing can do exactly that. You define a property (or 'specification') of a software component should satisfy, then you can let the test library prove or disprove that requirement automatically by feeding in random (but valid) input combinations.</p> <p>In fact, often the underlying issues of a component are easily detected than you can imagine. Some properties may hold true with a few combinations, but such luck usually cannot last for long. The issues reveal themselves eventually.</p> <p>In property-based testing, software requirements can be validated in automated fashion as in static code analyses, but by actually running the code as in dynamic code analyses. By actually running the code, we can check for many software requirements and issues that are usually not feasible to find with static code analyses.</p> <p> </p>"},{"location":"WhyPropertyBasedTesting2/#why-property-based-testing-for-c","title":"Why property-based testing for C++?","text":"<p>Property-based tesing relies on massive input combinations to be attempted to achieve high confidence. For example, if you have a function with 10 boolean flags to be thoroughly tested in runtime, you need to test it with <code>2</code><code>10</code> <code>= 1024</code> combinations. This kind of complexity has been often considered as unmanageable and something that should be avoided. However, as most C++ unit components (as single unit or multiple components combined) tend to execute blazingly fast on modern machines, running them 1000 times is usually not an issue. Unless it's involving external devices like secondary disk or network communication, running a typical C++ component 1000 times would normally end up finishing under a second barrier. This is why C++ and property-based testing is a fine pair.</p> <p>I feel many of the existing property-based testing implementation in C++ are either outdated or too daunting to learn due to their complexity. <code>cppproptest</code> focuses on lowering the learning curve while maintaining feature-completeness.</p>"}]}