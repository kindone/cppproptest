{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"cppproptest \u00b6 cppproptest is a property-based testing library for C++. It focuses on usability with features included: Out-of-box generators for primitives and standard containers Set of powerful generator combinators for creating new generators from existing generators Shrinking capability for quickly finding root cause of a failure and automated debugging support Stateful testing support for testing state changes Concurrency testing support for testing concurrent state changes You can get started with cppproptest on this page . Why Property-based Testing? \u00b6 Generalization and Abstraction \u00b6 Property-based testing lets you write tests using abstract ideas, instead of introducing some dummy examples or overly contrived scenarios. You can write tests focusing on specification or requirements of the tested components. Clear Separation of Variants and Invariants \u00b6 In reality, we often mix variants and invariants in our tests under typical example-based tests . This is one of the reasons why those tests become hard to maintain and difficult to read over time. Let's see following example-based test for an encoder and a decoder: // a text encoded and then decoded must be identical to original MyEncoder encoder ; MyDecoder decoder ; auto encodedMsg = encoder . encode ( \"Some dummy content that hopefully prove or disprove this works\" ); auto decodedMsg = decoder . decode ( encodedMsg ); ASSERT_EQ ( \"Some dummy content that hopefully prove or disprove this works\" , decodedMsg ); Even a simple test like this is confusing, as some dummy string value seems like as if it's playing a significant role in the test but in fact it isn't. Turning this dummy value to a free variable would lead to greater generalization of the test: []( ltt :: string originalMsg ) { // a text encoded and then decoded must be identical to originalMsg MyEncoder encoder ; MyDecoder decoder ; auto encodedMsg = encoder . encode ( originalMsg ); auto decodedMsg = decoder . decode ( encodedMsg ); PROP_ASSERT_EQ ( originalMsg , decodedMsg ); }; The new free variable originalMsg becomes the variant part ( input domain ) of the test while the rest becomes the invariant part. In order to turn this into a concrete test run, we can feed in some random values for the free variable originalMsg . This can be achieved by enclosing this function with forAll() function, which calls the given test function many times with some randomly generated values for the free variable originalMsg : forAll ([]( ltt :: string originalMsg ) { // a text encoded and then decoded must be identical to original MyEncoder encoder ; MyDecoder decoder ; auto encodedMsg = encoder . encode ( originalMsg ); auto decodedMsg = decoder . decode ( encodedMsg ); PROP_ASSERT_EQ ( originalMsg , decodedMsg ); }); As a result, forAll() will test the encoder and decoder against arbitrary input strings, by calling the property function hundreds of times (200 is the default number of runs) with some random strings, instead of relying on a dummy value. This let's you validate the property with various forms of originalMsg . With this approach, our test becomes more readable, gets easier to maintain, and carries test writer's intention better. Convenience and Versatility \u00b6 Property-based testing often provides with the convenient out-of-box generators and generator combinators (that can make new generators out of existing ones), and lets you to effortlessly define an input domain tailored for your test. You can specify your input domain using various notions - range, constraint, union, transformation, composition, and dependency, just to name a few. Following example shows how certain input domain of string type can be specified using a built-in generator and generator combinators: // a tailored string generator auto stringGen = Arbitrary < int > () . filter ([] ( int & num ) { return num % 2 == 0 ; }) // even numbers only . map ([] ( int & num ) { return \"<\" + ltt_adp :: to_string ( numStr ) + \">\" ; // string like \"<0>\", ..., \"<n>\" }); // property forAll ([]( ltt :: string original ) { // ... // }, stringGen ); The forAll function automatically identifies parameter types of the given property function. This automation allows any number of parameters of simple or complex types to be used to define a property-based test: It then automatically feeds in the randomly generated values of those types to call the given function multiple times. With this powerful generation engine, we can fully parameterize and randomize our tests with high flexibility but with much less effort. You don't need to care too much about how to test your requirements. Most of it is automatically done for you by the framework, letting you to focus on what to test. Further Topics and Details: \u00b6 Getting Started with cppproptest Introduction to generators Arbitraries Built-in generators Generator combinators for creating generators from existing ones Counterexamples and notion of shrinking for automated debugging Printing facilities Stateful testing with cppproptest Concurrency testing with cppproptest Advanced mocking with cppproptest (work in progress)","title":"cppproptest"},{"location":"#cppproptest","text":"cppproptest is a property-based testing library for C++. It focuses on usability with features included: Out-of-box generators for primitives and standard containers Set of powerful generator combinators for creating new generators from existing generators Shrinking capability for quickly finding root cause of a failure and automated debugging support Stateful testing support for testing state changes Concurrency testing support for testing concurrent state changes You can get started with cppproptest on this page .","title":"cppproptest"},{"location":"#why-property-based-testing","text":"","title":"Why Property-based Testing?"},{"location":"#generalization-and-abstraction","text":"Property-based testing lets you write tests using abstract ideas, instead of introducing some dummy examples or overly contrived scenarios. You can write tests focusing on specification or requirements of the tested components.","title":"Generalization and Abstraction"},{"location":"#clear-separation-of-variants-and-invariants","text":"In reality, we often mix variants and invariants in our tests under typical example-based tests . This is one of the reasons why those tests become hard to maintain and difficult to read over time. Let's see following example-based test for an encoder and a decoder: // a text encoded and then decoded must be identical to original MyEncoder encoder ; MyDecoder decoder ; auto encodedMsg = encoder . encode ( \"Some dummy content that hopefully prove or disprove this works\" ); auto decodedMsg = decoder . decode ( encodedMsg ); ASSERT_EQ ( \"Some dummy content that hopefully prove or disprove this works\" , decodedMsg ); Even a simple test like this is confusing, as some dummy string value seems like as if it's playing a significant role in the test but in fact it isn't. Turning this dummy value to a free variable would lead to greater generalization of the test: []( ltt :: string originalMsg ) { // a text encoded and then decoded must be identical to originalMsg MyEncoder encoder ; MyDecoder decoder ; auto encodedMsg = encoder . encode ( originalMsg ); auto decodedMsg = decoder . decode ( encodedMsg ); PROP_ASSERT_EQ ( originalMsg , decodedMsg ); }; The new free variable originalMsg becomes the variant part ( input domain ) of the test while the rest becomes the invariant part. In order to turn this into a concrete test run, we can feed in some random values for the free variable originalMsg . This can be achieved by enclosing this function with forAll() function, which calls the given test function many times with some randomly generated values for the free variable originalMsg : forAll ([]( ltt :: string originalMsg ) { // a text encoded and then decoded must be identical to original MyEncoder encoder ; MyDecoder decoder ; auto encodedMsg = encoder . encode ( originalMsg ); auto decodedMsg = decoder . decode ( encodedMsg ); PROP_ASSERT_EQ ( originalMsg , decodedMsg ); }); As a result, forAll() will test the encoder and decoder against arbitrary input strings, by calling the property function hundreds of times (200 is the default number of runs) with some random strings, instead of relying on a dummy value. This let's you validate the property with various forms of originalMsg . With this approach, our test becomes more readable, gets easier to maintain, and carries test writer's intention better.","title":"Clear Separation of Variants and Invariants"},{"location":"#convenience-and-versatility","text":"Property-based testing often provides with the convenient out-of-box generators and generator combinators (that can make new generators out of existing ones), and lets you to effortlessly define an input domain tailored for your test. You can specify your input domain using various notions - range, constraint, union, transformation, composition, and dependency, just to name a few. Following example shows how certain input domain of string type can be specified using a built-in generator and generator combinators: // a tailored string generator auto stringGen = Arbitrary < int > () . filter ([] ( int & num ) { return num % 2 == 0 ; }) // even numbers only . map ([] ( int & num ) { return \"<\" + ltt_adp :: to_string ( numStr ) + \">\" ; // string like \"<0>\", ..., \"<n>\" }); // property forAll ([]( ltt :: string original ) { // ... // }, stringGen ); The forAll function automatically identifies parameter types of the given property function. This automation allows any number of parameters of simple or complex types to be used to define a property-based test: It then automatically feeds in the randomly generated values of those types to call the given function multiple times. With this powerful generation engine, we can fully parameterize and randomize our tests with high flexibility but with much less effort. You don't need to care too much about how to test your requirements. Most of it is automatically done for you by the framework, letting you to focus on what to test.","title":"Convenience and Versatility"},{"location":"#further-topics-and-details","text":"Getting Started with cppproptest Introduction to generators Arbitraries Built-in generators Generator combinators for creating generators from existing ones Counterexamples and notion of shrinking for automated debugging Printing facilities Stateful testing with cppproptest Concurrency testing with cppproptest Advanced mocking with cppproptest (work in progress)","title":"Further Topics and Details:"},{"location":"Combinators/","text":"Generator Combinators \u00b6 Generator combinators are provided for building a new generator based on existing ones. Many of them come from ideas and best practices of functional programming. They can be chained as they receive existing generator(s) as argument and returns new generator. While you can go through this document from top to the bottom, you might be want to find a suitable combinator for your use case using this table: Purpose Related Generator/Combinator Examples Generate just a constant just<T> 0 or \"1337\" Generate a value within constants elementOf<T> a prime number under 100 Generate a list of unique values Arbi<set<T>> {3,5,1} but not {3,5,5} Generate a value within numeric range of values interval<T> , integers<T> a number within 1 ~ 9999 Generate a pair or a tuple of different types pairOf<T1,T2> , tupleOf<Ts...> a pair<int, string> Union multiple generators unionOf<T> ( oneOf<T> ) 20~39 or 60~79 combined Transform into another type or a value transform<T,U> \"0\" or \"1.4\" (a number as string). Generate a struct or a class object construct<T,ARGS...> a Rectangle object with width and height Apply constraints in generated values filter ( suchThat ) an even natural number ( n % 2 == 0 ) Generate values with dependencies or relationships dependency , chain , pairWith , tupleWith a rectangle where width == height * 2 Generate a value based on previously generated value aggregate , accumulate a sequence of numbers where each one is between 0.5x and 1.5x of its previous Basic Generator Combinators \u00b6 Constants \u00b6 just<T>(T*) , just<T>(T) , just<T>(shared_ptr<T>) : always generates a specific value. A shared pointer can be used for non-copyable types. lazy<T>(ltt::function<T()>) : generates a value by calling a function auto zeroGen = just ( 0 ); // template argument is optional if type is deducible auto oneGen = lazy < int > ([]() { return 1 ; }); Selecting from constants \u00b6 You may want to random choose from specific list of values. elementOf<T>(val1, ..., valN) : generates a type T from multiple values for type T , by choosing one of the values randomly // generates a prime number under 50 auto primeGen = elementOf < int > ( 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ); elementOf can receive optional probabilitistic weights ( 0 < weight < 1 , sum of weights must not exceed 1.0) for generators. If weight is unspecified for a generator, it is calculated automatically so that remaining probability among unspecified generators is evenly distributed. weightedVal(<value>, <weight>) is used to annotate the desired weight. // generates a numeric within ranges [0,10], [100, 1000], [10000, 100000] // weight for 10 automatically becomes 1.0 - 0.8 - 0.15 == 0.05 elementOf < int > ( weightedVal ( 2 , 0.8 ), weightedVal ( 5 , 0.15 ), 10 ); Integers and intervals \u00b6 Some utility generators for integers are provided interval<INT_TYPE>(min, max) : generates an integer type(e.g. uint16_t ) in the closed interval [min, max] . integers<INT_TYPE(from, count) : generates an integer type starting from from interval < int64_t > ( 1 , 28 ); interval ( 1 , 48 ); // template type argument can be ommitted if the input type(`int`) is the same as the output type. interval ( 1L , 48L ); // template type argument can be ommitted if the input type(`int`) is the same as the output type. interval ( 0 , 10 ); // generates an integer in {0, ..., 10} interval ( 'A' , 'Z' ); // generates a char of uppercase alphabet integers ( 0 , 10 ); // generates an integer in {0, ..., 9} integers ( 1 , 10 ); // generates an integer in {1, ..., 10} natural<INT_TYPE>(max) : generates a positive integer up to max (inclusive) nonNegative<INT_TYPE>(max) : : generates zero or a positive integer up to max (inclusive) Pair and Tuples \u00b6 Generators for different types can be bound to a pair or a tuple. pairOf<T1, T2>(gen1, gen2) : generates a ltt::pair<T1,T2> based on result of generators gen1 and gen2 auto pairGen = pairOf ( Arbi < int > (), Arbi < ltt :: string > ()); tupleOf<T1, ..., TN>(gen1, ..., genN) : generates a std::tuple<T1,...,TN> based on result of generators gen1 through genN auto tupleGen = tupleOf ( Arbi < int > (), Arbi < ltt :: string > (), Arbi < double > ()); Advanced Generator Combinators \u00b6 Selecting from generators \u00b6 You can combine generators to a single generator that can generate each of them with some probability. This can be considered as taking a union of generators. oneOf<T>(gen1, ..., genN) : generates a type T from multiple generators for type T , by choosing one of the generators randomly // generates a numeric within ranges [0,10], [100, 1000], [10000, 100000] auto evenGen = oneOf < int > ( interval ( 0 , 10 ), interval ( 100 , 1000 ), interval ( 10000 , 100000 )); oneOf can receive optional probabilistic weights ( 0 < weight < 1 , sum of weights must not exceed 1.0) for generators. If weight is unspecified for a generator, it is calculated automatically so that remaining probability among unspecified generators is evenly distributed. weightedGen(<generator>, <weight>) is used to annotate the desired weight. // generates a numeric within ranges [0,10], [100, 1000], [10000, 100000] auto evenGen = oneOf < int > ( weightedGen ( interval ( 0 , 10 ), 0.8 ), weightedGen ( interval ( 100 , 1000 ), 0.15 ), interval ( 10000 , 100000 ) /* weight automatically becomes 1.0 - (0.8 + 0.15) == 0.05 */ ); unionOf<T> is an alias of oneOf<T> Constructing an object \u00b6 You can generate an object of a class or a struct type T , by calling a matching constructor of T . construct<T, ARG1, ..., ARGN>([gen1, ..., genM]) : generates an object of type T by calling its constructor that matches the signature (ARG1, ..., ARGN) . Custom generators gen1 ,..., genM can be supplied for generating arguments. If M < N , then rest of the arguments are generated with Arbi s. struct Coordinate { Coordinate ( int x , int y ) { // ... } }; // ... auto coordinateGen1 = construct < Coordinate , int , int > ( interval ( -10 , 10 ), interval ( -20 , 20 )); auto coordinateGen2 = construct < Coordinate , int , int > ( interval ( -10 , 10 )); // y is generated with Arbi<int> Applying constraints \u00b6 You can add a filtering condition to a generator to restrict the generated values to have certain constraint. filter<T>(gen, condition_predicate) : generates a type T that satisfies condition predicate ( condition_predicate returns true ) // generates even numbers auto evenGen = filter < int > ( Arbi < int > (),[]( int & num ) { return num % 2 == 0 ; }); suchThat<T> : an alias of filter Transforming or mapping \u00b6 You can transform an existing generator to create new generator by providing a transformer function. This is equivalent to mapping in functional programming context. transform<T,U>(gen, transformer) : generates type U based on generator for type T , using transformer that transforms a value of type T to type U // generates string from integers (e.g. \"0\", \"1\", ... , \"-16384\") auto numStringGen = transform < int , ltt :: string > ( Arbi < int > (),[]( int & num ) { return ltt :: string ( num ); }); Deriving or flat-mapping \u00b6 Another combinator that resembles transform is derive . This is equivalent to flat-mapping or binding in functional programming. Difference to transform<T,U> is that you can have greater control on the resultant generator. derive<T, U>(genT, genUGen) : derives a new generator for type U , based on result of genT , which is a generator for type T . // generates a string something like \"KOPZZFASF\", \"ghnpqpojv\", or \"49681002378\", ... that consists of only uppercase/lowercase alphabets/numeric characters. auto stringGen = derive < int , ltt :: string > ( integers ( 0 , 2 ), []( int & num ) { if ( num == 0 ) return Arbi < ltt :: string > ( interval ( 'A' , 'Z' )); else if ( num == 1 ) return Arbi < ltt :: string > ( interval ( 'a' , 'z' )); else // num == 2 return Arbi < ltt :: string > ( interval ( '0' , '9' )); }); Following table compares transform and derive : Combinator transformer signature Result type transform<T,U> function<U(T)> Generator<U> derive<T,U> function<Generator<U>(T)> Generator<U> Values with dependencies \u00b6 You may want to include dependency in the generated values. There are two variants that do this. One generates a pair and the other one generates a tuple. dependency<T,U>(genT, genUgen) : generates a ltt::pair<T,U> with a generator genT for type T and genUgen . genUgen receives a type T and returns a generator for type U . This can effectively create a generator for a pair where second item depends on the first one. auto sizeAndVectorGen = dependency < int , ltt :: vector < bool >> ( Arbi < bool > (), []( int & num ) { auto vectorGen = Arbi < ltt :: vector < int >> (); vectorGen . maxLen = num ; // generates a vector with maximum size of num return vectorGen ; }); auto nullableIntegers = dependency < bool , int > ( Arbi < bool > (), []( bool & isNull ) { if ( isNull ) return just < int > ( 0 ); else return fromTo < int > ( 10 , 20 ); }); chain<Ts..., U>(genT, genUgen) : similar to dependency , but takes a tuple generator for std::tuple<Ts...> and generates a std::tuple<Ts..., U> instead of a ltt::pair . chain can be repeatedly applied to itself, and results in a tuple one element larger than the previous one. You can chain multiple dependencies with this form. auto yearMonthGen = tupleOf ( fromTo ( 0 , 9999 ), fromTo ( 1 , 12 )); // number of days of month depends on month (28~31 days) and year (whether it's a leap year) auto yearMonthDayGen = chain < std :: tuple < int , int > , int > ( yearMonthGen , []( std :: tuple < int , int >& yearMonth ) { int year = std :: get < 0 > ( yearMonth ); int month = std :: get < 1 > ( yearMonth ); if ( monthHas31Days ( month )) { return fromTo ( 1 , 31 ); } else if ( monthHas30Days ( month )) { return fromTo ( 1 , 30 ); } else { // february has 28 or 29 days if ( isLeapYear ( year )) return fromTo ( 1 , 29 ); else return fromTo ( 1 , 28 ); } }); // yearMonthDayGen generates std::tuple<int, int, int> of (year, month, day) Actually you can achieve the similar goal using filter combinator: // generate any year,month,day combination auto yearMonthDayGen = tupleOf ( fromTo ( 0 , 9999 ), fromTo ( 1 , 12 ), fromTo ( 1 , 31 )); // apply filter auto validYearMonthDayGen = yearMonthDayGen . filter ([]( std :: tuple < int , int , int >& ymd ) { int year = std :: get < 0 > ( ymd ); int month = std :: get < 1 > ( ymd ); int day = std :: get < 2 > ( ymd ); if ( monthHas31Days ( month ) && day <= 31 ) return true ; else if ( monthHas30Days ( month ) && day <= 30 ) return true ; else { // february has 28 or 29 days if ( isLeapYear ( year ) && day <= 29 ) return true ; else return day <= 28 ; } }); However, using filter for generating values with complex dependency may result in many generated values that do not meet the constraint to be discarded and retried. Therefore it's usually not recommended for that purpose if the ratio of discarded values is high. Aggregation or Accumulation of Values \u00b6 You may want to generate values that are related to previously generated values. This can be achieved with aggregate or accumulate . Both of the combinators take base generator in the form of Generator<T> as the first argument and a factory that takes a value of type T and returns Generator<T> , as the second argument. While aggregate generates a single value, accumulate generates a list of values at each generation. Combinator Result type Remark aggregate<GenT, GenT2GenT>(genT, gen2GenT, minSize, maxSize) Generator<T> accumulate<GenT, GenT2GenT>(genT, gen2GenT, minSize, maxSize) Generator<list<T>> // generate initial value auto baseGen = interval ( 0 , 1000 ); // generate a value based on previous value auto gen = aggregate ( gen1 , []( int & num ) { return interval ( num / 2 , num * 2 ); }, 2 /* min size */ , 10 /* max size */ ); // generate initial value auto baseGen = interval ( 0 , 1000 ); // generate list of values auto gen = accumulate ( gen1 , []( int & num ) { return interval ( num / 2 , num * 2 ); }, 2 /* min size */ , 10 /* max size */ ); Utility Methods in Standard Generators \u00b6 Standard generators and combinators (including Arbi<T> and Construct<...> ) returns a Generator<T> , which is of the form (Random&) -> Shrinkable<T> (aliased as GenFunction<T> ), but has additional combinator methods decorated for ease of use. They in fact have equivalent standalone counterparts. Following table shows this relationship: Decorated method Result type Equivalent Standalone combinator Generator<T>::filter Generator<T> filter<T> Generator<T>::map<U> Generator<U> transform<T,U> Generator<T>::flatMap<U> Generator<U> derive<T,U> Generator<T>::pairWith<U> Generator<ltt::pair<T,U>> dependency<T,U> Generator<T>::tupleWith<U> Generator<std::tuple<T,U>> chain<T,U> Generator<std::tuple<Ts...>>::tupleWith<U> Generator<std::tuple<Ts...,U>> chain<std::tuple<Ts...>,U> These functions and methods can be continuously chained. .map<U>(mapper) : effectively calls transform<T,U>(gen, transformer) combinator on itself with type T and generator gen . // generator for strings of arbitrary number Arbi < int > (). map < ltt :: string > ([]( int & num ) { return ltt_adp :: to_string ( num ); }); // this is equivalent to: transform < int , ltt :: string > ( Arbi < int > (), []( int & num ) { return ltt_adp :: to_string ( num ); }); .filter(filterer) : apply filter combinator on itself. // two equivalent ways to generate random even numbers auto evenGen = Arbi < int > (). filter ([]( int & num ) { return num % 2 == 0 ; }); auto evenGen = filter < int > ( Arbi < int > (),[]( int & num ) { return num % 2 == 0 ; }); .flatMap<U>(genUGen) : based on generated result of the generator object itself, induces a new generator for type U . It's equivalent combinator is derive<T,U> . Difference to .map<U> (or transform<T,U> ) is that you can have greater control on the resultant generator. auto stringGen = Arbi < int > (). flatMap < ltt :: string > ([]( int & num ) { auto genString = Arbi < ltt :: string > (); genString . setMaxSize ( num ); return genString ; }); .pairWith<U>(genUGen) or tupleWith<U>(genUGen) : chains itself to create a generator of pair or tuple. Equivalent to dependency or chain , respectively. Arbi < bool > (). tupleWith < int > ([]( bool & isEven ) { if ( isEven ) return Arbi < int > (). filter ([]( int & value ) { return value % 2 == 0 ; }); else return Arbi < int > (). filter ([]( int & value ) { return value % 2 == 1 ; }); }). tupleWith < ltt :: string > ([]( std :: tuple < bool , int >& tuple ) { int size = std :: get < 1 > ( tuple ); auto stringGen = Arbi < ltt :: string > (); stringGen . setSize ( size ); return stringGen ; }); Notice tupleWith can automatically chain a tuple generator of n parameters into a tuple generator of n+1 parameters ( bool generator -> tuple<bool, int> generator -> tuple<bool, int, string> generator in above example)","title":"Generator Combinators"},{"location":"Combinators/#generator-combinators","text":"Generator combinators are provided for building a new generator based on existing ones. Many of them come from ideas and best practices of functional programming. They can be chained as they receive existing generator(s) as argument and returns new generator. While you can go through this document from top to the bottom, you might be want to find a suitable combinator for your use case using this table: Purpose Related Generator/Combinator Examples Generate just a constant just<T> 0 or \"1337\" Generate a value within constants elementOf<T> a prime number under 100 Generate a list of unique values Arbi<set<T>> {3,5,1} but not {3,5,5} Generate a value within numeric range of values interval<T> , integers<T> a number within 1 ~ 9999 Generate a pair or a tuple of different types pairOf<T1,T2> , tupleOf<Ts...> a pair<int, string> Union multiple generators unionOf<T> ( oneOf<T> ) 20~39 or 60~79 combined Transform into another type or a value transform<T,U> \"0\" or \"1.4\" (a number as string). Generate a struct or a class object construct<T,ARGS...> a Rectangle object with width and height Apply constraints in generated values filter ( suchThat ) an even natural number ( n % 2 == 0 ) Generate values with dependencies or relationships dependency , chain , pairWith , tupleWith a rectangle where width == height * 2 Generate a value based on previously generated value aggregate , accumulate a sequence of numbers where each one is between 0.5x and 1.5x of its previous","title":"Generator Combinators"},{"location":"Combinators/#basic-generator-combinators","text":"","title":"Basic Generator Combinators"},{"location":"Combinators/#constants","text":"just<T>(T*) , just<T>(T) , just<T>(shared_ptr<T>) : always generates a specific value. A shared pointer can be used for non-copyable types. lazy<T>(ltt::function<T()>) : generates a value by calling a function auto zeroGen = just ( 0 ); // template argument is optional if type is deducible auto oneGen = lazy < int > ([]() { return 1 ; });","title":"Constants"},{"location":"Combinators/#selecting-from-constants","text":"You may want to random choose from specific list of values. elementOf<T>(val1, ..., valN) : generates a type T from multiple values for type T , by choosing one of the values randomly // generates a prime number under 50 auto primeGen = elementOf < int > ( 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ); elementOf can receive optional probabilitistic weights ( 0 < weight < 1 , sum of weights must not exceed 1.0) for generators. If weight is unspecified for a generator, it is calculated automatically so that remaining probability among unspecified generators is evenly distributed. weightedVal(<value>, <weight>) is used to annotate the desired weight. // generates a numeric within ranges [0,10], [100, 1000], [10000, 100000] // weight for 10 automatically becomes 1.0 - 0.8 - 0.15 == 0.05 elementOf < int > ( weightedVal ( 2 , 0.8 ), weightedVal ( 5 , 0.15 ), 10 );","title":"Selecting from constants"},{"location":"Combinators/#integers-and-intervals","text":"Some utility generators for integers are provided interval<INT_TYPE>(min, max) : generates an integer type(e.g. uint16_t ) in the closed interval [min, max] . integers<INT_TYPE(from, count) : generates an integer type starting from from interval < int64_t > ( 1 , 28 ); interval ( 1 , 48 ); // template type argument can be ommitted if the input type(`int`) is the same as the output type. interval ( 1L , 48L ); // template type argument can be ommitted if the input type(`int`) is the same as the output type. interval ( 0 , 10 ); // generates an integer in {0, ..., 10} interval ( 'A' , 'Z' ); // generates a char of uppercase alphabet integers ( 0 , 10 ); // generates an integer in {0, ..., 9} integers ( 1 , 10 ); // generates an integer in {1, ..., 10} natural<INT_TYPE>(max) : generates a positive integer up to max (inclusive) nonNegative<INT_TYPE>(max) : : generates zero or a positive integer up to max (inclusive)","title":"Integers and intervals"},{"location":"Combinators/#pair-and-tuples","text":"Generators for different types can be bound to a pair or a tuple. pairOf<T1, T2>(gen1, gen2) : generates a ltt::pair<T1,T2> based on result of generators gen1 and gen2 auto pairGen = pairOf ( Arbi < int > (), Arbi < ltt :: string > ()); tupleOf<T1, ..., TN>(gen1, ..., genN) : generates a std::tuple<T1,...,TN> based on result of generators gen1 through genN auto tupleGen = tupleOf ( Arbi < int > (), Arbi < ltt :: string > (), Arbi < double > ());","title":"Pair and Tuples"},{"location":"Combinators/#advanced-generator-combinators","text":"","title":"Advanced Generator Combinators"},{"location":"Combinators/#selecting-from-generators","text":"You can combine generators to a single generator that can generate each of them with some probability. This can be considered as taking a union of generators. oneOf<T>(gen1, ..., genN) : generates a type T from multiple generators for type T , by choosing one of the generators randomly // generates a numeric within ranges [0,10], [100, 1000], [10000, 100000] auto evenGen = oneOf < int > ( interval ( 0 , 10 ), interval ( 100 , 1000 ), interval ( 10000 , 100000 )); oneOf can receive optional probabilistic weights ( 0 < weight < 1 , sum of weights must not exceed 1.0) for generators. If weight is unspecified for a generator, it is calculated automatically so that remaining probability among unspecified generators is evenly distributed. weightedGen(<generator>, <weight>) is used to annotate the desired weight. // generates a numeric within ranges [0,10], [100, 1000], [10000, 100000] auto evenGen = oneOf < int > ( weightedGen ( interval ( 0 , 10 ), 0.8 ), weightedGen ( interval ( 100 , 1000 ), 0.15 ), interval ( 10000 , 100000 ) /* weight automatically becomes 1.0 - (0.8 + 0.15) == 0.05 */ ); unionOf<T> is an alias of oneOf<T>","title":"Selecting from generators"},{"location":"Combinators/#constructing-an-object","text":"You can generate an object of a class or a struct type T , by calling a matching constructor of T . construct<T, ARG1, ..., ARGN>([gen1, ..., genM]) : generates an object of type T by calling its constructor that matches the signature (ARG1, ..., ARGN) . Custom generators gen1 ,..., genM can be supplied for generating arguments. If M < N , then rest of the arguments are generated with Arbi s. struct Coordinate { Coordinate ( int x , int y ) { // ... } }; // ... auto coordinateGen1 = construct < Coordinate , int , int > ( interval ( -10 , 10 ), interval ( -20 , 20 )); auto coordinateGen2 = construct < Coordinate , int , int > ( interval ( -10 , 10 )); // y is generated with Arbi<int>","title":"Constructing an object"},{"location":"Combinators/#applying-constraints","text":"You can add a filtering condition to a generator to restrict the generated values to have certain constraint. filter<T>(gen, condition_predicate) : generates a type T that satisfies condition predicate ( condition_predicate returns true ) // generates even numbers auto evenGen = filter < int > ( Arbi < int > (),[]( int & num ) { return num % 2 == 0 ; }); suchThat<T> : an alias of filter","title":"Applying constraints"},{"location":"Combinators/#transforming-or-mapping","text":"You can transform an existing generator to create new generator by providing a transformer function. This is equivalent to mapping in functional programming context. transform<T,U>(gen, transformer) : generates type U based on generator for type T , using transformer that transforms a value of type T to type U // generates string from integers (e.g. \"0\", \"1\", ... , \"-16384\") auto numStringGen = transform < int , ltt :: string > ( Arbi < int > (),[]( int & num ) { return ltt :: string ( num ); });","title":"Transforming or mapping"},{"location":"Combinators/#deriving-or-flat-mapping","text":"Another combinator that resembles transform is derive . This is equivalent to flat-mapping or binding in functional programming. Difference to transform<T,U> is that you can have greater control on the resultant generator. derive<T, U>(genT, genUGen) : derives a new generator for type U , based on result of genT , which is a generator for type T . // generates a string something like \"KOPZZFASF\", \"ghnpqpojv\", or \"49681002378\", ... that consists of only uppercase/lowercase alphabets/numeric characters. auto stringGen = derive < int , ltt :: string > ( integers ( 0 , 2 ), []( int & num ) { if ( num == 0 ) return Arbi < ltt :: string > ( interval ( 'A' , 'Z' )); else if ( num == 1 ) return Arbi < ltt :: string > ( interval ( 'a' , 'z' )); else // num == 2 return Arbi < ltt :: string > ( interval ( '0' , '9' )); }); Following table compares transform and derive : Combinator transformer signature Result type transform<T,U> function<U(T)> Generator<U> derive<T,U> function<Generator<U>(T)> Generator<U>","title":"Deriving or flat-mapping"},{"location":"Combinators/#values-with-dependencies","text":"You may want to include dependency in the generated values. There are two variants that do this. One generates a pair and the other one generates a tuple. dependency<T,U>(genT, genUgen) : generates a ltt::pair<T,U> with a generator genT for type T and genUgen . genUgen receives a type T and returns a generator for type U . This can effectively create a generator for a pair where second item depends on the first one. auto sizeAndVectorGen = dependency < int , ltt :: vector < bool >> ( Arbi < bool > (), []( int & num ) { auto vectorGen = Arbi < ltt :: vector < int >> (); vectorGen . maxLen = num ; // generates a vector with maximum size of num return vectorGen ; }); auto nullableIntegers = dependency < bool , int > ( Arbi < bool > (), []( bool & isNull ) { if ( isNull ) return just < int > ( 0 ); else return fromTo < int > ( 10 , 20 ); }); chain<Ts..., U>(genT, genUgen) : similar to dependency , but takes a tuple generator for std::tuple<Ts...> and generates a std::tuple<Ts..., U> instead of a ltt::pair . chain can be repeatedly applied to itself, and results in a tuple one element larger than the previous one. You can chain multiple dependencies with this form. auto yearMonthGen = tupleOf ( fromTo ( 0 , 9999 ), fromTo ( 1 , 12 )); // number of days of month depends on month (28~31 days) and year (whether it's a leap year) auto yearMonthDayGen = chain < std :: tuple < int , int > , int > ( yearMonthGen , []( std :: tuple < int , int >& yearMonth ) { int year = std :: get < 0 > ( yearMonth ); int month = std :: get < 1 > ( yearMonth ); if ( monthHas31Days ( month )) { return fromTo ( 1 , 31 ); } else if ( monthHas30Days ( month )) { return fromTo ( 1 , 30 ); } else { // february has 28 or 29 days if ( isLeapYear ( year )) return fromTo ( 1 , 29 ); else return fromTo ( 1 , 28 ); } }); // yearMonthDayGen generates std::tuple<int, int, int> of (year, month, day) Actually you can achieve the similar goal using filter combinator: // generate any year,month,day combination auto yearMonthDayGen = tupleOf ( fromTo ( 0 , 9999 ), fromTo ( 1 , 12 ), fromTo ( 1 , 31 )); // apply filter auto validYearMonthDayGen = yearMonthDayGen . filter ([]( std :: tuple < int , int , int >& ymd ) { int year = std :: get < 0 > ( ymd ); int month = std :: get < 1 > ( ymd ); int day = std :: get < 2 > ( ymd ); if ( monthHas31Days ( month ) && day <= 31 ) return true ; else if ( monthHas30Days ( month ) && day <= 30 ) return true ; else { // february has 28 or 29 days if ( isLeapYear ( year ) && day <= 29 ) return true ; else return day <= 28 ; } }); However, using filter for generating values with complex dependency may result in many generated values that do not meet the constraint to be discarded and retried. Therefore it's usually not recommended for that purpose if the ratio of discarded values is high.","title":"Values with dependencies"},{"location":"Combinators/#aggregation-or-accumulation-of-values","text":"You may want to generate values that are related to previously generated values. This can be achieved with aggregate or accumulate . Both of the combinators take base generator in the form of Generator<T> as the first argument and a factory that takes a value of type T and returns Generator<T> , as the second argument. While aggregate generates a single value, accumulate generates a list of values at each generation. Combinator Result type Remark aggregate<GenT, GenT2GenT>(genT, gen2GenT, minSize, maxSize) Generator<T> accumulate<GenT, GenT2GenT>(genT, gen2GenT, minSize, maxSize) Generator<list<T>> // generate initial value auto baseGen = interval ( 0 , 1000 ); // generate a value based on previous value auto gen = aggregate ( gen1 , []( int & num ) { return interval ( num / 2 , num * 2 ); }, 2 /* min size */ , 10 /* max size */ ); // generate initial value auto baseGen = interval ( 0 , 1000 ); // generate list of values auto gen = accumulate ( gen1 , []( int & num ) { return interval ( num / 2 , num * 2 ); }, 2 /* min size */ , 10 /* max size */ );","title":"Aggregation or Accumulation of Values"},{"location":"Combinators/#utility-methods-in-standard-generators","text":"Standard generators and combinators (including Arbi<T> and Construct<...> ) returns a Generator<T> , which is of the form (Random&) -> Shrinkable<T> (aliased as GenFunction<T> ), but has additional combinator methods decorated for ease of use. They in fact have equivalent standalone counterparts. Following table shows this relationship: Decorated method Result type Equivalent Standalone combinator Generator<T>::filter Generator<T> filter<T> Generator<T>::map<U> Generator<U> transform<T,U> Generator<T>::flatMap<U> Generator<U> derive<T,U> Generator<T>::pairWith<U> Generator<ltt::pair<T,U>> dependency<T,U> Generator<T>::tupleWith<U> Generator<std::tuple<T,U>> chain<T,U> Generator<std::tuple<Ts...>>::tupleWith<U> Generator<std::tuple<Ts...,U>> chain<std::tuple<Ts...>,U> These functions and methods can be continuously chained. .map<U>(mapper) : effectively calls transform<T,U>(gen, transformer) combinator on itself with type T and generator gen . // generator for strings of arbitrary number Arbi < int > (). map < ltt :: string > ([]( int & num ) { return ltt_adp :: to_string ( num ); }); // this is equivalent to: transform < int , ltt :: string > ( Arbi < int > (), []( int & num ) { return ltt_adp :: to_string ( num ); }); .filter(filterer) : apply filter combinator on itself. // two equivalent ways to generate random even numbers auto evenGen = Arbi < int > (). filter ([]( int & num ) { return num % 2 == 0 ; }); auto evenGen = filter < int > ( Arbi < int > (),[]( int & num ) { return num % 2 == 0 ; }); .flatMap<U>(genUGen) : based on generated result of the generator object itself, induces a new generator for type U . It's equivalent combinator is derive<T,U> . Difference to .map<U> (or transform<T,U> ) is that you can have greater control on the resultant generator. auto stringGen = Arbi < int > (). flatMap < ltt :: string > ([]( int & num ) { auto genString = Arbi < ltt :: string > (); genString . setMaxSize ( num ); return genString ; }); .pairWith<U>(genUGen) or tupleWith<U>(genUGen) : chains itself to create a generator of pair or tuple. Equivalent to dependency or chain , respectively. Arbi < bool > (). tupleWith < int > ([]( bool & isEven ) { if ( isEven ) return Arbi < int > (). filter ([]( int & value ) { return value % 2 == 0 ; }); else return Arbi < int > (). filter ([]( int & value ) { return value % 2 == 1 ; }); }). tupleWith < ltt :: string > ([]( std :: tuple < bool , int >& tuple ) { int size = std :: get < 1 > ( tuple ); auto stringGen = Arbi < ltt :: string > (); stringGen . setSize ( size ); return stringGen ; }); Notice tupleWith can automatically chain a tuple generator of n parameters into a tuple generator of n+1 parameters ( bool generator -> tuple<bool, int> generator -> tuple<bool, int, string> generator in above example)","title":"Utility Methods in Standard Generators"},{"location":"ConcurrencyTesting/","text":"Concurrency Testing \u00b6 Once you're familiar with stateful testing , you can get acquainted with concurrent stateful testing easily. Concurrency testing performs interleaved state transitions using multiple threads in parallel. It allows us to see if any anomaly or breaking of requirement can be found in the tested component with concurrent accesses. Actually, a concurrency test is almost immediately achievable when you have prepared a stateful test for an object type. Following depicts a concurrent test for ltt::vector<int> with push_back(int) , pop_back() , and clear() actions included. using namespace proptest ; using namespace proptest :: concurrent ; // ... auto pushBackGen = Arbi < int > (). map < SimpleAction < ltt :: vector < int >>> ([]( int & value ) { return [ value ]( ltt :: vector < int >& obj ) { obj . push_back ( value ); return true ; }; }); auto popBackGen = just < SimpleAction < ltt :: vector < int >>> ([]( ltt :: vector < int >& obj ) { if ( obj . empty ()) return true ; obj . pop_back (); return true ; }); auto clearGen = just < SimpleAction < ltt :: vector < int >>> ([]( ltt :: vector < int >& obj ) { obj . clear (); return true ; }); auto actionListGen = actionListGenOf < ltt :: vector < int >> ( pushBackGen , popBackGen , clearGen ); auto concurrentProp = concurrency < ltt :: vector < int >> ( Arbi < ltt :: vector < int >> (), actionListGen ); concurrentProp . go (); You may have noticed that, above test would lead to exceptions or crashes, as ltt::vector is not made for concurrent writes, unless some synchronization mechanism is present. You can also add a post-check to be performed after each concurrent test run, by setting a post-check function to concurrent property with setPostCheck() method: concurrentProp . setPostCheck ([]( ltt :: vector < int >& obj ) { // ... post-check. perform some consistency check for obj }). go (); // variant with a model concurrentProp . setPostCheck ([]( ltt :: vector < int >& obj , VectorModel & model ) { // ... post-check. perform some consistency check for obj against model }). go (); While you can perform checks in some of the actions, it's sometimes better to have a post-check instead. In concurrent tests, your model as well as the stateful object can be concurrently accessed. Adding synchronization primitives for model object can cause unintended serialization to occur on the stateful object, too. This is why a post-check comes handy, as you don't need to care about synchronization since it's performed after all actions are finished and threads are joined.","title":"Concurrency Testing"},{"location":"ConcurrencyTesting/#concurrency-testing","text":"Once you're familiar with stateful testing , you can get acquainted with concurrent stateful testing easily. Concurrency testing performs interleaved state transitions using multiple threads in parallel. It allows us to see if any anomaly or breaking of requirement can be found in the tested component with concurrent accesses. Actually, a concurrency test is almost immediately achievable when you have prepared a stateful test for an object type. Following depicts a concurrent test for ltt::vector<int> with push_back(int) , pop_back() , and clear() actions included. using namespace proptest ; using namespace proptest :: concurrent ; // ... auto pushBackGen = Arbi < int > (). map < SimpleAction < ltt :: vector < int >>> ([]( int & value ) { return [ value ]( ltt :: vector < int >& obj ) { obj . push_back ( value ); return true ; }; }); auto popBackGen = just < SimpleAction < ltt :: vector < int >>> ([]( ltt :: vector < int >& obj ) { if ( obj . empty ()) return true ; obj . pop_back (); return true ; }); auto clearGen = just < SimpleAction < ltt :: vector < int >>> ([]( ltt :: vector < int >& obj ) { obj . clear (); return true ; }); auto actionListGen = actionListGenOf < ltt :: vector < int >> ( pushBackGen , popBackGen , clearGen ); auto concurrentProp = concurrency < ltt :: vector < int >> ( Arbi < ltt :: vector < int >> (), actionListGen ); concurrentProp . go (); You may have noticed that, above test would lead to exceptions or crashes, as ltt::vector is not made for concurrent writes, unless some synchronization mechanism is present. You can also add a post-check to be performed after each concurrent test run, by setting a post-check function to concurrent property with setPostCheck() method: concurrentProp . setPostCheck ([]( ltt :: vector < int >& obj ) { // ... post-check. perform some consistency check for obj }). go (); // variant with a model concurrentProp . setPostCheck ([]( ltt :: vector < int >& obj , VectorModel & model ) { // ... post-check. perform some consistency check for obj against model }). go (); While you can perform checks in some of the actions, it's sometimes better to have a post-check instead. In concurrent tests, your model as well as the stateful object can be concurrently accessed. Adding synchronization primitives for model object can cause unintended serialization to occur on the stateful object, too. This is why a post-check comes handy, as you don't need to care about synchronization since it's performed after all actions are finished and threads are joined.","title":"Concurrency Testing"},{"location":"CustomGenerator/","text":"Building Custom Generator from Scratch \u00b6 GenFunction<T> - Common representation for all generators for type T \u00b6 All generators, including the default ones, share the same base function type. A generator can be a callable (function, functor, or lambda) with following common signature: // (Random&) -> Shrinkable<T> This can be represented as (or coerced to) a standard function type, ltt::function<Shrinkable<T>(Random&)> . In cppproptest , this function type is aliased as GenFunction<T> . We will use this term GenFunction throughout this page to refer the generator function type. template < typename T > using GenFunction = ltt :: function < Shrinkable < T > ( Random & ); By the way, you may have noticed a strange template type Shrinkable in this signature. You can refer to Shrinkable for its further detail, but it can be treated as a wrapper for type T for now. So a generator ( Generator<T> ) basically generates a value of type T from a random number generator of Random type. A generator can be defined as function, functor, or lambda, as following: // lambda style auto myIntGen = []( Random & rand ) { int smallInt = rand . getRandomInt8 (); return make_shrinkable < int > ( smallInt ); }; // function style Shrinkable < int > myIntGen ( Random & rand ) { int smallInt = rand . getRandomInt8 (); return make_shrinkable < int > ( smallInt ); } // functor style struct MyIntGen { Shrinkable < int > operator ()( Random & rand ) { int smallInt = rand . getRandomInt8 (); return make_shrinkable < int > ( smallInt ); } }; Generator<T> - Decorator class for supercharging a generator \u00b6 The template class Generator<T> is an abstract functor class that also coerces to GenFunction<T> . A Generator<T> gives access to some useful methods so that you can wrap your callable with this to decorate with those methods. As all accompanied generators and combinators of cppproptest produce decorated Generator<T> s, you can use the utility methods out-of-box. // decorate a GenFunction with Generator<T> auto myIntGen = Generator < int > ([]( Random & rand ) { int smallInt = rand . getRandomInt8 (); return make_shrinkable < int > ( smallInt ); }); // .filter and other utility methods can be used once the generator is decorated with Generator<T> auto evenGen = myIntGen . filter ([]( int & value ) { return value % 2 == 0 ; }); // generates even numbers only","title":"Building Custom Generator from Scratch"},{"location":"CustomGenerator/#building-custom-generator-from-scratch","text":"","title":"Building Custom Generator from Scratch"},{"location":"CustomGenerator/#genfunctiont-common-representation-for-all-generators-for-type-t","text":"All generators, including the default ones, share the same base function type. A generator can be a callable (function, functor, or lambda) with following common signature: // (Random&) -> Shrinkable<T> This can be represented as (or coerced to) a standard function type, ltt::function<Shrinkable<T>(Random&)> . In cppproptest , this function type is aliased as GenFunction<T> . We will use this term GenFunction throughout this page to refer the generator function type. template < typename T > using GenFunction = ltt :: function < Shrinkable < T > ( Random & ); By the way, you may have noticed a strange template type Shrinkable in this signature. You can refer to Shrinkable for its further detail, but it can be treated as a wrapper for type T for now. So a generator ( Generator<T> ) basically generates a value of type T from a random number generator of Random type. A generator can be defined as function, functor, or lambda, as following: // lambda style auto myIntGen = []( Random & rand ) { int smallInt = rand . getRandomInt8 (); return make_shrinkable < int > ( smallInt ); }; // function style Shrinkable < int > myIntGen ( Random & rand ) { int smallInt = rand . getRandomInt8 (); return make_shrinkable < int > ( smallInt ); } // functor style struct MyIntGen { Shrinkable < int > operator ()( Random & rand ) { int smallInt = rand . getRandomInt8 (); return make_shrinkable < int > ( smallInt ); } };","title":"GenFunction&lt;T&gt; - Common representation for all generators for type T"},{"location":"CustomGenerator/#generatort-decorator-class-for-supercharging-a-generator","text":"The template class Generator<T> is an abstract functor class that also coerces to GenFunction<T> . A Generator<T> gives access to some useful methods so that you can wrap your callable with this to decorate with those methods. As all accompanied generators and combinators of cppproptest produce decorated Generator<T> s, you can use the utility methods out-of-box. // decorate a GenFunction with Generator<T> auto myIntGen = Generator < int > ([]( Random & rand ) { int smallInt = rand . getRandomInt8 (); return make_shrinkable < int > ( smallInt ); }); // .filter and other utility methods can be used once the generator is decorated with Generator<T> auto evenGen = myIntGen . filter ([]( int & value ) { return value % 2 == 0 ; }); // generates even numbers only","title":"Generator&lt;T&gt; - Decorator class for supercharging a generator"},{"location":"Generators/","text":"Generating Inputs \u00b6 Generators in Property-Based Testing \u00b6 Property-based testing promotes the concept of input domain of a property. In property-based testing, generators are the means for representing input domains. A generator is basically a function that generates random values. It defines the constraints of the generated random values in its body. Even a simple forAll() call depends on generators under the hood. Let's see following example: forAll ([]( int age , ltt :: string name ) { }); This forAll() call takes a function with parameters of types int and ltt::string . This function is the property function . If no additional specification is given on how to generate the values for age and name as in this example, the parameter types are identified to invoke the default generators for those types. In this case, it calls the default generators for int and ltt::string types. Those default generators are called the arbitraries . You can access the arbitraries of a type T with Arbitrary<T> or Arbi<T> . This code is actually equivalent to: forAll ([]( int age , ltt :: string name ) { }, Arbitrary < int > (), Arbitrary < ltt :: string > ()); Notice the extra arguments Arbitrary<int>() and Arbitrary<ltt::string>() in the forAll() call. As you can see, forAll() actually requires some information on how to generate the values for the parameter types. Some of the often used types have default generators defined in cppproptest . Arbitraries - The Default Generators \u00b6 What makes defaults so special \u00b6 An Arbitrary<T> or its alias Arbi<T> is a generator type (that also coerces to GenFunction<T> ). Arbitraries are specially treated in cppproptest . An arbitrary serves as globally defined default generator for the type. If a default generator for a type is available, cppproptest can use the default generator to generate a value of that type, if no generator has been specified. forAll ([]( T1 t1 , T2 t2 , ..., TN tn ) { // property function body }, /* custom generators for T1, ..., TN */ ); For each of the parameter types of a property function, forAll() requires either a custom generator is provided as an argument, or a conforming Arbitrary<T> class has been defined in proptest namespace. A custom generator can be supplied in the forAll() function arguments next to the property function, as in the same order of parameters of the property function. If it hasn't been supplied, forAll() looks up the default generator - the arbitrary - and uses it instead. If there were no proptest::Arbitrary<T> defined, the compilation would fail. // if there is no default generator available, you must provide a generator for the type SomeNewType. forAll ([]( SomeNewType x ) { }, someNewTypeGen ); // explicit generators should be supplied in same order as parameter types of property function forAll ([]( SomeNewType x , SomeOtherType y ) { }, someNewTypeGen , SomeOtherTypeGen ); // if there is a default generator (Arbitrary<SomeType>) available, you can use that generator by omitting the argument forAll ([]( SomeType x ) { }); // Partially specifying generators is also allowed. Other types will be generated with arbitraries forAll ([]( SomeNewType x , SomeOtherType y ) { }, someNewTypeGen ); // y will be generated with Arbitary<SomeOtherType> Built-in Arbitraries \u00b6 cppproptest provides a set of built-in generators for generation of types that are often used in practice. These built-in generators are in the form of Arbitraries. You can access an arbitrary for T with proptest::Arbitrary<T> . Some of them are defined as template classes with type parameters for universality. For example, Arbitrary<vector<T>> defines a generator for a vector of any given type T , assuming you have an arbitrary for T already defined, or you have provided a custom generator for T as an argument for the vector arbitrary's constructor. Arbitraries of Commonly used standard containers are defined with type parameters so that you can generate such containers for the elemental types you desire. Here's quick reference for built-in arbitraries: Purpose Generator Examples Generate a boolean Arbi<bool>() true or false Generate a character Arbi<char>() 'c' or '%' Generate an integer Arbi<int>() , Arbi<uint64_t>() , ... 12 or -1133 Generate a floating point number Arbi<float>() , Arbi<double>() 3.4 or -1.4e3 Generate a string Arbi<ltt::string>() , Arbi<UTF8String>() \"world\" or \"\u3042\u53f6\u8449\ub9d0\" Generate a pair Arbi<ltt::pair<T1,T2>>() {1, \"xv\"} or {true, 3.4} Generate a tuple Arbi<ltt::tuple<Ts...>>() {1, \"xv\", true} or {true, 3.4} Generate a list Arbi<ltt::list<T>>() {10, -4, 0} or {\"k\", \"&\"} Generate a vector Arbi<ltt::vector<T>>() {10, -4, 0} or {\"k\", \"&\"} Generate a set Arbi<ltt::set<T>>() set {1, 3, 4} but not {1, 1, 3} Generate a map Arbi<ltt::map<K,V>>() map of \"Bob\" -> 25, \"Alice\" -> 30 Boolean type: bool Character type: char Integral types: int8_t , uint8_t , int16_t , uint16_t , int32_t , uint32_t , int64_t , uint64_t Floating point types: float , double String types: ltt::string (defaults to generate ASCII character strings in [0x01, 0x7F] range) UTF8String (a class which extends ltt::string and can be used to generate valid UTF-8 strings by using Arbi<UTF8String> ) CESU8String (similar to UTF-8, but can be used to generate valid CESU-8 strings) UTF16BEString and UTF16LEString for UTF-16 big and little endian strings. CESU-8 and Unicode types produce full unicode code point range of [0x1, 0x10FFFF], excluding forbidden surrogate code points ([0xD800, 0xDFFF]) Shared pointers: ltt::shared_ptr<T> where an Arbi<T> or a custom generator for T is available. It's also useful for generating polymorphic types. struct Action { virtual int get () = 0 ; }; struct Insert : Action { virtual void get () { return 1 ; } }; struct Delete : Action { virtual void get () { return 2 ; } }; Generator < ltt :: shared_ptr < Action >> (...); // can hold both Insert and Delete Standard containers: ltt::string , ltt::vector , ltt::list , ltt::set , ltt::pair , ltt::tuple , ltt::map Arbitraries for containers can optionally take a custom generator for their elemental types. If no custom generator for elemental type T is provided, Arbitrary<T> will be used instead. // You can supply a specific generator for integers auto vecInt0to100 = Arbi < ltt :: vector < int >> ( interval < int > ( 0 , 100 )); // otherwise, Arbi<int> is used auto vecInt = Arbi < ltt :: vector < int >> (); // string aarbitraries also take optional element generator auto uppercaseGen = Arbi < ltt :: string > ( interval ( 'A' , 'Z' )); auto alphabetGen = Arbi < ltt :: string > ( unionOf ( interval ( 'A' , 'Z' ), interval ( 'a' , 'z' ))); Arbi<ltt::Map> provides setter methods for assigning a key generator and a value generator. auto mapGen = Arbi < ltt :: map < int , int >> (); mapGen . setKeyGen ( interval < int > ( 0 , 100 )); // interval: key ranges from 0 to 100 mapGen . setElemGen ( interval < int > ( -100 , 100 )); // interval: value ranges from -100 to 100 Containers provide methods for configuring the desired sizes setMinSize(size) , setMaxSize(size) for restricting the container to specific range of sizes setSize(size) for restricting the container to a specific size auto vecInt = Arbi < ltt :: vector < int >> (); vecInt . setSize ( 10 ); // 1) generated vector will always have size 10 vecInt . setMinSize ( 1 ); // 2) generated vector will have size >= 1 vecInt . setMaxSize ( 10 ); // generated vector will have size <= 10 vecInt . setSize ( 1 , 10 ); // 3) generated vector will have size >= 1 and size <= 10 As long as a generator for type T is available (either by Arbitary<T> defined or a custom generator provided), you can generate a container of that type, however complex the type T is, even including a container type. This means you can readily generate a random vector<vector<int>> , as Arbitrary<vector<T>> and Arbitrary<int> is readily available. Arbi < ltt :: vector < ltt :: vector < int >>> (); // generates a vector of vector of ints. Arbi < ltt :: map < ltt :: string , ltt :: vector < ltt :: set < int >>>> (); This design makes arbitraries of cppproptest composable, meaning that they can be easily reusable as building blocks for a new generator. Defining an Arbitrary \u00b6 With template specialization, new proptest::Arbi<T> (or its alias proptest::Arbitrary<T> ) for type T can be defined, if it hasn't been already defined yet. By defining an Arbitrary , you are effectively adding a default generator for a type. Following shows an example of defining an Arbitrary . Note that it should be defined under proptest namespace in order to be recognized and accessible by the library. namespace proptest { // you should define your Arbi<T> inside this namespace // define a template specialization of Arbi for Car type // by extending ArbiBase, you are decorating your arbitrary with standard methods (map, flatMap, filter, etc.) template <> struct Arbi < Car > : ArbiBase < Car > { Shrinkable < Car > operator ()( Random & rand ) { bool isAutomatic = rand . getRandomBool (); return make_shrinkable < Car > ( isAutomatic ); // make_shrinkable creates a Car object by calling Car's constructor with 1 boolean parameter } }; } Although you can define an arbitrary as shown in this example, it's only required to do so if you desire to have a default generator for the type. Utility methods of Arbitrary \u00b6 Arbitrary<T> provides useful helpers for creating new generators from existing ones 1 . filter is such a helper. It restrictively generates values that satisfy a criteria function. Following shows an even number generator from the integer Arbitrary . // generates any integers auto anyIntGen = Arbi < int > (); // generates even integers auto evenGen = anyIntGen . filter ([]( int & num ) { return num % 2 == 0 ; }); You can find the full list of such helpers in Utility methods in standard generators . Building Custom Generators \u00b6 You can build your own generator for type T by manually defining the conforming generator type GenFunction<T> . You can refer to Building Custom Generators from Scratch for more information. While you can build a custom generator from scratch, it's usually not recommended as there is a better option - using a generator combinator . Generator combinators are toolkit for building new generators based on existing ones. They can also be chained to create another generator out of themselves. See Combinators page for the detail. In fact, Arbitrary<T> inherits from Generator<T> , which provides those helpers. \u21a9","title":"Generating Inputs"},{"location":"Generators/#generating-inputs","text":"","title":"Generating Inputs"},{"location":"Generators/#generators-in-property-based-testing","text":"Property-based testing promotes the concept of input domain of a property. In property-based testing, generators are the means for representing input domains. A generator is basically a function that generates random values. It defines the constraints of the generated random values in its body. Even a simple forAll() call depends on generators under the hood. Let's see following example: forAll ([]( int age , ltt :: string name ) { }); This forAll() call takes a function with parameters of types int and ltt::string . This function is the property function . If no additional specification is given on how to generate the values for age and name as in this example, the parameter types are identified to invoke the default generators for those types. In this case, it calls the default generators for int and ltt::string types. Those default generators are called the arbitraries . You can access the arbitraries of a type T with Arbitrary<T> or Arbi<T> . This code is actually equivalent to: forAll ([]( int age , ltt :: string name ) { }, Arbitrary < int > (), Arbitrary < ltt :: string > ()); Notice the extra arguments Arbitrary<int>() and Arbitrary<ltt::string>() in the forAll() call. As you can see, forAll() actually requires some information on how to generate the values for the parameter types. Some of the often used types have default generators defined in cppproptest .","title":"Generators in Property-Based Testing"},{"location":"Generators/#arbitraries-the-default-generators","text":"","title":"Arbitraries - The Default Generators"},{"location":"Generators/#what-makes-defaults-so-special","text":"An Arbitrary<T> or its alias Arbi<T> is a generator type (that also coerces to GenFunction<T> ). Arbitraries are specially treated in cppproptest . An arbitrary serves as globally defined default generator for the type. If a default generator for a type is available, cppproptest can use the default generator to generate a value of that type, if no generator has been specified. forAll ([]( T1 t1 , T2 t2 , ..., TN tn ) { // property function body }, /* custom generators for T1, ..., TN */ ); For each of the parameter types of a property function, forAll() requires either a custom generator is provided as an argument, or a conforming Arbitrary<T> class has been defined in proptest namespace. A custom generator can be supplied in the forAll() function arguments next to the property function, as in the same order of parameters of the property function. If it hasn't been supplied, forAll() looks up the default generator - the arbitrary - and uses it instead. If there were no proptest::Arbitrary<T> defined, the compilation would fail. // if there is no default generator available, you must provide a generator for the type SomeNewType. forAll ([]( SomeNewType x ) { }, someNewTypeGen ); // explicit generators should be supplied in same order as parameter types of property function forAll ([]( SomeNewType x , SomeOtherType y ) { }, someNewTypeGen , SomeOtherTypeGen ); // if there is a default generator (Arbitrary<SomeType>) available, you can use that generator by omitting the argument forAll ([]( SomeType x ) { }); // Partially specifying generators is also allowed. Other types will be generated with arbitraries forAll ([]( SomeNewType x , SomeOtherType y ) { }, someNewTypeGen ); // y will be generated with Arbitary<SomeOtherType>","title":"What makes defaults so special"},{"location":"Generators/#built-in-arbitraries","text":"cppproptest provides a set of built-in generators for generation of types that are often used in practice. These built-in generators are in the form of Arbitraries. You can access an arbitrary for T with proptest::Arbitrary<T> . Some of them are defined as template classes with type parameters for universality. For example, Arbitrary<vector<T>> defines a generator for a vector of any given type T , assuming you have an arbitrary for T already defined, or you have provided a custom generator for T as an argument for the vector arbitrary's constructor. Arbitraries of Commonly used standard containers are defined with type parameters so that you can generate such containers for the elemental types you desire. Here's quick reference for built-in arbitraries: Purpose Generator Examples Generate a boolean Arbi<bool>() true or false Generate a character Arbi<char>() 'c' or '%' Generate an integer Arbi<int>() , Arbi<uint64_t>() , ... 12 or -1133 Generate a floating point number Arbi<float>() , Arbi<double>() 3.4 or -1.4e3 Generate a string Arbi<ltt::string>() , Arbi<UTF8String>() \"world\" or \"\u3042\u53f6\u8449\ub9d0\" Generate a pair Arbi<ltt::pair<T1,T2>>() {1, \"xv\"} or {true, 3.4} Generate a tuple Arbi<ltt::tuple<Ts...>>() {1, \"xv\", true} or {true, 3.4} Generate a list Arbi<ltt::list<T>>() {10, -4, 0} or {\"k\", \"&\"} Generate a vector Arbi<ltt::vector<T>>() {10, -4, 0} or {\"k\", \"&\"} Generate a set Arbi<ltt::set<T>>() set {1, 3, 4} but not {1, 1, 3} Generate a map Arbi<ltt::map<K,V>>() map of \"Bob\" -> 25, \"Alice\" -> 30 Boolean type: bool Character type: char Integral types: int8_t , uint8_t , int16_t , uint16_t , int32_t , uint32_t , int64_t , uint64_t Floating point types: float , double String types: ltt::string (defaults to generate ASCII character strings in [0x01, 0x7F] range) UTF8String (a class which extends ltt::string and can be used to generate valid UTF-8 strings by using Arbi<UTF8String> ) CESU8String (similar to UTF-8, but can be used to generate valid CESU-8 strings) UTF16BEString and UTF16LEString for UTF-16 big and little endian strings. CESU-8 and Unicode types produce full unicode code point range of [0x1, 0x10FFFF], excluding forbidden surrogate code points ([0xD800, 0xDFFF]) Shared pointers: ltt::shared_ptr<T> where an Arbi<T> or a custom generator for T is available. It's also useful for generating polymorphic types. struct Action { virtual int get () = 0 ; }; struct Insert : Action { virtual void get () { return 1 ; } }; struct Delete : Action { virtual void get () { return 2 ; } }; Generator < ltt :: shared_ptr < Action >> (...); // can hold both Insert and Delete Standard containers: ltt::string , ltt::vector , ltt::list , ltt::set , ltt::pair , ltt::tuple , ltt::map Arbitraries for containers can optionally take a custom generator for their elemental types. If no custom generator for elemental type T is provided, Arbitrary<T> will be used instead. // You can supply a specific generator for integers auto vecInt0to100 = Arbi < ltt :: vector < int >> ( interval < int > ( 0 , 100 )); // otherwise, Arbi<int> is used auto vecInt = Arbi < ltt :: vector < int >> (); // string aarbitraries also take optional element generator auto uppercaseGen = Arbi < ltt :: string > ( interval ( 'A' , 'Z' )); auto alphabetGen = Arbi < ltt :: string > ( unionOf ( interval ( 'A' , 'Z' ), interval ( 'a' , 'z' ))); Arbi<ltt::Map> provides setter methods for assigning a key generator and a value generator. auto mapGen = Arbi < ltt :: map < int , int >> (); mapGen . setKeyGen ( interval < int > ( 0 , 100 )); // interval: key ranges from 0 to 100 mapGen . setElemGen ( interval < int > ( -100 , 100 )); // interval: value ranges from -100 to 100 Containers provide methods for configuring the desired sizes setMinSize(size) , setMaxSize(size) for restricting the container to specific range of sizes setSize(size) for restricting the container to a specific size auto vecInt = Arbi < ltt :: vector < int >> (); vecInt . setSize ( 10 ); // 1) generated vector will always have size 10 vecInt . setMinSize ( 1 ); // 2) generated vector will have size >= 1 vecInt . setMaxSize ( 10 ); // generated vector will have size <= 10 vecInt . setSize ( 1 , 10 ); // 3) generated vector will have size >= 1 and size <= 10 As long as a generator for type T is available (either by Arbitary<T> defined or a custom generator provided), you can generate a container of that type, however complex the type T is, even including a container type. This means you can readily generate a random vector<vector<int>> , as Arbitrary<vector<T>> and Arbitrary<int> is readily available. Arbi < ltt :: vector < ltt :: vector < int >>> (); // generates a vector of vector of ints. Arbi < ltt :: map < ltt :: string , ltt :: vector < ltt :: set < int >>>> (); This design makes arbitraries of cppproptest composable, meaning that they can be easily reusable as building blocks for a new generator.","title":"Built-in Arbitraries"},{"location":"Generators/#defining-an-arbitrary","text":"With template specialization, new proptest::Arbi<T> (or its alias proptest::Arbitrary<T> ) for type T can be defined, if it hasn't been already defined yet. By defining an Arbitrary , you are effectively adding a default generator for a type. Following shows an example of defining an Arbitrary . Note that it should be defined under proptest namespace in order to be recognized and accessible by the library. namespace proptest { // you should define your Arbi<T> inside this namespace // define a template specialization of Arbi for Car type // by extending ArbiBase, you are decorating your arbitrary with standard methods (map, flatMap, filter, etc.) template <> struct Arbi < Car > : ArbiBase < Car > { Shrinkable < Car > operator ()( Random & rand ) { bool isAutomatic = rand . getRandomBool (); return make_shrinkable < Car > ( isAutomatic ); // make_shrinkable creates a Car object by calling Car's constructor with 1 boolean parameter } }; } Although you can define an arbitrary as shown in this example, it's only required to do so if you desire to have a default generator for the type.","title":"Defining an Arbitrary"},{"location":"Generators/#utility-methods-of-arbitrary","text":"Arbitrary<T> provides useful helpers for creating new generators from existing ones 1 . filter is such a helper. It restrictively generates values that satisfy a criteria function. Following shows an even number generator from the integer Arbitrary . // generates any integers auto anyIntGen = Arbi < int > (); // generates even integers auto evenGen = anyIntGen . filter ([]( int & num ) { return num % 2 == 0 ; }); You can find the full list of such helpers in Utility methods in standard generators .","title":"Utility methods of Arbitrary"},{"location":"Generators/#building-custom-generators","text":"You can build your own generator for type T by manually defining the conforming generator type GenFunction<T> . You can refer to Building Custom Generators from Scratch for more information. While you can build a custom generator from scratch, it's usually not recommended as there is a better option - using a generator combinator . Generator combinators are toolkit for building new generators based on existing ones. They can also be chained to create another generator out of themselves. See Combinators page for the detail. In fact, Arbitrary<T> inherits from Generator<T> , which provides those helpers. \u21a9","title":"Building Custom Generators"},{"location":"GettingStarted/","text":"Getting Started with cppproptest \u00b6 You can add the shared library proptest to TARGET_LINK_LIBRARIES section. TARGET_LINK_LIBRARIES( ... ... proptest ... ) Here's an example using Googletest : // ... #include \"proptest/proptest.hpp\" using namespace proptest ; TEST ( AudioCodec , EncoderDecoder ) { // ASSERT_FOR_ALL() is shorthand for ASSERT_TRUE(forAll(...)) ASSERT_FOR_ALL ([]( SoundData soundData ) { auto encoded = MyAudioCodec :: encode ( soundData ); auto decoded = MyAudioCodec :: decode ( encoded ); PROP_ASSERT_EQ ( decoded , soundData ); }); } Note that ASSERT_FOR_ALL is a simple macro wrapping an ASSERT_TRUE google test macro around the proptest::forAll function. You can find more information in Using Assertion section. You can continue to Writing Property-based Tests","title":"Getting Started"},{"location":"GettingStarted/#getting-started-with-cppproptest","text":"You can add the shared library proptest to TARGET_LINK_LIBRARIES section. TARGET_LINK_LIBRARIES( ... ... proptest ... ) Here's an example using Googletest : // ... #include \"proptest/proptest.hpp\" using namespace proptest ; TEST ( AudioCodec , EncoderDecoder ) { // ASSERT_FOR_ALL() is shorthand for ASSERT_TRUE(forAll(...)) ASSERT_FOR_ALL ([]( SoundData soundData ) { auto encoded = MyAudioCodec :: encode ( soundData ); auto decoded = MyAudioCodec :: decode ( encoded ); PROP_ASSERT_EQ ( decoded , soundData ); }); } Note that ASSERT_FOR_ALL is a simple macro wrapping an ASSERT_TRUE google test macro around the proptest::forAll function. You can find more information in Using Assertion section. You can continue to Writing Property-based Tests","title":"Getting Started with cppproptest"},{"location":"Mocking/","text":"Generating Mocks \u00b6 TODO \u00b6","title":"Mocking"},{"location":"Mocking/#generating-mocks","text":"","title":"Generating Mocks"},{"location":"Mocking/#todo","text":"","title":"TODO"},{"location":"Printing/","text":"Printing Facilities \u00b6 It's sometimes recommended to have a printer defined for a type. It would ensure values of a type to be correctly printed. cppproptest fully defines printers for built-in types. // a ltt::tuple<ltt::tuple<int, ltt::tuple<int>>> type is printed: shrinking found simpler failing arg 0 : { { -10 , { -1002144 } } } For a new type you'd like to use with cppproptest , you can define a printer for that type. As you can see in above example, complex recursive structures such as tuple of tuples can be printed if you have correctly defined it. If there is no printer is defined for a type yet, '???' would be printed instead, as there is no correct way known to cppproptest how to printing that type . // Car type that does not yet have a printing method, so it's printed as '???': shrinking found simpler failing arg 0 : ??? Defining a printer for a type \u00b6 Defining a printer for type T can be achieved by defining the struct specialization proptest::util::ShowDefault<T> : namespace proptest { namespace util { // printer for Car class template <> struct ShowDefault < Car > { static ltt :: ostream & show ( ltt :: ostream & os , const Car & car ) { os << \"Car(\" << car . name << \", \" << car . year << \")\" ; return os ; } }; } // namespace util } // namespace proptest This will be called whenever T is being printed by cppproptest : // Car type now has a printer defined shrinking found simpler failing arg 0 : Car ( Ferari , 2020 ) Defining a printer for a templated type \u00b6 You can also define a printer for a templated type as following: namespace proptest { namespace util { // printer for CarLike<T> template < typename T > struct ShowDefault < CarLike < T >> { static ltt :: ostream & show ( ltt :: ostream & os , const CarLike < T >& ) { os << \"CarLike()\" ; return os ; } }; } // namespace util } // namespace proptest This will print a CarLike as: shrinking found simpler failing arg 0 : CarLike () Utilizing other printers \u00b6 If your printer fneeds to print another type T , you can use an already defined (either built-in or custom one) printer for T by calling proptest::util::Show<T>(T&) , as following: namespace proptest { namespace util { template < typename T > struct ShowDefault < CarLike < T >> { static ltt :: ostream & show ( ltt :: ostream & os , const CarLike < T >& carLike ) { // utilize printer for type T ('CarLike(???)' will be printed if there is no printer defined for T) os << \"CarLike(\" << Show < T > ( carLike . t ) << \")\" ; return os ; } }; } // namespace util } // namespace proptest Now it will correctly prints a CarLike<Car> : shrinking found simpler failing arg 0 : CarLike ( Car ( Ferari , 2020 ))","title":"Printing Facilities"},{"location":"Printing/#printing-facilities","text":"It's sometimes recommended to have a printer defined for a type. It would ensure values of a type to be correctly printed. cppproptest fully defines printers for built-in types. // a ltt::tuple<ltt::tuple<int, ltt::tuple<int>>> type is printed: shrinking found simpler failing arg 0 : { { -10 , { -1002144 } } } For a new type you'd like to use with cppproptest , you can define a printer for that type. As you can see in above example, complex recursive structures such as tuple of tuples can be printed if you have correctly defined it. If there is no printer is defined for a type yet, '???' would be printed instead, as there is no correct way known to cppproptest how to printing that type . // Car type that does not yet have a printing method, so it's printed as '???': shrinking found simpler failing arg 0 : ???","title":"Printing Facilities"},{"location":"Printing/#defining-a-printer-for-a-type","text":"Defining a printer for type T can be achieved by defining the struct specialization proptest::util::ShowDefault<T> : namespace proptest { namespace util { // printer for Car class template <> struct ShowDefault < Car > { static ltt :: ostream & show ( ltt :: ostream & os , const Car & car ) { os << \"Car(\" << car . name << \", \" << car . year << \")\" ; return os ; } }; } // namespace util } // namespace proptest This will be called whenever T is being printed by cppproptest : // Car type now has a printer defined shrinking found simpler failing arg 0 : Car ( Ferari , 2020 )","title":"Defining a printer for a type"},{"location":"Printing/#defining-a-printer-for-a-templated-type","text":"You can also define a printer for a templated type as following: namespace proptest { namespace util { // printer for CarLike<T> template < typename T > struct ShowDefault < CarLike < T >> { static ltt :: ostream & show ( ltt :: ostream & os , const CarLike < T >& ) { os << \"CarLike()\" ; return os ; } }; } // namespace util } // namespace proptest This will print a CarLike as: shrinking found simpler failing arg 0 : CarLike ()","title":"Defining a printer for a templated type"},{"location":"Printing/#utilizing-other-printers","text":"If your printer fneeds to print another type T , you can use an already defined (either built-in or custom one) printer for T by calling proptest::util::Show<T>(T&) , as following: namespace proptest { namespace util { template < typename T > struct ShowDefault < CarLike < T >> { static ltt :: ostream & show ( ltt :: ostream & os , const CarLike < T >& carLike ) { // utilize printer for type T ('CarLike(???)' will be printed if there is no printer defined for T) os << \"CarLike(\" << Show < T > ( carLike . t ) << \")\" ; return os ; } }; } // namespace util } // namespace proptest Now it will correctly prints a CarLike<Car> : shrinking found simpler failing arg 0 : CarLike ( Car ( Ferari , 2020 ))","title":"Utilizing other printers"},{"location":"Property/","text":"Writing Property-based Tests \u00b6 What you can do with cppproptest \u00b6 Here's the list of property-based test functions and macros you can use in cppproptest : Property Function and Its Test Methods \u00b6 You can define a property with a criteria function and certain input domain. You can choose to verify the criteria function with randomly generated inputs ( forAll() ) or with manually specified ones ( example() ). You can also exhaustively test all combinations of inputs based on the values you provided ( matrix() ). Name Description Remark proptest::property() Define a property based on a callable .forAll() Run the property with random inputs .matrix() Run the property with Cartesian product of inputs Input list as initializer_list .example() Run the property with specific inputs Shorthands for Property Test Methods \u00b6 You can use convenient shorthands for above methods. Name Description Remark proptest::forAll() Define and run a property immediately Shorthand for proptest::property(callable).forAll() proptest::matrix() Define and run a matrix test immediately Shorthand for proptest::property(callable).matrix() Google Test Assertion Macros \u00b6 You can wrap around a property test with Google Tests' macro so that you make Google Test consider the property test failure as a test failure (otherwise, the property test will only print the failure information to standard output and return false .). Name Description Remark EXPECT_FOR_ALL() Run proptest::forAll with EXPECT_TRUE Google Test macro Shorthand for EXPECT_TRUE(proptest::forAll(...)) ASSERT_FOR_ALL() Run proptest::forAll with ASSERT_TRUE Google Test macro Shorthand for ASSERT_TRUE(proptest::forAll(...)) Defining and running a property test \u00b6 property() defines a property with optional configurations. By calling property() , you are creating a Property object. forAll() is the shorthand for calling Property 's method forAll() . Property::forAll() performs property-based test using supplied callable (function, functor, or lambda). While forAll() would work most of the time, property() in combination with its methods .forAll() , .example() , .matrix() can be more versatile and configurable at times. forAll ([]( int a , int b ) -> bool { return a + b == b + a ; }); is equivalent to: property ([]( int a , int b ) -> bool { return a + b == b + a ; }). forAll (); Defining a Property \u00b6 Defining a property requires a callable. For example, a lambda as following is such a callable with an int as parameter: []( int a ) -> bool { return a >= 0 ; } Arguments are generated automatically by the library and the return value of the function will indicate success( true ) or failure( false ) of the property. Asserts can also be used to mark successes and failures. If you prefer not to use boolean return value to indicate success/fail, you can use void return type and use assertions instead: []( int a ) { PROP_ASSERT_GE ( a , 0 ); } Generators and Arbitraries under the hood \u00b6 In above case, the function is called with an integer argument randomly generated by the test library. The library will repeatedly feed in some random values into the function for given number of runs. Under the hood, the library requires a generator for each of given parameter types. For each parameter, either an Arbi<T> (an arbitrary, the default generator for type T ) should be defined ahead, or a custom generator must be provided. In above example, a predefined generator Arbi<int> is used to generate an integer argument. You can provide a custom generator as additional argument(s) to property() function, as following: property ([]( int a , int b ) -> bool { return true ; }, myIntGenerator ); Any remaining parameter in the property function with no custom generator supplied will be generated using an arbitrary. In above example, int a is generated using myIntGenerator as it was supplied in the arguments, while int b will be generated using Arbi<int> , as no custom generator was supplied. If there is no arbitrary defined for a type and no custom generator is supplied either, a compile error will be emitted, as the library cannot test a property without a generator for the input type. Many primitive types and standard containers have their default generators Arbi<T> defined by the library for convenience. You can find more about generators and see the full list of built-in Arbitraries in Generators page. Testing a Property \u00b6 Once a property has been defined, you can run a simple randomized test based on the defined property with Property::forAll() . auto prop = property ([]( int a , int b ) -> bool { return true ; }, myIntGenerator ); prop . forAll (); It will repeatedly call the lambda with different input combinations of a and b then stops after some designated number of runs or a time duration. If a property fails with an input combination by the lambda returning false or encountering an assertion failure, the test stops there and the library will provide some information on the failed case. If possible the library will simplify the failed case with a process called shrinking . See Shrinking page for more information on this process. Specifying generators with Property::forAll() \u00b6 While you can define a property with or without specifying generators, you can additionally specify or override some of the generators when calling .forAll() , by passing the generators as arguments. // a is fixed to INT_MAX, while b is randomly generated prop . forAll ( just < int > ( INT_MIN )); // specifying generator for both a and b prop . forAll ( just < int > ( INT_MIN ), inRange < int > ( -100 , 100 )); In above example, proptest::just() is a generator combinator that simply keeps generating a single value. proptest::inRange is another example of generator combinator. It generates a numeric value within a given range. Specifying example inputs with Property::example() \u00b6 While having a randomized set of inputs is powerful, you might want to test the property with specific combination of inputs to ensure those combinations are always tested. This can be accomplished using .example(...) . You need to specify all the parameters needed to call the callable: // define a property auto prop = property ([]( int a , int b ) -> bool { return a + b == b + a ; }); // check specific examples prop . example ( INT_MIN , INT_MIN ); prop . example ( INT_MIN , INT_MAX ); prop . example ( INT_MAX , INT_MIN ); prop . example ( INT_MAX , INT_MAX ); Specifying full matrix of inputs with Property::matrix() \u00b6 While .example() provides a way to test certain examples by specifying each one of them, you might want to go even further to test all combinations of concerned inputs (e.g. all defined enum values) by taking a Cartesian product of the input parameters. In above example,taking {INT_MIN, INT_MAX} for a and another {INT_MIN, INT_MAX} for b and multiply them as if it was a matrix multiplication. This will result in four combinations {(INT_MIN, INT_MIN), (INT_MIN, INT_MAX), (INT_MAX, INT_MIN), (INT_MAX, INT_MAX)} . .matrix() lets you do exactly this kind of combination test: // equivalent to above using four `prop.example()` prop . matrix ({ INT_MIN , INT_MAX }, { INT_MIN , INT_MAX }); // arbitrary size of the list can be used prop . matrix ({ INT_MIN , 0 , INT_MAX }, { INT_MIN , 0 , 1 , INT_MAX }); Configuring test runs \u00b6 Setting number of runs \u00b6 You can set the number of runs with Property::setNumRuns(int num) . The default number of runs is 1000 . auto prop = property ([]( int a , int b ) -> bool { // ... }); prop . setNumRuns ( 100 ). forAll (); You can set default number of runs affected globally by calling the static method PropertyBase::setDefaultNumRuns(int num) . Subsequent properties will follow this number of runs unless specified with setNumRuns() . PropertyBase :: setDefaultNumRuns ( 100 ); Setting the random seed \u00b6 A property can be configured a specific random seed. This can be done by calling Property::setSeed(unsigned long seed) . auto prop = property ([]( int a , int b ) -> bool { // ... }); prop . setSeed ( savedSeed ). forAll (); If no random seed is specified, current timestamp in milliseconds is used. You can override these unspecified random seeds globally with an environment variable PROPTEST_SEED . This comes in handy when you have encountered a failure and its random seed value is available for reproduction: # ... failed test with random seed 15665312 $ PROPTEST_SEED = 15665312 ./my_proptest Setting maximum test duration \u00b6 You can set maximum duration for a property test run by calling Property::setMaxDurationMs() . This will limit the time regardless of number of runs. It can be useful if your time resource is limited or if you have some external timeout duration configured. prop . setMaxDurationMs ( 60000 ); // will run the test for maximum of 60 seconds, if number of runs does not run out first. Chaining configurations \u00b6 You can chain the configurations for a property as following, for ease of use: auto prop = property ([]( int a , int b ) -> bool { // ... }); prop . setSeed ( savedSeed ). setNumRuns ( 1000000 ). setMaxDurationMs ( 60000 ). forAll (); Using Assertions \u00b6 cppproptest provides assertion(fatal)/expectation(non-fatal) macros based on the popular Google Test library. // PROP_EXPECT*: non-fatal, continues upon failure PROP_EXPECT ( condition ); PROP_EXPECT_TRUE ( condition ); PROP_EXPECT_FALSE ( condition ); PROP_EXPECT_EQ ( A , B ); PROP_EXPECT_NE ( A , B ); PROP_EXPECT_LT ( A , B ); PROP_EXPECT_GT ( A , B ); PROP_EXPECT_LE ( A , B ); PROP_EXPECT_GE ( A , B ); PROP_EXPECT_STREQ ( A , B , N ); // PROP_ASSERT*: fatal, breaks test upon failure PROP_ASSERT ( condition ); PROP_ASSERT_TRUE ( condition ); PROP_ASSERT_FALSE ( condition ); PROP_ASSERT_EQ ( A , B ); PROP_ASSERT_NE ( A , B ); PROP_ASSERT_LT ( A , B ); PROP_ASSERT_GT ( A , B ); PROP_ASSERT_LE ( A , B ); PROP_ASSERT_GE ( A , B ); PROP_ASSERT_STREQ ( A , B , N ); Also, there are Google Test compatible macros for forAll that fails the gtest test case or suite upon a property test failure (since with a bare forAll , the failures won't behave as gtest failure): EXPECT_FOR_ALL (...); // non-fatal, shorthand for EXPECT_TRUE(proptest::forAll(...)); ASSERT_FOR_ALL (...); // fatal, shorthand for ASSERT_TRUE(proptest::forAll(...));","title":"Writing Property-based Tests"},{"location":"Property/#writing-property-based-tests","text":"","title":"Writing Property-based Tests"},{"location":"Property/#what-you-can-do-with-cppproptest","text":"Here's the list of property-based test functions and macros you can use in cppproptest :","title":"What you can do with cppproptest"},{"location":"Property/#property-function-and-its-test-methods","text":"You can define a property with a criteria function and certain input domain. You can choose to verify the criteria function with randomly generated inputs ( forAll() ) or with manually specified ones ( example() ). You can also exhaustively test all combinations of inputs based on the values you provided ( matrix() ). Name Description Remark proptest::property() Define a property based on a callable .forAll() Run the property with random inputs .matrix() Run the property with Cartesian product of inputs Input list as initializer_list .example() Run the property with specific inputs","title":"Property Function and Its Test Methods"},{"location":"Property/#shorthands-for-property-test-methods","text":"You can use convenient shorthands for above methods. Name Description Remark proptest::forAll() Define and run a property immediately Shorthand for proptest::property(callable).forAll() proptest::matrix() Define and run a matrix test immediately Shorthand for proptest::property(callable).matrix()","title":"Shorthands for Property Test Methods"},{"location":"Property/#google-test-assertion-macros","text":"You can wrap around a property test with Google Tests' macro so that you make Google Test consider the property test failure as a test failure (otherwise, the property test will only print the failure information to standard output and return false .). Name Description Remark EXPECT_FOR_ALL() Run proptest::forAll with EXPECT_TRUE Google Test macro Shorthand for EXPECT_TRUE(proptest::forAll(...)) ASSERT_FOR_ALL() Run proptest::forAll with ASSERT_TRUE Google Test macro Shorthand for ASSERT_TRUE(proptest::forAll(...))","title":"Google Test Assertion Macros"},{"location":"Property/#defining-and-running-a-property-test","text":"property() defines a property with optional configurations. By calling property() , you are creating a Property object. forAll() is the shorthand for calling Property 's method forAll() . Property::forAll() performs property-based test using supplied callable (function, functor, or lambda). While forAll() would work most of the time, property() in combination with its methods .forAll() , .example() , .matrix() can be more versatile and configurable at times. forAll ([]( int a , int b ) -> bool { return a + b == b + a ; }); is equivalent to: property ([]( int a , int b ) -> bool { return a + b == b + a ; }). forAll ();","title":"Defining and running a property test"},{"location":"Property/#defining-a-property","text":"Defining a property requires a callable. For example, a lambda as following is such a callable with an int as parameter: []( int a ) -> bool { return a >= 0 ; } Arguments are generated automatically by the library and the return value of the function will indicate success( true ) or failure( false ) of the property. Asserts can also be used to mark successes and failures. If you prefer not to use boolean return value to indicate success/fail, you can use void return type and use assertions instead: []( int a ) { PROP_ASSERT_GE ( a , 0 ); }","title":"Defining a Property"},{"location":"Property/#generators-and-arbitraries-under-the-hood","text":"In above case, the function is called with an integer argument randomly generated by the test library. The library will repeatedly feed in some random values into the function for given number of runs. Under the hood, the library requires a generator for each of given parameter types. For each parameter, either an Arbi<T> (an arbitrary, the default generator for type T ) should be defined ahead, or a custom generator must be provided. In above example, a predefined generator Arbi<int> is used to generate an integer argument. You can provide a custom generator as additional argument(s) to property() function, as following: property ([]( int a , int b ) -> bool { return true ; }, myIntGenerator ); Any remaining parameter in the property function with no custom generator supplied will be generated using an arbitrary. In above example, int a is generated using myIntGenerator as it was supplied in the arguments, while int b will be generated using Arbi<int> , as no custom generator was supplied. If there is no arbitrary defined for a type and no custom generator is supplied either, a compile error will be emitted, as the library cannot test a property without a generator for the input type. Many primitive types and standard containers have their default generators Arbi<T> defined by the library for convenience. You can find more about generators and see the full list of built-in Arbitraries in Generators page.","title":"Generators and Arbitraries under the hood"},{"location":"Property/#testing-a-property","text":"Once a property has been defined, you can run a simple randomized test based on the defined property with Property::forAll() . auto prop = property ([]( int a , int b ) -> bool { return true ; }, myIntGenerator ); prop . forAll (); It will repeatedly call the lambda with different input combinations of a and b then stops after some designated number of runs or a time duration. If a property fails with an input combination by the lambda returning false or encountering an assertion failure, the test stops there and the library will provide some information on the failed case. If possible the library will simplify the failed case with a process called shrinking . See Shrinking page for more information on this process.","title":"Testing a Property"},{"location":"Property/#specifying-generators-with-propertyforall","text":"While you can define a property with or without specifying generators, you can additionally specify or override some of the generators when calling .forAll() , by passing the generators as arguments. // a is fixed to INT_MAX, while b is randomly generated prop . forAll ( just < int > ( INT_MIN )); // specifying generator for both a and b prop . forAll ( just < int > ( INT_MIN ), inRange < int > ( -100 , 100 )); In above example, proptest::just() is a generator combinator that simply keeps generating a single value. proptest::inRange is another example of generator combinator. It generates a numeric value within a given range.","title":"Specifying generators with Property::forAll()"},{"location":"Property/#specifying-example-inputs-with-propertyexample","text":"While having a randomized set of inputs is powerful, you might want to test the property with specific combination of inputs to ensure those combinations are always tested. This can be accomplished using .example(...) . You need to specify all the parameters needed to call the callable: // define a property auto prop = property ([]( int a , int b ) -> bool { return a + b == b + a ; }); // check specific examples prop . example ( INT_MIN , INT_MIN ); prop . example ( INT_MIN , INT_MAX ); prop . example ( INT_MAX , INT_MIN ); prop . example ( INT_MAX , INT_MAX );","title":"Specifying example inputs with Property::example()"},{"location":"Property/#specifying-full-matrix-of-inputs-with-propertymatrix","text":"While .example() provides a way to test certain examples by specifying each one of them, you might want to go even further to test all combinations of concerned inputs (e.g. all defined enum values) by taking a Cartesian product of the input parameters. In above example,taking {INT_MIN, INT_MAX} for a and another {INT_MIN, INT_MAX} for b and multiply them as if it was a matrix multiplication. This will result in four combinations {(INT_MIN, INT_MIN), (INT_MIN, INT_MAX), (INT_MAX, INT_MIN), (INT_MAX, INT_MAX)} . .matrix() lets you do exactly this kind of combination test: // equivalent to above using four `prop.example()` prop . matrix ({ INT_MIN , INT_MAX }, { INT_MIN , INT_MAX }); // arbitrary size of the list can be used prop . matrix ({ INT_MIN , 0 , INT_MAX }, { INT_MIN , 0 , 1 , INT_MAX });","title":"Specifying full matrix of inputs with Property::matrix()"},{"location":"Property/#configuring-test-runs","text":"","title":"Configuring test runs"},{"location":"Property/#setting-number-of-runs","text":"You can set the number of runs with Property::setNumRuns(int num) . The default number of runs is 1000 . auto prop = property ([]( int a , int b ) -> bool { // ... }); prop . setNumRuns ( 100 ). forAll (); You can set default number of runs affected globally by calling the static method PropertyBase::setDefaultNumRuns(int num) . Subsequent properties will follow this number of runs unless specified with setNumRuns() . PropertyBase :: setDefaultNumRuns ( 100 );","title":"Setting number of runs"},{"location":"Property/#setting-the-random-seed","text":"A property can be configured a specific random seed. This can be done by calling Property::setSeed(unsigned long seed) . auto prop = property ([]( int a , int b ) -> bool { // ... }); prop . setSeed ( savedSeed ). forAll (); If no random seed is specified, current timestamp in milliseconds is used. You can override these unspecified random seeds globally with an environment variable PROPTEST_SEED . This comes in handy when you have encountered a failure and its random seed value is available for reproduction: # ... failed test with random seed 15665312 $ PROPTEST_SEED = 15665312 ./my_proptest","title":"Setting the random seed"},{"location":"Property/#setting-maximum-test-duration","text":"You can set maximum duration for a property test run by calling Property::setMaxDurationMs() . This will limit the time regardless of number of runs. It can be useful if your time resource is limited or if you have some external timeout duration configured. prop . setMaxDurationMs ( 60000 ); // will run the test for maximum of 60 seconds, if number of runs does not run out first.","title":"Setting maximum test duration"},{"location":"Property/#chaining-configurations","text":"You can chain the configurations for a property as following, for ease of use: auto prop = property ([]( int a , int b ) -> bool { // ... }); prop . setSeed ( savedSeed ). setNumRuns ( 1000000 ). setMaxDurationMs ( 60000 ). forAll ();","title":"Chaining configurations"},{"location":"Property/#using-assertions","text":"cppproptest provides assertion(fatal)/expectation(non-fatal) macros based on the popular Google Test library. // PROP_EXPECT*: non-fatal, continues upon failure PROP_EXPECT ( condition ); PROP_EXPECT_TRUE ( condition ); PROP_EXPECT_FALSE ( condition ); PROP_EXPECT_EQ ( A , B ); PROP_EXPECT_NE ( A , B ); PROP_EXPECT_LT ( A , B ); PROP_EXPECT_GT ( A , B ); PROP_EXPECT_LE ( A , B ); PROP_EXPECT_GE ( A , B ); PROP_EXPECT_STREQ ( A , B , N ); // PROP_ASSERT*: fatal, breaks test upon failure PROP_ASSERT ( condition ); PROP_ASSERT_TRUE ( condition ); PROP_ASSERT_FALSE ( condition ); PROP_ASSERT_EQ ( A , B ); PROP_ASSERT_NE ( A , B ); PROP_ASSERT_LT ( A , B ); PROP_ASSERT_GT ( A , B ); PROP_ASSERT_LE ( A , B ); PROP_ASSERT_GE ( A , B ); PROP_ASSERT_STREQ ( A , B , N ); Also, there are Google Test compatible macros for forAll that fails the gtest test case or suite upon a property test failure (since with a bare forAll , the failures won't behave as gtest failure): EXPECT_FOR_ALL (...); // non-fatal, shorthand for EXPECT_TRUE(proptest::forAll(...)); ASSERT_FOR_ALL (...); // fatal, shorthand for ASSERT_TRUE(proptest::forAll(...));","title":"Using Assertions"},{"location":"Shrinking/","text":"Simplifying Failed Inputs \u00b6 Shrinking is powerful notion widely utilized in most property-based testing libraries. It automates some of typical debugging process and greatly reduces the effort required to analyse a test failure. cppproptest fully supports shrinking for all built-in generators and combinators. Counterexample and Shrinking \u00b6 Compared to generators , shrinking is a relatively optional feature of property-based testing. But it plays very important role in terms of usability and debugging. Here is an example: forAll ([]( int a , double b , bool c ) -> bool { PROP_ASSERT (...); }); When a property fails during a property-based test, a counterexample is found. Falsifiable after 12 tests, where a = -13680124, b = 7524.68454e-14, c = true Here, a , b , and c 's tuple (-13680124, 7524.68454e-14, true) is a counterexample that disproves a property. You can reproduce the property failure with this input combination so that you can further reason about its root cause. You would immediately want to know which combination of the arguments a , b , and c is responsible for the failure. In some cases, a boolean flag such as c in this example could have triggered the failure. If c is the only responsible for the failure, we can pull other arguments a and b out of the equation and keep them as simple as possible. Finding such relationship of arguments is what we would typically do to indentify the root cause of the failure. Shrinking exactly automates this process. When a failure is encountered, forAll shrinks the failing input combination. In other words, it tries to find another input combination that still fails the property, but with simpler representation. If an integer is big, it tries with a smaller number. If a boolean is true , then tries with false . If a vector has many elements, it tries with removing some of the elements, and so on. If possible, it will come up with much more meaningful set of arguments that led to the failure. In this specific example, a , b , and c tuple can be shrunk from the complicated (-13680124, 7524.68454e-14, true) to much simpler (0, 0, true) , because a and b has no role in the failure. In short, Shrinking is the process of finding another failing combination of arguments with simpler representation. Although There is no universal definition of simple or simpler , we can agree on some basic ideas: Booleans: false (turning a flag off) is simpler than true (turning on) Numerics: remove sign or take a smaller absolute value/exponent (e.g. -34 -> 34 , 16384 -> 1024 , 12e55 -> 12e20 ) round some of the digits (e.g. -29.5134 -> -29 ) Strings: drop some of characters in the back (e.g. \"Hello world!\" -> \"Hello\" ) Containers: remove some of the elements (in the back) [0,1,2,3,4,5] -> [0,1,2] Shrinking also shines during the early stage of writing a test. It can quickly summarize a test failure so that we can easily identify whether it was the component that had a bug or the test itself that was badly designed.","title":"Simplifying Failed Inputs"},{"location":"Shrinking/#simplifying-failed-inputs","text":"Shrinking is powerful notion widely utilized in most property-based testing libraries. It automates some of typical debugging process and greatly reduces the effort required to analyse a test failure. cppproptest fully supports shrinking for all built-in generators and combinators.","title":"Simplifying Failed Inputs"},{"location":"Shrinking/#counterexample-and-shrinking","text":"Compared to generators , shrinking is a relatively optional feature of property-based testing. But it plays very important role in terms of usability and debugging. Here is an example: forAll ([]( int a , double b , bool c ) -> bool { PROP_ASSERT (...); }); When a property fails during a property-based test, a counterexample is found. Falsifiable after 12 tests, where a = -13680124, b = 7524.68454e-14, c = true Here, a , b , and c 's tuple (-13680124, 7524.68454e-14, true) is a counterexample that disproves a property. You can reproduce the property failure with this input combination so that you can further reason about its root cause. You would immediately want to know which combination of the arguments a , b , and c is responsible for the failure. In some cases, a boolean flag such as c in this example could have triggered the failure. If c is the only responsible for the failure, we can pull other arguments a and b out of the equation and keep them as simple as possible. Finding such relationship of arguments is what we would typically do to indentify the root cause of the failure. Shrinking exactly automates this process. When a failure is encountered, forAll shrinks the failing input combination. In other words, it tries to find another input combination that still fails the property, but with simpler representation. If an integer is big, it tries with a smaller number. If a boolean is true , then tries with false . If a vector has many elements, it tries with removing some of the elements, and so on. If possible, it will come up with much more meaningful set of arguments that led to the failure. In this specific example, a , b , and c tuple can be shrunk from the complicated (-13680124, 7524.68454e-14, true) to much simpler (0, 0, true) , because a and b has no role in the failure. In short, Shrinking is the process of finding another failing combination of arguments with simpler representation. Although There is no universal definition of simple or simpler , we can agree on some basic ideas: Booleans: false (turning a flag off) is simpler than true (turning on) Numerics: remove sign or take a smaller absolute value/exponent (e.g. -34 -> 34 , 16384 -> 1024 , 12e55 -> 12e20 ) round some of the digits (e.g. -29.5134 -> -29 ) Strings: drop some of characters in the back (e.g. \"Hello world!\" -> \"Hello\" ) Containers: remove some of the elements (in the back) [0,1,2,3,4,5] -> [0,1,2] Shrinking also shines during the early stage of writing a test. It can quickly summarize a test failure so that we can easily identify whether it was the component that had a bug or the test itself that was badly designed.","title":"Counterexample and Shrinking"},{"location":"StatefulTesting/","text":"Stateful Testing \u00b6 While property-based testing suits well with functions and stateless objects, it's also useful in testing for various state changes with ease. Typical properties we can test with stateful tests are as following: Test for consistency of internal state Test for memory leaks Test for concurrent accesses (see Concurrency Testing for more) The key idea of stateful testing with cppproptest is to generate state changes . Define action generators: Define action s that each represents unit of state change - e.g. For a numeric object, calling .multiply(int multiplier) method with a numeric multiplier as an argument, calling .divide(int divisor) method, etc. Build an action list generator: we then need a generator for the action types that can build a list of actions and pass required arguments to the selected actions Run the stateful test Say, you are to write stateful test for your MyVector , which is a linear container for integers. class MyVector { void push_back ( int val ); int pop_back (); int size (); int & at ( int pos ); void clear (); }; You first need to define actions for each state change. Using Action Functions \u00b6 An Action or a SimpleAction is formally defined as a functor object of the form: Action<ObjectType,ModelType> : ( ObjectType & , ModelType & ) -> void SimpleAction<ObjectType> : ( ObjectType & ) -> void ObjectType refers to the type of the stateful object of our concern. ModelType indicates an optional object type with which we'd like to check our stateful object. This additional object is called a model . For example, you can mark number of elements in a model to track the inserted or removed elements in a container object. Or you could closely compare your object with an already validated implementation that works similar to yours. Option 1: SimpleAction - Working without a model \u00b6 ( ObjectType & ) -> void You can use SimpleAction and its variant if you do not intend to use a model object. Let's discuss this simper variant first. The function takes an ObjectType reference. You will typically be defining a SimpleAction with a lambda. Our first goal is to create a generator for our action. A generator for an action with no arguments such as pop_back() can be defined as: #include \"statefultest.hpp\" // ... auto popBackGen = just ( SimpleAction < MyVector > ([]( MyVector & obj ) { obj . pop_back (); })); Notice the usage of just generator combinator which will always generate the same action. Compare with following push_back() 's action generator that requires an integer argument: auto pushBackGen = Arbi < int > (). map < SimpleAction < MyVector >> ([]( int value ) { return SimpleAction < MyVector > ([ value ]( MyVector & obj ) { obj . push_back ( value ); }); }); Here you can see an integer generator is transformed as an action generator. The outer lambda returns an action that calls push_back() with the integer argument value . You can add various assertions in the action. Any failed assertion will be reported and analyzed, as in ordinary property tests. With each action generator defined, we would typically combine these generators as one, using oneOf combinator: auto actionGen = oneOf < SimpleAction < MyAction >> ( pushBackGen , popBackGen , clearGen ); This will generate either of 3 actions, with evenly distributed probability (1/3). Finally, we can define a stateful property by calling statefulProperty<ObjectType>() . This method requires an initial state generator, and the actionGen we've just obtained. Calling statefulProperty::go() will execute the stateful property test. // we can generate initial object from an arbitrary, assuming we have an Arbi<MyVector> defined auto prop = statefulProperty < T > ( /* initial state generator */ Arbi < MyVector > (), /* action generator */ actionGen ); prop . go (); // ... // or, we can just initialize the object to an empty object auto prop = statefulProperty < T > ( /* initial state generator */ just < MyVector > ([]() { return MyVector (); }), /* action generator */ actionGen ); prop . go (); Putting it together: \u00b6 class MyVector { void push_back ( int val ) { ... } int pop_back () { ... } int size () { ... } int & at ( int pos ) { ... } void clear () { ... } }; TEST ( MyVectorTest , Stateful ) { auto popBackGen = just ( SimpleAction < MyVector > ([]( MyVector & obj ) { if ( obj . size () == 0 ) return ; int size = obj . size (); obj . pop_back (); PROP_ASSERT ( obj . size () == size - 1 ); })); auto pushBackGen = Arbi < int > (). map < SimpleAction < MyVector >> ([]( int value ) { return [ value ]( MyVector & obj ) { int size = obj . size (); obj . push_back ( value ); PROP_ASSERT ( obj . size () == size + 1 ); }; }); auto clearGen = just ( SimpleAction < MyVector > ([]( MyVector & obj ) { obj . clear (); PROP_ASSERT ( obj . size () == 0 ); })); auto actionGen = oneOf < SimpleAction < MyVector >> ( pushBackGen , popBackGen , weightedGen < SimpleAction < MyVector >> ( clearGen , 0.1 )); // `oneOf` can take weights, so you can adjust rate of generation of an action // auto actionGen = oneOf<SimpleAction<MyVector>>(pushBackGen, popBackGen, weightedGen<SimpleAction<MyVector>>(clearGen, 0.1)); auto prop = statefulProperty < MyVector > ( /* initial state generator */ just < MyVector > ([]() { return MyVector (); }), /* action generator */ actionGen ); // Tests massive cases with randomly generated action sequences prop . go (); } Option 2: Action - Working with a model \u00b6 If you need a model for advanced tracking of state changes, use Action instead of SimpleAction . Action takes additional parameter indicating the model type. Let's define our model for tracking number of elements for MyVector // our simple model that tracks number of elements struct Counter { Counter ( int n ) : num ( n ) {} int num ; }; With this defined, we can continue defining our actions. auto popBackGen = just ( Action < MyVector , Counter > ([]( MyVector & obj , Counter & counter ) { if ( obj . size () == 0 ) return ; obj . pop_back (); counter . num -- ; })); You can use oneOf<Action<ObjectType, ModelType>> to get the combined action generator: auto actionGen = oneOf < Action < MyVector , Counter >> ( pushBackGen , popBackGen , clearGen ); Finally, we can define a stateful property by calling statefulProperty<ObjectType,ModelType>() . This method requires an initial state generator, and the actionGen we've just obtained. Compared to SimpleAction case, it additionally requires a model factory in the form of ObjectType& -> ModelType . This factory is to induce initial model from initial object. Calling statefulProperty::go() will execute the stateful property test. auto prop = statefulProperty < T > ( /* initial state generator */ Arbi < MyVector > (), /* model factory */ []( MyVector & vec ) { return Counter ( vec . size ()); }, /* action generator */ actionGen ); prop . go (); While the model in this example is simple, you may choose to use more complex ones. It's often a clever idea to use an existing, well validated implementation as model. For example, we could use ltt::vector<int> as model and perform the actions on both MyVector and ltt::vector . We assure MyVector works correctly by comparing element-wise with the ltt::vector model object that has undergone the same state changes. Putting it together: \u00b6 class MyVector { void push_back ( int val ) { ... } int pop_back () { ... } int size () { ... } int & at ( int pos ) { ... } void clear () { ... } }; // our simple model that tracks number of elements struct Counter { Counter ( int n ) : num ( n ) {} int num ; }; TEST ( MyVectorTest , Stateful ) { auto popBackGen = just ( Action < MyVector , Counter > ([]( MyVector & obj , Counter & cnt ) { if ( obj . size () == 0 ) return ; obj . pop_back (); cnt . num -- ; PROP_ASSERT ( cnt . num == obj . size ()); })); auto pushBackGen = Arbi < int > (). map < Action < MyVector , Counter >> ([]( int value ) { return [ value ]( MyVector & obj ) { obj . push_back ( value ); cnt . num ++ ; PROP_ASSERT ( cnt . num == obj . size ()); }; }); auto clearGen = just ( Action < MyVector , Counter > ([]( MyVector & obj ) { obj . clear (); cnt . num = 0 ; PROP_ASSERT ( cnt . num == obj . size ()); })); // combine action generators auto actionGen = oneOf < Action < MyVector , Counter >> ( pushBackGen , popBackGen , clearGen ); // oneOf() can take weights, so you can adjust rate of generation of an action // auto actionGen = oneOf<Action<MyVector, Counter>>(pushBackGen, popBackGen, weightedGen<Action<MyVector, Counter>>(clearGen, 0.1)); auto prop = statefulProperty < MyVector , Counter > ( /* initial state generator */ Arbi < MyVector > (), /* initial model factory */ []( MyVector & vec ) { return Counter ( vec . size ()); }, /* action generator */ actionGen ); // Tests massive cases with randomly generated action sequences prop . go (); } Debugging stateful test failures \u00b6 A stateful test is succesful if all tried combinations were complete without issues. On the other hand, a failed assertion or an unexpected exception would end up with a stateful test failure. The framework will print the failed condition and tried input combinations so that you can debug the failure. Among the args , the first arg is the initial state, and the second one is the action list: Falsifiable, after 12 tests: vec.size () == count ( test/test_state_func.cpp:111 ) with args: { [ 1882384569 , -1157159508, ..., 128 , 32768 , 840506558 ] , [ Action<?>, Action<?>, Action<?>, ..., Action<?> ] } Note that, by default, an Action or a SimpleAction has no distinctive description. This is why there are indistinguishable Action<?> s printed in the action list. This can be avoided by prepending a description to each action constructor: // action with no argument auto clearGen = just ( SimpleAction < MyVector >> ( \"Clear\" , []( MyVector & obj ) { // ... })); // action with arguments can be printed nicely with a stringstream auto pushBackGen = Arbi < int > (). map < SimpleAction < MyVector >> ([]( int value ) { ltt :: stringstream str ; str << \"PushBack(\" << value << \")\" ; return SimpleAction ( str . str (), [ value ]( MyVector & obj ) { // ... }); }); Now you can see the actions are correctly printed: Falsifiable, after 1 tests: vec.size () < 5 ( test/test_state_func.cpp:111 ) with args: { [ 1882384569 , -1157159508, ..., 128 , 32768 , 840506558 ] , [ PushBack ( 1894834799 ) , PopBack, Clear, ..., PushBack ( 814265512 ) ] } Configuring stateful test runs \u00b6 You can alter some of test characteristics of stateful test runs. Random seed Number of runs Maximum time duration of test runs auto prop = statefulProperty (...); // set random seed prop . setSeed ( 5464561L ); // number of sequences to be tested prop . setNumRuns ( 10000 ); // maximum time duration for go() is 60 seconds prop . setMaxDurationMs ( 60 * 1000 ); prop . go (); // or you can simply chain the property: prop . setSeed ( 0 ). setNumRuns ( 1000 ). setMaxDurationMs ( 10000 ). go (); Alternative Style: Using Action Classes \u00b6 There are actually two styles of stateful testing - one with action functions(lambda) and one with action classes . While the first style using functions are easier to use and understand, the second style is more formal way of doing stateful testing. You may choose to use either style. Both have similar process of defining and running stateful tests. See the separate page for detail. Both styles are similar in terms of expressive power. Further topics \u00b6 See Concurrency Testing for testing for concurrent changes of a stateful object.","title":"Stateful Testing"},{"location":"StatefulTesting/#stateful-testing","text":"While property-based testing suits well with functions and stateless objects, it's also useful in testing for various state changes with ease. Typical properties we can test with stateful tests are as following: Test for consistency of internal state Test for memory leaks Test for concurrent accesses (see Concurrency Testing for more) The key idea of stateful testing with cppproptest is to generate state changes . Define action generators: Define action s that each represents unit of state change - e.g. For a numeric object, calling .multiply(int multiplier) method with a numeric multiplier as an argument, calling .divide(int divisor) method, etc. Build an action list generator: we then need a generator for the action types that can build a list of actions and pass required arguments to the selected actions Run the stateful test Say, you are to write stateful test for your MyVector , which is a linear container for integers. class MyVector { void push_back ( int val ); int pop_back (); int size (); int & at ( int pos ); void clear (); }; You first need to define actions for each state change.","title":"Stateful Testing"},{"location":"StatefulTesting/#using-action-functions","text":"An Action or a SimpleAction is formally defined as a functor object of the form: Action<ObjectType,ModelType> : ( ObjectType & , ModelType & ) -> void SimpleAction<ObjectType> : ( ObjectType & ) -> void ObjectType refers to the type of the stateful object of our concern. ModelType indicates an optional object type with which we'd like to check our stateful object. This additional object is called a model . For example, you can mark number of elements in a model to track the inserted or removed elements in a container object. Or you could closely compare your object with an already validated implementation that works similar to yours.","title":"Using Action Functions"},{"location":"StatefulTesting/#option-1-simpleaction-working-without-a-model","text":"( ObjectType & ) -> void You can use SimpleAction and its variant if you do not intend to use a model object. Let's discuss this simper variant first. The function takes an ObjectType reference. You will typically be defining a SimpleAction with a lambda. Our first goal is to create a generator for our action. A generator for an action with no arguments such as pop_back() can be defined as: #include \"statefultest.hpp\" // ... auto popBackGen = just ( SimpleAction < MyVector > ([]( MyVector & obj ) { obj . pop_back (); })); Notice the usage of just generator combinator which will always generate the same action. Compare with following push_back() 's action generator that requires an integer argument: auto pushBackGen = Arbi < int > (). map < SimpleAction < MyVector >> ([]( int value ) { return SimpleAction < MyVector > ([ value ]( MyVector & obj ) { obj . push_back ( value ); }); }); Here you can see an integer generator is transformed as an action generator. The outer lambda returns an action that calls push_back() with the integer argument value . You can add various assertions in the action. Any failed assertion will be reported and analyzed, as in ordinary property tests. With each action generator defined, we would typically combine these generators as one, using oneOf combinator: auto actionGen = oneOf < SimpleAction < MyAction >> ( pushBackGen , popBackGen , clearGen ); This will generate either of 3 actions, with evenly distributed probability (1/3). Finally, we can define a stateful property by calling statefulProperty<ObjectType>() . This method requires an initial state generator, and the actionGen we've just obtained. Calling statefulProperty::go() will execute the stateful property test. // we can generate initial object from an arbitrary, assuming we have an Arbi<MyVector> defined auto prop = statefulProperty < T > ( /* initial state generator */ Arbi < MyVector > (), /* action generator */ actionGen ); prop . go (); // ... // or, we can just initialize the object to an empty object auto prop = statefulProperty < T > ( /* initial state generator */ just < MyVector > ([]() { return MyVector (); }), /* action generator */ actionGen ); prop . go ();","title":"Option 1: SimpleAction - Working without a model"},{"location":"StatefulTesting/#putting-it-together","text":"class MyVector { void push_back ( int val ) { ... } int pop_back () { ... } int size () { ... } int & at ( int pos ) { ... } void clear () { ... } }; TEST ( MyVectorTest , Stateful ) { auto popBackGen = just ( SimpleAction < MyVector > ([]( MyVector & obj ) { if ( obj . size () == 0 ) return ; int size = obj . size (); obj . pop_back (); PROP_ASSERT ( obj . size () == size - 1 ); })); auto pushBackGen = Arbi < int > (). map < SimpleAction < MyVector >> ([]( int value ) { return [ value ]( MyVector & obj ) { int size = obj . size (); obj . push_back ( value ); PROP_ASSERT ( obj . size () == size + 1 ); }; }); auto clearGen = just ( SimpleAction < MyVector > ([]( MyVector & obj ) { obj . clear (); PROP_ASSERT ( obj . size () == 0 ); })); auto actionGen = oneOf < SimpleAction < MyVector >> ( pushBackGen , popBackGen , weightedGen < SimpleAction < MyVector >> ( clearGen , 0.1 )); // `oneOf` can take weights, so you can adjust rate of generation of an action // auto actionGen = oneOf<SimpleAction<MyVector>>(pushBackGen, popBackGen, weightedGen<SimpleAction<MyVector>>(clearGen, 0.1)); auto prop = statefulProperty < MyVector > ( /* initial state generator */ just < MyVector > ([]() { return MyVector (); }), /* action generator */ actionGen ); // Tests massive cases with randomly generated action sequences prop . go (); }","title":"Putting it together:"},{"location":"StatefulTesting/#option-2-action-working-with-a-model","text":"If you need a model for advanced tracking of state changes, use Action instead of SimpleAction . Action takes additional parameter indicating the model type. Let's define our model for tracking number of elements for MyVector // our simple model that tracks number of elements struct Counter { Counter ( int n ) : num ( n ) {} int num ; }; With this defined, we can continue defining our actions. auto popBackGen = just ( Action < MyVector , Counter > ([]( MyVector & obj , Counter & counter ) { if ( obj . size () == 0 ) return ; obj . pop_back (); counter . num -- ; })); You can use oneOf<Action<ObjectType, ModelType>> to get the combined action generator: auto actionGen = oneOf < Action < MyVector , Counter >> ( pushBackGen , popBackGen , clearGen ); Finally, we can define a stateful property by calling statefulProperty<ObjectType,ModelType>() . This method requires an initial state generator, and the actionGen we've just obtained. Compared to SimpleAction case, it additionally requires a model factory in the form of ObjectType& -> ModelType . This factory is to induce initial model from initial object. Calling statefulProperty::go() will execute the stateful property test. auto prop = statefulProperty < T > ( /* initial state generator */ Arbi < MyVector > (), /* model factory */ []( MyVector & vec ) { return Counter ( vec . size ()); }, /* action generator */ actionGen ); prop . go (); While the model in this example is simple, you may choose to use more complex ones. It's often a clever idea to use an existing, well validated implementation as model. For example, we could use ltt::vector<int> as model and perform the actions on both MyVector and ltt::vector . We assure MyVector works correctly by comparing element-wise with the ltt::vector model object that has undergone the same state changes.","title":"Option 2: Action - Working with a model"},{"location":"StatefulTesting/#putting-it-together_1","text":"class MyVector { void push_back ( int val ) { ... } int pop_back () { ... } int size () { ... } int & at ( int pos ) { ... } void clear () { ... } }; // our simple model that tracks number of elements struct Counter { Counter ( int n ) : num ( n ) {} int num ; }; TEST ( MyVectorTest , Stateful ) { auto popBackGen = just ( Action < MyVector , Counter > ([]( MyVector & obj , Counter & cnt ) { if ( obj . size () == 0 ) return ; obj . pop_back (); cnt . num -- ; PROP_ASSERT ( cnt . num == obj . size ()); })); auto pushBackGen = Arbi < int > (). map < Action < MyVector , Counter >> ([]( int value ) { return [ value ]( MyVector & obj ) { obj . push_back ( value ); cnt . num ++ ; PROP_ASSERT ( cnt . num == obj . size ()); }; }); auto clearGen = just ( Action < MyVector , Counter > ([]( MyVector & obj ) { obj . clear (); cnt . num = 0 ; PROP_ASSERT ( cnt . num == obj . size ()); })); // combine action generators auto actionGen = oneOf < Action < MyVector , Counter >> ( pushBackGen , popBackGen , clearGen ); // oneOf() can take weights, so you can adjust rate of generation of an action // auto actionGen = oneOf<Action<MyVector, Counter>>(pushBackGen, popBackGen, weightedGen<Action<MyVector, Counter>>(clearGen, 0.1)); auto prop = statefulProperty < MyVector , Counter > ( /* initial state generator */ Arbi < MyVector > (), /* initial model factory */ []( MyVector & vec ) { return Counter ( vec . size ()); }, /* action generator */ actionGen ); // Tests massive cases with randomly generated action sequences prop . go (); }","title":"Putting it together:"},{"location":"StatefulTesting/#debugging-stateful-test-failures","text":"A stateful test is succesful if all tried combinations were complete without issues. On the other hand, a failed assertion or an unexpected exception would end up with a stateful test failure. The framework will print the failed condition and tried input combinations so that you can debug the failure. Among the args , the first arg is the initial state, and the second one is the action list: Falsifiable, after 12 tests: vec.size () == count ( test/test_state_func.cpp:111 ) with args: { [ 1882384569 , -1157159508, ..., 128 , 32768 , 840506558 ] , [ Action<?>, Action<?>, Action<?>, ..., Action<?> ] } Note that, by default, an Action or a SimpleAction has no distinctive description. This is why there are indistinguishable Action<?> s printed in the action list. This can be avoided by prepending a description to each action constructor: // action with no argument auto clearGen = just ( SimpleAction < MyVector >> ( \"Clear\" , []( MyVector & obj ) { // ... })); // action with arguments can be printed nicely with a stringstream auto pushBackGen = Arbi < int > (). map < SimpleAction < MyVector >> ([]( int value ) { ltt :: stringstream str ; str << \"PushBack(\" << value << \")\" ; return SimpleAction ( str . str (), [ value ]( MyVector & obj ) { // ... }); }); Now you can see the actions are correctly printed: Falsifiable, after 1 tests: vec.size () < 5 ( test/test_state_func.cpp:111 ) with args: { [ 1882384569 , -1157159508, ..., 128 , 32768 , 840506558 ] , [ PushBack ( 1894834799 ) , PopBack, Clear, ..., PushBack ( 814265512 ) ] }","title":"Debugging stateful test failures"},{"location":"StatefulTesting/#configuring-stateful-test-runs","text":"You can alter some of test characteristics of stateful test runs. Random seed Number of runs Maximum time duration of test runs auto prop = statefulProperty (...); // set random seed prop . setSeed ( 5464561L ); // number of sequences to be tested prop . setNumRuns ( 10000 ); // maximum time duration for go() is 60 seconds prop . setMaxDurationMs ( 60 * 1000 ); prop . go (); // or you can simply chain the property: prop . setSeed ( 0 ). setNumRuns ( 1000 ). setMaxDurationMs ( 10000 ). go ();","title":"Configuring stateful test runs"},{"location":"StatefulTesting/#alternative-style-using-action-classes","text":"There are actually two styles of stateful testing - one with action functions(lambda) and one with action classes . While the first style using functions are easier to use and understand, the second style is more formal way of doing stateful testing. You may choose to use either style. Both have similar process of defining and running stateful tests. See the separate page for detail. Both styles are similar in terms of expressive power.","title":"Alternative Style: Using Action Classes"},{"location":"StatefulTesting/#further-topics","text":"See Concurrency Testing for testing for concurrent changes of a stateful object.","title":"Further topics"},{"location":"StatefulTestingStyle2/","text":"Stateful Testing \u00b6 Style 2: Using Action Classes \u00b6 Understanding Action \u00b6 In the second style, you will define actions by defining an Action or a SimpleAction abstract class with following signatures: template < typename ObjectType , typename ModelType > struct Action { virtual bool precondition ( const ObjectType & , const ModelType & ) { ... } virtual bool run ( ObjectType & , ModelType & ) { ... } }; template < typename ObjectType > struct SimpleAction { virtual bool precondition ( const ObjectType & ) { ... } virtual bool run ( ObjectType & ) { ... } }; ObjectType is the target stateful object type. In this case, MyVector is the ObjectType type. ModelType is optional structure to hold useful data for validation of the ObjectType based on some model, throughout the test sequence. You would prefer to use SimpleAction if you don't need a model structure, and Action if you need one. precondition is called to check if an action in the sequence is applicable to current state. If it's not the action is skipped. Overriding precondition is optional and returns true by default run is called to actually apply the state change and perform validations against your model after the state change template < typename ObjectType , typename ModelType > struct Action { virtual bool precondition ( const ObjectType & system , const ModelType & ) { ... } virtual bool run ( ObjectType & system , ModelType & ) { ... } }; Defining Actions \u00b6 For the listed methods that might change the state of a MyVector , we would write Action s for each. void push_back ( int val ); int pop_back (); int & at ( int pos ); void clear (); struct PushBack : public SimpleAction < MyVector > { int val ; PushBack ( int val ) : val ( val ) { } bool run ( MyVector & vector ) { vector . push_back ( val ); } }; struct PopBack : public SimpleAction < MyVector > { bool precondition ( MyVector & vector ) { return vector . size () > 0 ; } bool run ( MyVector & vector ) { vector . pop_back ( val ); } }; struct SetAt : public SimpleAction < MyVector > { int pos ; int val ; SetAt ( int pos , int val ) : pos ( pos ), val ( val ) { } bool precondition ( MyVector & vector ) { return pos < vector . size (); } bool run ( MyVector & vector ) { vector . at ( pos ) = val ; } }; struct Clear : public SimpleAction < MyVector > { bool run ( MyVector & vector ) { vector . clear ( val ); } }; Generating Action sequence \u00b6 With our Action s properly defined, we can generate a sequence of Action s. actionClasses function is a useful shorthand for oneOf generator combinator that is specialized for generating Action Sequences. auto actionListGen = actionListGenOf < SimpleAction < MyVector >> ( // int -> PushBack(int) transform < int , ltt :: shared_ptr < SimpleAction < MyVector >>> ( Arbi < int > (), []( const int & value ) { return ltt_adp :: make_shared < PushBack > ( value ); }), // Popback() just < ltt :: shared_ptr < SimpleAction < MyVector >>> ([]() { return ltt_adp :: make_shared < PopBack > (); }), // (int, int) -> SetAt(int, int) transform < int , ltt :: shared_ptr < SimpleAction < MyVector >>> ( Arbi < ltt :: pair < int , int >> (), []( const std : ; pair < int , int >& posAndVal ) { return ltt_adp :: make_shared < SetAt > ( posAndVal . first , posAndVal . second ); }), // Clear() just < ltt :: shared_ptr < SimpleAction < MyVector >>> ([]() { return ltt_adp :: make_shared < Clear > (); }) ); This defines a generator for action sequences that randomly chooses push_back , pop_back , at , and clear methods for MyVector with arguments. Running stateful tests \u00b6 Finally, we will call statefulProperty::forAll to perform generation of action sequences and run the tests. You should supply generator for initial state of MyVector to start with. auto prop = statefulProperty < SimpleAction < MyVector >> ( Arbi < MyVector > (), actionListGen ) prop . forAll ();","title":"[Stateful Testing](./StatefulTesting.md)"},{"location":"StatefulTestingStyle2/#stateful-testing","text":"","title":"Stateful Testing"},{"location":"StatefulTestingStyle2/#style-2-using-action-classes","text":"","title":"Style 2: Using Action Classes"},{"location":"StatefulTestingStyle2/#understanding-action","text":"In the second style, you will define actions by defining an Action or a SimpleAction abstract class with following signatures: template < typename ObjectType , typename ModelType > struct Action { virtual bool precondition ( const ObjectType & , const ModelType & ) { ... } virtual bool run ( ObjectType & , ModelType & ) { ... } }; template < typename ObjectType > struct SimpleAction { virtual bool precondition ( const ObjectType & ) { ... } virtual bool run ( ObjectType & ) { ... } }; ObjectType is the target stateful object type. In this case, MyVector is the ObjectType type. ModelType is optional structure to hold useful data for validation of the ObjectType based on some model, throughout the test sequence. You would prefer to use SimpleAction if you don't need a model structure, and Action if you need one. precondition is called to check if an action in the sequence is applicable to current state. If it's not the action is skipped. Overriding precondition is optional and returns true by default run is called to actually apply the state change and perform validations against your model after the state change template < typename ObjectType , typename ModelType > struct Action { virtual bool precondition ( const ObjectType & system , const ModelType & ) { ... } virtual bool run ( ObjectType & system , ModelType & ) { ... } };","title":"Understanding Action"},{"location":"StatefulTestingStyle2/#defining-actions","text":"For the listed methods that might change the state of a MyVector , we would write Action s for each. void push_back ( int val ); int pop_back (); int & at ( int pos ); void clear (); struct PushBack : public SimpleAction < MyVector > { int val ; PushBack ( int val ) : val ( val ) { } bool run ( MyVector & vector ) { vector . push_back ( val ); } }; struct PopBack : public SimpleAction < MyVector > { bool precondition ( MyVector & vector ) { return vector . size () > 0 ; } bool run ( MyVector & vector ) { vector . pop_back ( val ); } }; struct SetAt : public SimpleAction < MyVector > { int pos ; int val ; SetAt ( int pos , int val ) : pos ( pos ), val ( val ) { } bool precondition ( MyVector & vector ) { return pos < vector . size (); } bool run ( MyVector & vector ) { vector . at ( pos ) = val ; } }; struct Clear : public SimpleAction < MyVector > { bool run ( MyVector & vector ) { vector . clear ( val ); } };","title":"Defining Actions"},{"location":"StatefulTestingStyle2/#generating-action-sequence","text":"With our Action s properly defined, we can generate a sequence of Action s. actionClasses function is a useful shorthand for oneOf generator combinator that is specialized for generating Action Sequences. auto actionListGen = actionListGenOf < SimpleAction < MyVector >> ( // int -> PushBack(int) transform < int , ltt :: shared_ptr < SimpleAction < MyVector >>> ( Arbi < int > (), []( const int & value ) { return ltt_adp :: make_shared < PushBack > ( value ); }), // Popback() just < ltt :: shared_ptr < SimpleAction < MyVector >>> ([]() { return ltt_adp :: make_shared < PopBack > (); }), // (int, int) -> SetAt(int, int) transform < int , ltt :: shared_ptr < SimpleAction < MyVector >>> ( Arbi < ltt :: pair < int , int >> (), []( const std : ; pair < int , int >& posAndVal ) { return ltt_adp :: make_shared < SetAt > ( posAndVal . first , posAndVal . second ); }), // Clear() just < ltt :: shared_ptr < SimpleAction < MyVector >>> ([]() { return ltt_adp :: make_shared < Clear > (); }) ); This defines a generator for action sequences that randomly chooses push_back , pop_back , at , and clear methods for MyVector with arguments.","title":"Generating Action sequence"},{"location":"StatefulTestingStyle2/#running-stateful-tests","text":"Finally, we will call statefulProperty::forAll to perform generation of action sequences and run the tests. You should supply generator for initial state of MyVector to start with. auto prop = statefulProperty < SimpleAction < MyVector >> ( Arbi < MyVector > (), actionListGen ) prop . forAll ();","title":"Running stateful tests"},{"location":"WhyPropertyBasedTesting/","text":"Why Property-based testing? \u00b6 Generalization and abstraction \u00b6 Property-based testing, or PBT in short, lets you write a test using abstract idea, instead of some dummy examples or contrived scenarios that are easy to break over time and hard to interpret. You can write tests using specification or requirements - which are essentially expressed as combination of input domain and expected behavior (=properties) of tested component. Clear separation of variants and invariants \u00b6 Describing a test using input domain and expected behavior means that we have clear cut between variants and invariants. We often mix variants and invariants in our tests in typical example-based tests . This is one of the reasons why those tests become hard to maintain and difficult to read over time. In property-based tests, however, we clearly separate invariants as properties and variants as input domain. Thus tests become more readable and gets easier to maintain, as they carry test writers' intention better. Convenience and versatility \u00b6 Property-based testing often provides with the convenient out-of-box generators (sometimes called strategies ) and combinators (that lets you make new generators out of existing ones), and lets you to effortlessly define the input domain for your tests. You can specify your input domains using various notions - range, constraint, union, transformation, composition, and dependency, just to name a few. Reusability and Scalability \u00b6 As it defines input domain with generators and combinators, Property-based testing lets you define and reuse existing input domain and properties to build new input domain and properties with ease. These new ones then can be reused as building blocks for next tests and so on. Reusable nature of property-based testing lets you write tests with scale. Complex combinations of components can be readily tested if simpler pieces are already available by tests written previously.","title":"Why Property-based testing?"},{"location":"WhyPropertyBasedTesting/#why-property-based-testing","text":"","title":"Why Property-based testing?"},{"location":"WhyPropertyBasedTesting/#generalization-and-abstraction","text":"Property-based testing, or PBT in short, lets you write a test using abstract idea, instead of some dummy examples or contrived scenarios that are easy to break over time and hard to interpret. You can write tests using specification or requirements - which are essentially expressed as combination of input domain and expected behavior (=properties) of tested component.","title":"Generalization and abstraction"},{"location":"WhyPropertyBasedTesting/#clear-separation-of-variants-and-invariants","text":"Describing a test using input domain and expected behavior means that we have clear cut between variants and invariants. We often mix variants and invariants in our tests in typical example-based tests . This is one of the reasons why those tests become hard to maintain and difficult to read over time. In property-based tests, however, we clearly separate invariants as properties and variants as input domain. Thus tests become more readable and gets easier to maintain, as they carry test writers' intention better.","title":"Clear separation of variants and invariants"},{"location":"WhyPropertyBasedTesting/#convenience-and-versatility","text":"Property-based testing often provides with the convenient out-of-box generators (sometimes called strategies ) and combinators (that lets you make new generators out of existing ones), and lets you to effortlessly define the input domain for your tests. You can specify your input domains using various notions - range, constraint, union, transformation, composition, and dependency, just to name a few.","title":"Convenience and versatility"},{"location":"WhyPropertyBasedTesting/#reusability-and-scalability","text":"As it defines input domain with generators and combinators, Property-based testing lets you define and reuse existing input domain and properties to build new input domain and properties with ease. These new ones then can be reused as building blocks for next tests and so on. Reusable nature of property-based testing lets you write tests with scale. Complex combinations of components can be readily tested if simpler pieces are already available by tests written previously.","title":"Reusability and Scalability"},{"location":"WhyPropertyBasedTesting2/","text":"An attempt to approximate software quality \u00b6 Property-based testing, or sometimes refered to as specification-based testing , tries to verify software's integrity by validating the requirements of a software component, where the requirements are often written as properties (or specifications ). They are validated using massive input combinations. // encode & decode are inverse functions ASSERT ( decode ( encode ( text )) == text ); Many property-based testing implementations derive their ideas from QuickCheck , which was originally written in Haskell. Quickcheck's basic idea is to quickly prove a theorem , as the name suggests. But how can anything possibly be proved about software? A software piece is often too complex to reason about in definitive way. If we randomly choose 100 input combinations to test your component and confirm that it satisfies the required properties with every 100 of the combinations, you may argue that it's still not proving anything. But how about if we increase the number of combinations to 1,000, or 10,000? Certainly there still remains some possibility that one of the untested input combinations might fail the properties. But we can say this as an approximation - an approximation of software integrity or quality. As the number of evidences grows, more accurate the approximation it becomes. It's often very effective to approximate an answer when it cannot be easily obtained. It's sometimes the only feasible way. Property-based testing can do exactly that. You define a property (or 'specification') of a software component should satisfy, then you can let the test library prove or disprove that requirement automatically by feeding in random (but valid) input combinations. In fact, often the underlying issues of a component are easily detected than you can imagine. Some properties may hold true with a few combinations, but such luck usually cannot last for long. The issues reveal themselves eventually. In property-based testing, software requirements can be validated in automated fashion as in static code analyses, but by actually running the code as in dynamic code analyses. By actually running the code, we can check for many software requirements and issues that are usually not feasible to find with static code analyses. Why property-based testing for C++? \u00b6 Property-based tesing relies on massive input combinations to be attempted to achieve high confidence. For example, if you have a function with 10 boolean flags to be thoroughly tested in runtime, you need to test it with 2 10 = 1024 combinations. This kind of complexity has been often considered as unmanageable and something that should be avoided. However, as most C++ unit components (as single unit or multiple components combined) tend to execute blazingly fast on modern machines, running them 1000 times is usually not an issue. Unless it's involving external devices like secondary disk or network communication, running a typical C++ component 1000 times would normally end up finishing under a second barrier. This is why C++ and property-based testing is a fine pair. I feel many of the existing property-based testing implementation in C++ are either outdated or too daunting to learn due to their complexity. cppproptest focuses on lowering the learning curve while maintaining feature-completeness.","title":"WhyPropertyBasedTesting2"},{"location":"WhyPropertyBasedTesting2/#an-attempt-to-approximate-software-quality","text":"Property-based testing, or sometimes refered to as specification-based testing , tries to verify software's integrity by validating the requirements of a software component, where the requirements are often written as properties (or specifications ). They are validated using massive input combinations. // encode & decode are inverse functions ASSERT ( decode ( encode ( text )) == text ); Many property-based testing implementations derive their ideas from QuickCheck , which was originally written in Haskell. Quickcheck's basic idea is to quickly prove a theorem , as the name suggests. But how can anything possibly be proved about software? A software piece is often too complex to reason about in definitive way. If we randomly choose 100 input combinations to test your component and confirm that it satisfies the required properties with every 100 of the combinations, you may argue that it's still not proving anything. But how about if we increase the number of combinations to 1,000, or 10,000? Certainly there still remains some possibility that one of the untested input combinations might fail the properties. But we can say this as an approximation - an approximation of software integrity or quality. As the number of evidences grows, more accurate the approximation it becomes. It's often very effective to approximate an answer when it cannot be easily obtained. It's sometimes the only feasible way. Property-based testing can do exactly that. You define a property (or 'specification') of a software component should satisfy, then you can let the test library prove or disprove that requirement automatically by feeding in random (but valid) input combinations. In fact, often the underlying issues of a component are easily detected than you can imagine. Some properties may hold true with a few combinations, but such luck usually cannot last for long. The issues reveal themselves eventually. In property-based testing, software requirements can be validated in automated fashion as in static code analyses, but by actually running the code as in dynamic code analyses. By actually running the code, we can check for many software requirements and issues that are usually not feasible to find with static code analyses.","title":"An attempt to approximate software quality"},{"location":"WhyPropertyBasedTesting2/#why-property-based-testing-for-c","text":"Property-based tesing relies on massive input combinations to be attempted to achieve high confidence. For example, if you have a function with 10 boolean flags to be thoroughly tested in runtime, you need to test it with 2 10 = 1024 combinations. This kind of complexity has been often considered as unmanageable and something that should be avoided. However, as most C++ unit components (as single unit or multiple components combined) tend to execute blazingly fast on modern machines, running them 1000 times is usually not an issue. Unless it's involving external devices like secondary disk or network communication, running a typical C++ component 1000 times would normally end up finishing under a second barrier. This is why C++ and property-based testing is a fine pair. I feel many of the existing property-based testing implementation in C++ are either outdated or too daunting to learn due to their complexity. cppproptest focuses on lowering the learning curve while maintaining feature-completeness.","title":"Why property-based testing for C++?"}]}